-- Liquibase-managed PostgreSQL schema for Memory Service
-- Copied from the top-level schema.sql specification.

-- PostgreSQL schema for Memory Service
-- UUID values are generated by the application; the database does not rely
-- on the uuid-ossp extension. If pgvector is used, enable it separately
-- where appropriate (e.g., via migrations or deployment scripts).
-- Example (optional): CREATE EXTENSION IF NOT EXISTS vector;

-- Conversations & ownership
-------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_groups (
    id              UUID PRIMARY KEY,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS conversations (
    id              UUID PRIMARY KEY,
    title           BYTEA,
    -- External user identifier (e.g., OAuth subject); no local users table.
    owner_user_id   TEXT NOT NULL,
    metadata        JSONB NOT NULL DEFAULT '{}'::JSONB,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    forked_at_entry_id UUID,
    forked_at_conversation_id UUID REFERENCES conversations (id) ON DELETE CASCADE,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    vectorized_at   TIMESTAMPTZ,
    deleted_at      TIMESTAMPTZ
);

-- Per-user access to conversations.
-- Exactly one row per conversation with access_level = 'owner'.
-- Memberships are hard-deleted (not soft-deleted) with audit logging.
CREATE TABLE IF NOT EXISTS conversation_memberships (
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifier (e.g., OAuth subject); no local users table.
    user_id           TEXT NOT NULL,
    access_level      TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (conversation_group_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_user
    ON conversation_memberships (user_id, conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_group
    ON conversation_memberships (conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversation_groups_not_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_conversations_not_deleted
    ON conversations (deleted_at) WHERE deleted_at IS NULL;

-- Index for eviction queries (deleted records past retention)
CREATE INDEX IF NOT EXISTS idx_conversation_groups_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NOT NULL;

------------------------------------------------------------
-- Entries & summaries
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS entries (
    id                UUID PRIMARY KEY,
    conversation_id   UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    user_id           TEXT,
    client_id         TEXT,
    channel           TEXT NOT NULL,
    epoch             BIGINT,
    content_type      TEXT NOT NULL,
    content           BYTEA NOT NULL,
    indexed_content   TEXT,
    indexed_at        TIMESTAMPTZ,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for finding unindexed history entries (batch indexing job)
CREATE INDEX IF NOT EXISTS idx_entries_unindexed
    ON entries (channel, created_at)
    WHERE indexed_content IS NULL;

-- Index for finding entries pending vector store indexing (retry task)
CREATE INDEX IF NOT EXISTS idx_entries_pending_vector_indexing
    ON entries (indexed_at)
    WHERE indexed_content IS NOT NULL AND indexed_at IS NULL;

-- Full-text search support: generated tsvector column for GIN index
-- Automatically maintained when indexed_content changes
ALTER TABLE entries ADD COLUMN IF NOT EXISTS indexed_content_tsv tsvector
    GENERATED ALWAYS AS (to_tsvector('english', COALESCE(indexed_content, ''))) STORED;

-- GIN index for fast full-text search
CREATE INDEX IF NOT EXISTS idx_entries_indexed_content_fts
    ON entries USING GIN (indexed_content_tsv);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_created_at
    ON entries (conversation_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_group_created_at
    ON entries (conversation_group_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_channel_client_epoch_created_at
    ON entries (conversation_id, channel, client_id, epoch, created_at);

CREATE INDEX IF NOT EXISTS idx_conversations_group
    ON conversations (conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_conversation
    ON conversations (forked_at_conversation_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_entry
    ON conversations (forked_at_entry_id);

------------------------------------------------------------
-- Semantic search (pgvector-backed, optional)
------------------------------------------------------------

-- If pgvector is enabled, uncomment the extension above and this table.
-- Embeddings are associated with individual entries.
-- CREATE TABLE IF NOT EXISTS entry_embeddings (
--     entry_id         UUID PRIMARY KEY REFERENCES entries (id) ON DELETE CASCADE,
--     conversation_id  UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
--     -- Adjust dimension to match the configured embedding model.
--     embedding        vector(768) NOT NULL,
--     created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW()
-- );
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_conversation
--     ON entry_embeddings (conversation_id);
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_embedding
--     ON entry_embeddings
--     USING ivfflat (embedding vector_cosine_ops)
--     WITH (lists = 100);

------------------------------------------------------------
-- Ownership transfer tracking
-- Transfers are always "pending" while they exist; accepted/rejected transfers are hard deleted.
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_ownership_transfers (
    id                UUID PRIMARY KEY,
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifiers (e.g., OAuth subjects).
    from_user_id      TEXT NOT NULL,
    to_user_id        TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- Only one pending transfer per conversation (transfer is deleted when accepted/rejected)
    CONSTRAINT unique_transfer_per_conversation UNIQUE (conversation_group_id),
    CONSTRAINT different_users CHECK (from_user_id != to_user_id)
);

-- Index for listing user's transfers as recipient
CREATE INDEX IF NOT EXISTS idx_ownership_transfers_to_user
    ON conversation_ownership_transfers (to_user_id);

-- Index for listing user's transfers as sender
CREATE INDEX IF NOT EXISTS idx_ownership_transfers_from_user
    ON conversation_ownership_transfers (from_user_id);

------------------------------------------------------------
-- Background task queue
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS tasks (
    id              UUID PRIMARY KEY,
    task_name       TEXT UNIQUE,
    task_type       TEXT NOT NULL,
    task_body       JSONB NOT NULL,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    retry_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_error      TEXT,
    retry_count     INT NOT NULL DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_tasks_ready
    ON tasks (task_type, retry_at);

-- Unique partial index for singleton tasks (allows multiple NULL task_name values)
CREATE UNIQUE INDEX IF NOT EXISTS idx_tasks_name
    ON tasks (task_name) WHERE task_name IS NOT NULL;

------------------------------------------------------------
-- Attachments
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS attachments (
    id              UUID PRIMARY KEY,
    storage_key     VARCHAR(255),
    filename        VARCHAR(255),
    content_type    VARCHAR(127) NOT NULL,
    size            BIGINT,
    sha256          VARCHAR(64),
    user_id         TEXT NOT NULL,
    entry_id        UUID REFERENCES entries(id) ON DELETE CASCADE,
    expires_at      TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_attachments_expires_at
    ON attachments(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_entry_id
    ON attachments(entry_id) WHERE entry_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_storage_key
    ON attachments(storage_key) WHERE storage_key IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_deleted_at
    ON attachments(deleted_at) WHERE deleted_at IS NOT NULL;

-- Liquibase-managed PostgreSQL schema for Memory Service
-- Copied from the top-level schema.sql specification.

-- PostgreSQL schema for Memory Service
-- UUID values are generated by the application; the database does not rely
-- on the uuid-ossp extension. If pgvector is used, enable it separately
-- where appropriate (e.g., via migrations or deployment scripts).
-- Example (optional): CREATE EXTENSION IF NOT EXISTS vector;

-- Conversations & ownership
-------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_groups (
    id              UUID PRIMARY KEY,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS conversations (
    id              UUID PRIMARY KEY,
    title           BYTEA,
    -- External user identifier (e.g., OAuth subject); no local users table.
    owner_user_id   TEXT NOT NULL,
    metadata        JSONB NOT NULL DEFAULT '{}'::JSONB,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    forked_at_entry_id UUID,
    forked_at_conversation_id UUID REFERENCES conversations (id) ON DELETE CASCADE,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    vectorized_at   TIMESTAMPTZ,
    deleted_at      TIMESTAMPTZ
);

-- Per-user access to conversations.
-- Exactly one row per conversation with access_level = 'owner'.
CREATE TABLE IF NOT EXISTS conversation_memberships (
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifier (e.g., OAuth subject); no local users table.
    user_id           TEXT NOT NULL,
    access_level      TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at        TIMESTAMPTZ,
    PRIMARY KEY (conversation_group_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_user
    ON conversation_memberships (user_id, conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversation_groups_not_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_conversations_not_deleted
    ON conversations (deleted_at) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_not_deleted
    ON conversation_memberships (deleted_at) WHERE deleted_at IS NULL;

-- Indexes for eviction queries (deleted records past retention)
CREATE INDEX IF NOT EXISTS idx_conversation_groups_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_deleted
    ON conversation_memberships (deleted_at) WHERE deleted_at IS NOT NULL;

------------------------------------------------------------
-- Entries & summaries
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS entries (
    id                UUID PRIMARY KEY,
    conversation_id   UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    user_id           TEXT,
    client_id         TEXT,
    channel           TEXT NOT NULL,
    epoch             BIGINT,
    content_type      TEXT NOT NULL,
    content           BYTEA NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_created_at
    ON entries (conversation_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_group_created_at
    ON entries (conversation_group_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_channel_client_epoch_created_at
    ON entries (conversation_id, channel, client_id, epoch, created_at);

CREATE INDEX IF NOT EXISTS idx_conversations_group
    ON conversations (conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_conversation
    ON conversations (forked_at_conversation_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_entry
    ON conversations (forked_at_entry_id);

------------------------------------------------------------
-- Semantic search (pgvector-backed, optional)
------------------------------------------------------------

-- If pgvector is enabled, uncomment the extension above and this table.
-- Embeddings are associated with individual entries.
-- CREATE TABLE IF NOT EXISTS entry_embeddings (
--     entry_id         UUID PRIMARY KEY REFERENCES entries (id) ON DELETE CASCADE,
--     conversation_id  UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
--     -- Adjust dimension to match the configured embedding model.
--     embedding        vector(768) NOT NULL,
--     created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW()
-- );
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_conversation
--     ON entry_embeddings (conversation_id);
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_embedding
--     ON entry_embeddings
--     USING ivfflat (embedding vector_cosine_ops)
--     WITH (lists = 100);

------------------------------------------------------------
-- Ownership transfer tracking
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_ownership_transfers (
    id                UUID PRIMARY KEY,
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifiers (e.g., OAuth subjects).
    from_user_id      TEXT NOT NULL,
    to_user_id        TEXT NOT NULL,
    status            TEXT NOT NULL DEFAULT 'pending',
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_ownership_transfers_to_user
    ON conversation_ownership_transfers (to_user_id, status);

------------------------------------------------------------
-- Background task queue
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS tasks (
    id              UUID PRIMARY KEY,
    task_type       TEXT NOT NULL,
    task_body       JSONB NOT NULL,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    retry_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_error      TEXT,
    retry_count     INT NOT NULL DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_tasks_ready 
    ON tasks (task_type, retry_at);

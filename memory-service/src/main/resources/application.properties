# Enable PostgreSQL dev service for the memory-service container to use
quarkus.datasource.db-kind=postgresql
quarkus.datasource.devservices.enabled=true
quarkus.datasource.devservices.db-name=memory_service
# To be able to use the pgvector dev service, we need to set the image name
quarkus.datasource.devservices.image-name=pgvector/pgvector:pg17

# Migrations: routed to the correct Liquibase backend by DatastoreConfigSourceFactory
memory-service.datastore.migrate-at-start=true
quarkus.liquibase.change-log=db/changelog/db.changelog-master.yaml

# Prefer JSONB for JSON mappings on PostgreSQL
hibernate.type.preferred_json_format=jsonb

# Use built-in JSON mapping for DB only, ignore REST-specific formatting customization
quarkus.hibernate-orm.mapping.format.global=ignore

# Memory service provider selection
memory-service.datastore.type=postgres
memory-service.cache.type=none
memory-service.cache.epoch.ttl=PT10M
memory-service.vector.type=none

# Embedding configuration (uses in-process all-MiniLM-L6-v2 model, 384 dimensions)
memory-service.embedding.enabled=true

# Search method availability (default: both enabled)
# Set to false to disable a search method and return errors when requested
memory-service.search.semantic.enabled=true
memory-service.search.fulltext.enabled=true

# OIDC / Keycloak configuration (following Quarkus Keycloak authorization guide)
# In production (e.g., docker-compose), use the Keycloak realm backing the memory service.
%prod.quarkus.oidc.auth-server-url=http://keycloak:8080/realms/memory-service
quarkus.oidc.client-id=memory-service-client
quarkus.oidc.credentials.secret=${KEYCLOAK_CLIENT_SECRET:change-me}
quarkus.oidc.application-type=service
quarkus.oidc.roles.source=accesstoken

quarkus.smallrye-openapi.path=/q/openapi

quarkus.http.auth.permission.authenticated.paths=/*
quarkus.http.auth.permission.authenticated.methods=GET,POST,PUT,PATCH,DELETE,HEAD
quarkus.http.auth.permission.authenticated.policy=authenticated

# MongoDB configuration (used when memory-service.datastore.type=mongo or mongodb)
quarkus.mongodb.database=memory_service

# MongoDB Liquibase changelog (migration enabled/disabled via memory-service.migrations.enabled)
quarkus.liquibase-mongodb.change-log=db/changelog-mongodb/db.changelog-master.yaml

# Data encryption configuration - Uses the plain provider unless overridden
data.encryption.providers=plain
data.encryption.provider.plain.type=plain

# API keys that can be used by trusted agents (e.g., MemoryServiceChatMemory).
# Each client id can have one or more keys:
# memory-service.api-keys.agent-a=agent-a-key-1,agent-a-key-2
# memory-service.api-keys.agent-b=agent-b-key-1

# Enable HTTP access logging
quarkus.http.access-log.enabled=true

quarkus.log.level=INFO

quarkus.log.category."io.quarkus.http.access-log".level=INFO
quarkus.log.category."io.github.chirino.memory".level=INFO
#quarkus.log.category."io.github.chirino.memory.membership.audit".level=INFO
#quarkus.log.category."io.github.chirino.memory.response".level=INFO
quarkus.log.category."io.github.chirino.memory.grpc".level=WARN

# Uncomment the following to enable more detailed logging for OIDC and JWT.
# quarkus.log.category."io.quarkus.oidc".level=DEBUG
# quarkus.log.category."io.quarkus.oidc.runtime".level=DEBUG
# quarkus.log.category."io.smallrye.jwt".level=DEBUG
# quarkus.log.category."io.smallrye.jwt.auth".level=DEBUG
# quarkus.log.category."io.vertx.ext.auth".level=DEBUG

quarkus.grpc.server.use-separate-server=false
quarkus.grpc.server.grpc-health.enabled=true
quarkus.grpc.server.enable-reflection-service=true
quarkus.generate-code.grpc.scan-for-proto=io.github.chirino.memory-service:memory-service-proto-quarkus

# Public paths (accessible without authentication)
quarkus.http.auth.permission.public.paths=/q/*,/v1/health,/v1/attachments/download/*
quarkus.http.auth.permission.public.policy=permit

# Allow CORS preflight requests without authentication
quarkus.http.auth.permission.cors-preflight.paths=/*
quarkus.http.auth.permission.cors-preflight.methods=OPTIONS
quarkus.http.auth.permission.cors-preflight.policy=permit

# Delay authentication until required (allows CORS preflight to work)
quarkus.http.auth.proactive=false

# Admin path requires authentication (role checking is application-level)
quarkus.http.auth.permission.admin.paths=/v1/admin/*
quarkus.http.auth.permission.admin.methods=GET,POST,PUT,PATCH,DELETE,HEAD
quarkus.http.auth.permission.admin.policy=authenticated

# Admin audit justification (default: optional)
memory-service.admin.require-justification=false

# Role mapping defaults (uncomment to customize)
# memory-service.roles.admin.oidc.role=admin
# memory-service.roles.auditor.oidc.role=auditor
# memory-service.roles.admin.users=
# memory-service.roles.auditor.users=
# memory-service.roles.admin.clients=
# memory-service.roles.auditor.clients=

# Prometheus configuration for admin stats endpoints
# When not configured, admin stats endpoints return 501 Not Implemented
# memory-service.prometheus.url=http://prometheus:9090
quarkus.rest-client.prometheus.url=${memory-service.prometheus.url:http://localhost:9090}
quarkus.rest-client.prometheus.scope=jakarta.inject.Singleton

# Attachment storage (quarkus.http.limits.max-body-size is auto-derived as 2x this value)
memory-service.attachments.max-size=10M
memory-service.attachments.default-expires-in=PT1H
memory-service.attachments.max-expires-in=PT24H
memory-service.attachments.upload-expires-in=PT1M
memory-service.attachments.upload-refresh-interval=PT30S
memory-service.attachments.cleanup-interval=PT5M
memory-service.attachments.store=db
memory-service.attachments.download-url-expires-in=PT5M

# S3 FileStore configuration (when memory-service.attachments.store=s3)
quarkus.s3.devservices.enabled=false
memory-service.attachments.s3.bucket=memory-service-attachments

# Task processor configuration
memory-service.tasks.retry-delay=PT10M
memory-service.tasks.processor-interval=1m
memory-service.tasks.batch-size=100
memory-service.tasks.stale-claim-timeout=PT5M

# Eviction configuration
memory-service.eviction.batch-size=1000
memory-service.eviction.batch-delay-ms=100

# Satisfy Redis extension validation in prod when Redis is not deployed
# (overridden by QUARKUS_REDIS_HOSTS env var when Redis kustomize component is used)
%prod.quarkus.redis.hosts=redis://localhost:6379
%prod.quarkus.redis.health.enabled=false

%test.quarkus.datasource.db-kind=postgresql
%test.quarkus.redis.devservices.enabled=true
%test.memory-service.cache.type=redis

# CORS configuration (disabled by default, enable via MEMORY_SERVICE_CORS_ENABLED=true and MEMORY_SERVICE_CORS_ORIGINS)
memory-service.cors.enabled=false
memory-service.cors.methods=GET,POST,PUT,PATCH,DELETE,OPTIONS
memory-service.cors.headers=accept,authorization,content-type,x-requested-with
memory-service.cors.exposed-headers=content-type,authorization
memory-service.cors.access-control-allow-credentials=true

# Keycloak dev services - expose on port 8081 and import realm (dev profile only)
%dev.quarkus.keycloak.devservices.enabled=true
%dev.quarkus.keycloak.devservices.port=8081
%dev.quarkus.keycloak.devservices.realm-path=../deploy/keycloak/memory-service-realm.json

%dev.quarkus.http.port=8082
%dev.memory-service.api-keys.port=8082   
%dev.memory-service.api-keys.agent=agent-api-key-1
%dev.memory-service.roles.admin.oidc.role=admin
%dev.memory-service.roles.auditor.oidc.role=auditor
%dev.memory-service.roles.indexer.clients=agent
%dev.memory-service.cors.enabled=true
%dev.memory-service.cors.origins=http://localhost:3000

%dev.quarkus.datasource.db-kind=postgresql
%dev.quarkus.redis.devservices.enabled=true
%dev.memory-service.cache.type=redis

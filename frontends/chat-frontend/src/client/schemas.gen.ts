// This file is auto-generated by @hey-api/openapi-ts

export const $ErrorResponse = {
  type: "object",
  properties: {
    error: {
      type: "string",
    },
    code: {
      type: "string",
    },
    details: {
      type: "object",
      additionalProperties: true,
    },
  },
} as const;

export const $SearchTypeUnavailableError = {
  type: "object",
  description: "Error response when the requested search type is not available on the server.",
  properties: {
    error: {
      type: "string",
      description: "Error code.",
      example: "search_type_unavailable",
    },
    message: {
      type: "string",
      description: "Human-readable error message.",
      example: "Semantic search is not available. The embedding service is disabled on this server.",
    },
    availableTypes: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of search types that are available on this server.",
      example: ["fulltext"],
    },
  },
} as const;

export const $AccessLevel = {
  type: "string",
  description: "Access level of a user for a conversation.",
  enum: ["owner", "manager", "writer", "reader"],
} as const;

export const $ConversationSummary = {
  type: "object",
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    ownerUserId: {
      type: "string",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      format: "date-time",
    },
    lastMessagePreview: {
      type: "string",
      nullable: true,
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
  },
  example: {
    id: "550e8400-e29b-41d4-a716-446655440000",
    title: "Brainstorming UI for memory service",
    ownerUserId: "user_1234",
    createdAt: "2025-01-10T14:32:05Z",
    updatedAt: "2025-01-10T14:45:12Z",
    lastMessagePreview: "Let's try modeling forks as separate conversations…",
    accessLevel: "owner",
  },
} as const;

export const $Conversation = {
  allOf: [
    {
      $ref: "#/components/schemas/ConversationSummary",
    },
    {
      type: "object",
      properties: {
        forkedAtEntryId: {
          type: "string",
          format: "uuid",
          nullable: true,
          description: "Entry ID where this conversation forked from its parent.",
        },
        forkedAtConversationId: {
          type: "string",
          format: "uuid",
          nullable: true,
          description: "Conversation ID from which this conversation was forked.",
        },
      },
      example: {
        id: "550e8400-e29b-41d4-a716-446655440000",
        title: "Brainstorming UI for memory service",
        ownerUserId: "user_1234",
        createdAt: "2025-01-10T14:32:05Z",
        updatedAt: "2025-01-10T14:45:12Z",
        lastMessagePreview: "Let's try modeling forks as separate conversations…",
        accessLevel: "owner",
        forkedAtEntryId: null,
        forkedAtConversationId: null,
      },
    },
  ],
} as const;

export const $CreateConversationRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
      maxLength: 500,
    },
    metadata: {
      type: "object",
      additionalProperties: true,
    },
  },
  example: {
    title: "Chat with support bot",
    metadata: {
      source: "web-chat",
      projectId: "proj_7890",
    },
  },
} as const;

export const $UpdateConversationRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
      maxLength: 500,
    },
  },
} as const;

export const $ConversationMembership = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation.",
    },
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ConversationForkSummary = {
  type: "object",
  description: "Summary of a forked conversation originating at a given entry.",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the forked conversation.",
    },
    forkedAtEntryId: {
      type: "string",
      format: "uuid",
      description: "Entry ID at which this forked conversation diverged.",
    },
    forkedAtConversationId: {
      type: "string",
      format: "uuid",
      nullable: true,
      description: "Conversation ID where the fork occurred.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ShareConversationRequest = {
  type: "object",
  required: ["userId", "accessLevel"],
  properties: {
    userId: {
      type: "string",
      minLength: 1,
      maxLength: 255,
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $Channel = {
  type: "string",
  description: "Logical channel of the entry within the conversation.",
  enum: ["history", "memory"],
} as const;

export const $Attachment = {
  type: "object",
  description: `A reference to an attachment on a history entry. Supports two modes:

**External URL (Phase 1)**: Provide \`href\` and \`contentType\` to reference
an externally-hosted resource.

**Server-stored (Phase 2)**: Provide \`attachmentId\` to reference a file
previously uploaded via \`POST /v1/attachments\`. When the entry is created,
the server replaces \`attachmentId\` with an \`href\` pointing to
\`/v1/attachments/{id}\`.

At least one of \`href\` or \`attachmentId\` must be present.`,
  properties: {
    href: {
      type: "string",
      format: "uri",
      description: "URL to the attachment resource (external or server-relative).",
    },
    attachmentId: {
      type: "string",
      description: `ID of a previously uploaded attachment (from POST /v1/attachments).
When the entry is created, this is replaced with an href.`,
    },
    contentType: {
      type: "string",
      description:
        'MIME type of the attachment (e.g., "image/jpeg", "audio/mp3"). Required when href is provided directly.',
    },
    name: {
      type: "string",
      description: "Optional display name for the attachment.",
    },
    description: {
      type: "string",
      description: "Optional alt text or description.",
    },
    size: {
      type: "integer",
      format: "int64",
      description: "File size in bytes (set by server for uploaded attachments).",
    },
    sha256: {
      type: "string",
      description: "SHA-256 hash of the file content (set by server for uploaded attachments).",
    },
  },
} as const;

export const $CreateFromUrlRequest = {
  type: "object",
  description: "Request to create an attachment from a source URL.",
  required: ["sourceUrl"],
  properties: {
    sourceUrl: {
      type: "string",
      format: "uri",
      description: "URL of the content to download and store as an attachment.",
    },
    contentType: {
      type: "string",
      description: "MIME type of the content. Defaults to application/octet-stream.",
    },
    name: {
      type: "string",
      description: "Display name for the attachment.",
    },
  },
  example: {
    sourceUrl: "https://example.com/generated-image.png",
    contentType: "image/png",
    name: "generated-cat.png",
  },
} as const;

export const $AttachmentUploadResponse = {
  type: "object",
  description: "Response from uploading or creating an attachment.",
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the uploaded attachment.",
    },
    href: {
      type: "string",
      description: "Server-relative URL to retrieve the attachment.",
    },
    contentType: {
      type: "string",
      description: "MIME type of the uploaded file.",
    },
    filename: {
      type: "string",
      nullable: true,
      description: "Original filename of the uploaded file.",
    },
    size: {
      type: "integer",
      format: "int64",
      description: "File size in bytes (null for URL-created attachments until download completes).",
    },
    sha256: {
      type: "string",
      description: "SHA-256 hash of the file content (null for URL-created attachments until download completes).",
    },
    expiresAt: {
      type: "string",
      format: "date-time",
      description: "When this unlinked attachment will expire and be deleted.",
    },
    status: {
      type: "string",
      enum: ["uploading", "downloading", "ready", "failed"],
      description: `Current status of the attachment:
- \`uploading\` - Multipart upload created but not yet completed
- \`downloading\` - Server is downloading content from sourceUrl
- \`ready\` - Content is available for retrieval
- \`failed\` - Download from sourceUrl failed`,
    },
    sourceUrl: {
      type: "string",
      nullable: true,
      description: "Original source URL (only present for URL-created attachments).",
    },
  },
  example: {
    id: "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    href: "/v1/attachments/7c9e6679-7425-40de-944b-e07fc1f90ae7",
    contentType: "image/jpeg",
    filename: "photo.jpg",
    size: 204800,
    sha256: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    expiresAt: "2025-01-28T11:30:00Z",
    status: "ready",
  },
} as const;

export const $AttachmentDownloadUrlResponse = {
  type: "object",
  description: "Response containing a signed download URL for an attachment.",
  properties: {
    url: {
      type: "string",
      description: "The signed download URL. May be an absolute S3 URL or a server-relative path.",
    },
    expiresIn: {
      type: "integer",
      description: "Number of seconds until the URL expires.",
    },
  },
  example: {
    url: "/v1/attachments/download/dG9rZW4.../photo.jpg",
    expiresIn: 300,
  },
} as const;

export const $Entry = {
  type: "object",
  required: ["id", "conversationId", "channel", "contentType", "content", "createdAt"],
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the entry.",
    },
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation this entry belongs to.",
    },
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `Logical memory epoch this entry belongs to.
For history entries this is typically null. For memory entries,
the agent increments the epoch when starting a new memory version.`,
    },
    contentType: {
      type: "string",
      description: `Describes the schema/format of the content array.

**History channel entries must use \`"history"\` or \`"history/<subtype>"\` as the contentType.**

Supported content types:
- \`history\` - Simple text-only history entries
- \`history/lc4j\` - LangChain4j rich event format (Quarkus)

The content array for history entries contains objects with:
- \`role\` (string, required): Either \`"USER"\` or \`"AI"\`.
- \`text\` (string, optional): The message text. At least one of \`text\`, \`events\`, or \`attachments\` must be present.
- \`events\` (array, optional): Rich event objects for streaming details.
  Event structure is not validated by the server. For \`history/lc4j\`, events use an \`eventType\` field:
  - \`PartialResponse\`: Text chunk (\`{eventType, chunk}\`)
  - \`PartialThinking\`: Reasoning chunk (\`{eventType, chunk}\`)
  - \`BeforeToolExecution\`: Before tool call (\`{eventType, toolName, input}\`)
  - \`ToolExecuted\`: Tool result (\`{eventType, toolName, output}\`)
- \`attachments\` (array, optional): Array of \`Attachment\` objects referencing external resources (images, audio, video, documents).

Other contentTypes (e.g., \`"LC4J"\`, \`"SpringAI"\`) may be used for
agent memory entries.`,
    },
    content: {
      type: "array",
      description: `Opaque, agent-defined content blocks.
Different agents may use different schemas; the memory-service
stores and returns them without interpretation.

For history channel entries (contentType: \`"history"\`), each block
contains \`role\` and at least one of \`text\`, \`events\`, or \`attachments\`.`,
      items: {},
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
  example: {
    id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    userId: "user_1234",
    channel: "history",
    epoch: null,
    contentType: "history",
    content: [
      {
        text: "What breed is this dog?",
        role: "USER",
        attachments: [
          {
            href: "https://example.com/photos/my-dog.jpg",
            contentType: "image/jpeg",
            name: "my-dog.jpg",
          },
        ],
      },
    ],
    createdAt: "2025-01-10T14:40:12Z",
  },
} as const;

export const $CreateEntryRequest = {
  type: "object",
  required: ["contentType", "content"],
  properties: {
    userId: {
      type: "string",
      nullable: true,
      maxLength: 255,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    contentType: {
      type: "string",
      maxLength: 127,
      description: `Describes the schema/format of the content array.

**History channel entries must use \`"history"\` or \`"history/<subtype>"\` as the contentType.**

Supported content types:
- \`history\` - Simple text-only history entries
- \`history/lc4j\` - LangChain4j rich event format (Quarkus)

The content array for history entries must contain exactly 1 object with:
- \`role\` (string, required): Either \`"USER"\` or \`"AI"\`.
- \`text\` (string, optional): The message text. At least one of \`text\`, \`events\`, or \`attachments\` must be present.
- \`events\` (array, optional): Rich event objects for streaming details.
  Event structure is not validated by the server. For \`history/lc4j\`, events use an \`eventType\` field:
  - \`PartialResponse\`: Text chunk (\`{eventType, chunk}\`)
  - \`PartialThinking\`: Reasoning chunk (\`{eventType, chunk}\`)
  - \`BeforeToolExecution\`: Before tool call (\`{eventType, toolName, input}\`)
  - \`ToolExecuted\`: Tool result (\`{eventType, toolName, output}\`)
- \`attachments\` (array, optional): Array of \`Attachment\` objects referencing external resources (images, audio, video, documents).

Other contentTypes (e.g., \`"LC4J"\`, \`"SpringAI"\`) may be used for
agent memory entries.`,
    },
    content: {
      type: "array",
      maxItems: 1000,
      description: `For history channel entries (contentType: \`"history"\` or \`"history/<subtype>"\`), each block
contains \`role\` and at least one of \`text\`, \`events\`, or \`attachments\`.`,
      items: {},
    },
    indexedContent: {
      type: "string",
      nullable: true,
      maxLength: 100000,
      description: `Optional text to index for search. Only valid for entries in the history
channel. If provided, the entry will be indexed for search immediately
after creation. Returns 400 Bad Request if specified for non-history channels.`,
    },
    forkedAtConversationId: {
      type: "string",
      format: "uuid",
      description:
        "If the target conversation doesn't exist yet, auto-create it as a fork of this conversation. Ignored when the conversation already exists.",
    },
    forkedAtEntryId: {
      type: "string",
      format: "uuid",
      description:
        "Entry ID marking the fork point. Entries before this point are inherited; entries at and after this point are excluded. Required when forkedAtConversationId is set.",
    },
  },
  example: {
    userId: "user_1234",
    channel: "history",
    contentType: "history/lc4j",
    content: [
      {
        text: "Let me check the weather for you. The weather in Seattle is 72°F.",
        role: "AI",
        events: [
          {
            eventType: "PartialResponse",
            chunk: "Let me check the weather for you.",
          },
          {
            eventType: "BeforeToolExecution",
            toolName: "get_weather",
            input: {
              city: "Seattle",
            },
          },
          {
            eventType: "ToolExecuted",
            toolName: "get_weather",
            output: {
              temp: 72,
            },
          },
          {
            eventType: "PartialResponse",
            chunk: "The weather in Seattle is 72°F.",
          },
        ],
      },
    ],
  },
} as const;

export const $SyncEntryResponse = {
  type: "object",
  properties: {
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: "The epoch number that now reflects the stored memory state.",
    },
    noOp: {
      type: "boolean",
      description: "True when the request resulted in no stored changes.",
    },
    epochIncremented: {
      type: "boolean",
      description: "True when the provided list diverged and a new epoch was started.",
    },
    entry: {
      $ref: "#/components/schemas/Entry",
      nullable: true,
      description: "The entry that was appended during this sync, or null if no-op.",
    },
  },
  example: {
    epoch: 5,
    noOp: false,
    epochIncremented: true,
    entry: {
      id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
      conversationId: "550e8400-e29b-41d4-a716-446655440000",
      userId: "agent_memory",
      channel: "memory",
      epoch: 5,
      contentType: "LC4J",
      content: [
        {
          type: "text",
          text: "First message in memory.",
        },
        {
          type: "text",
          text: "Second message added during sync.",
        },
      ],
      createdAt: "2025-01-10T14:40:12Z",
    },
  },
} as const;

export const $IndexEntryRequest = {
  type: "object",
  required: ["conversationId", "entryId", "indexedContent"],
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation containing the entry.",
    },
    entryId: {
      type: "string",
      format: "uuid",
      description: "The entry ID to index.",
    },
    indexedContent: {
      type: "string",
      minLength: 1,
      maxLength: 100000,
      description: "The searchable text for this entry.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    entryId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    indexedContent: "User asked about conversation forking and branching strategies",
  },
} as const;

export const $IndexConversationsResponse = {
  type: "object",
  properties: {
    indexed: {
      type: "integer",
      description: `Number of entries processed. These entries have their indexed content
stored and will be searchable. If vector store indexing failed for some
entries, they will become searchable asynchronously via background retry.`,
    },
  },
  example: {
    indexed: 3,
  },
} as const;

export const $UnindexedEntriesResponse = {
  type: "object",
  properties: {
    data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/UnindexedEntry",
      },
    },
    cursor: {
      type: "string",
      nullable: true,
      description: "Cursor for fetching next page. Null when no more results.",
    },
  },
  example: {
    data: [
      {
        conversationId: "550e8400-e29b-41d4-a716-446655440000",
        entry: {
          id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
          channel: "history",
          contentType: "history",
          content: [
            {
              text: "Help me design a memory service",
              role: "USER",
            },
          ],
          createdAt: "2025-01-10T14:40:12Z",
        },
      },
    ],
    cursor: "eyJjcmVhdGVkQXQiOiIyMDI1LTAxLTEwVDE0OjQwOjEyWiJ9",
  },
} as const;

export const $UnindexedEntry = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
    },
    entry: {
      $ref: "#/components/schemas/Entry",
    },
  },
} as const;

export const $SearchConversationsRequest = {
  type: "object",
  required: ["query"],
  properties: {
    query: {
      type: "string",
      minLength: 1,
      maxLength: 1000,
      description: "Natural language query.",
    },
    searchType: {
      type: "string",
      enum: ["auto", "semantic", "fulltext"],
      default: "auto",
      description: `The search method to use:
- \`auto\` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
- \`semantic\`: Use only vector/embedding-based semantic search
- \`fulltext\`: Use only PostgreSQL full-text search with GIN index

If the requested search type is not available on the server, a 501 (Not Implemented)
error is returned with details about which search types are available.
`,
    },
    after: {
      type: "string",
      nullable: true,
      maxLength: 100,
      description: "Cursor for pagination; returns items after this result.",
    },
    limit: {
      type: "integer",
      default: 20,
      minimum: 1,
      maximum: 200,
      description: "Maximum number of results to return.",
    },
    includeEntry: {
      type: "boolean",
      default: true,
      description:
        "Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.",
    },
    groupByConversation: {
      type: "boolean",
      default: true,
      description: `When true (default), groups results by conversation and returns only
the highest-scoring entry per conversation. When false, returns all
matching entries ordered by score.
`,
    },
  },
  example: {
    query: "summary of memory service design decisions",
    searchType: "auto",
    limit: 20,
    includeEntry: true,
    groupByConversation: true,
  },
} as const;

export const $SearchResult = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier of the conversation containing this entry.",
    },
    conversationTitle: {
      type: "string",
      description: "Title of the conversation containing this entry.",
    },
    entryId: {
      type: "string",
      format: "uuid",
      description: "ID of the matched entry. Always present for deep-linking.",
    },
    score: {
      type: "number",
      format: "float",
    },
    highlights: {
      type: "string",
      nullable: true,
    },
    entry: {
      allOf: [
        {
          $ref: "#/components/schemas/Entry",
        },
      ],
      description: "The matched entry. Only included when includeEntry is true in the request.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    conversationTitle: "Memory Service Design Discussion",
    score: 0.93,
    highlights: "design a memory service for my agent",
    entry: {
      id: "6ba7b810-9dad-11d1-80b4-00c04fd430c9",
      conversationId: "550e8400-e29b-41d4-a716-446655440000",
      userId: "user_1234",
      channel: "history",
      contentType: "history",
      content: [
        {
          text: "Help me design a memory service for my agent.",
          role: "USER",
        },
      ],
      createdAt: "2025-01-10T14:32:05Z",
    },
  },
} as const;

export const $OwnershipTransfer = {
  type: "object",
  description: `Represents a pending ownership transfer request.
Transfers are always "pending" while they exist; accepted/rejected transfers
are hard deleted from the database.`,
  required: ["id", "conversationId", "fromUserId", "toUserId", "createdAt"],
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the transfer.",
    },
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation being transferred.",
    },
    conversationTitle: {
      type: "string",
      nullable: true,
      description: "Title of the conversation (for display purposes).",
    },
    fromUserId: {
      type: "string",
      description: "Current owner initiating the transfer.",
    },
    toUserId: {
      type: "string",
      description: "Proposed new owner (recipient).",
    },
    createdAt: {
      type: "string",
      format: "date-time",
      description: "When the transfer was initiated.",
    },
  },
  example: {
    id: "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    conversationTitle: "Help with React hooks",
    fromUserId: "user_john_doe",
    toUserId: "user_jane_smith",
    createdAt: "2025-01-28T10:30:00Z",
  },
} as const;

export const $CreateOwnershipTransferRequest = {
  type: "object",
  required: ["conversationId", "newOwnerUserId"],
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation to transfer ownership of.",
    },
    newOwnerUserId: {
      type: "string",
      description: "User ID of the proposed new owner. Must be an existing member.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    newOwnerUserId: "user_jane_smith",
  },
} as const;

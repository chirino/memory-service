// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from "./core/CancelablePromise";
import { OpenAPI } from "./core/OpenAPI";
import { request as __request } from "./core/request";
import type { $OpenApiTs } from "./types.gen";

export class ConversationsService {
  /**
   * List conversations visible to current user
   * Lists all conversations the current user has access to (owner, manager, writer, or reader).
   *
   * **Fork Tree Behavior**: Conversations can be forked to create branches. All forks
   * share the same "conversation group" (fork tree). The `mode` parameter controls
   * which conversations from each fork tree are returned.
   * @param data The data for the request.
   * @param data.mode Listing mode for conversations. Controls which conversations are returned
   * from each fork tree (conversation group).
   * - `all`: include all conversations the user can access (roots and forks).
   * - `roots`: only include root conversations (conversations that are not forks).
   * - `latest-fork`: include only the most recently updated conversation per fork tree.
   * This is useful for showing a single representative conversation from each tree.
   * @param data.after Cursor for pagination; returns items after this conversation id (UUID format).
   * @param data.limit Maximum number of conversations to return.
   * @param data.query Optional text query for basic title/metadata search.
   * @returns unknown A list of conversations.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversations(
    data: $OpenApiTs["/v1/conversations"]["get"]["req"] = {},
  ): CancelablePromise<
    $OpenApiTs["/v1/conversations"]["get"]["res"][200] | $OpenApiTs["/v1/conversations"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations",
      query: {
        mode: data.mode,
        after: data.after,
        limit: data.limit,
        query: data.query,
      },
    });
  }

  /**
   * Create a conversation
   * Creates a new conversation owned by the current user.
   * @param data The data for the request.
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Conversation The created conversation.
   * @throws ApiError
   */
  public static createConversation(
    data: $OpenApiTs["/v1/conversations"]["post"]["req"],
  ): CancelablePromise<
    $OpenApiTs["/v1/conversations"]["post"]["res"][200] | $OpenApiTs["/v1/conversations"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations",
      body: data.requestBody,
      mediaType: "application/json",
    });
  }

  /**
   * Get a conversation
   * Retrieve a conversation the user has access to.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @returns Conversation The conversation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static getConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Update a conversation
   * Updates conversation properties. Currently supports updating the title.
   * Requires writer or higher access on the conversation.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.requestBody
   * @returns Conversation The updated conversation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static updateConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}"]["patch"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}"]["patch"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}"]["patch"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "PATCH",
      url: "/v1/conversations/{conversationId}",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Delete a conversation
   * Deletes a conversation. Only the owner (or manager, depending on policy) may delete.
   *
   * **Deleting a conversation deletes all conversations in the same fork tree** (the root conversation and all its forks). Memberships and messages associated with these conversations are also deleted.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @returns ErrorResponse Error response
   * @returns void Conversation deleted.
   * @throws ApiError
   */
  public static deleteConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/conversations/{conversationId}",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * List conversation entries
   * Returns entries in a conversation, ordered by creation time.
   *
   * The `channel` parameter determines which logical channel of entries
   * is returned:
   *
   * - `history` (default) returns the user-visible conversation between
   * users and the agent.
   * - `memory` returns agent memory entries which are typically not
   * shown directly to end users. Memory entries are scoped to the
   * calling client id derived from the API key.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.after Cursor for pagination; returns entries after this entry id (UUID format).
   * @param data.limit
   * @param data.channel Channel of entries to return. Defaults to `history` for the
   * user-visible conversation; `memory` returns agent memory entries
   * scoped to the calling client id.
   * @param data.epoch Optional epoch filter when listing the `memory` channel. Valid values
   * are `latest`, `all`, or a numeric epoch identifier. Defaults to
   * `latest` when not provided. The epoch selection is scoped to the
   * calling client id.
   * @param data.forks Controls which fork entries to include. `none` (default) follows the
   * fork ancestry path, returning entries from the target conversation
   * and its ancestors up to fork points. `all` returns entries from all
   * forks in the conversation group, useful for debugging or getting a
   * complete picture of all activity across forks.
   * @returns unknown A list of entries.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationEntries(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/entries",
      path: {
        conversationId: data.conversationId,
      },
      query: {
        after: data.after,
        limit: data.limit,
        channel: data.channel,
        epoch: data.epoch,
        forks: data.forks,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Append an entry
   * Appends a new entry to the conversation.
   *
   * This endpoint is used by both end-user clients and agents.
   * The service determines whether the caller is a user or an agent
   * based on authentication (for example, API keys or tokens) and
   * stores the entry with the appropriate internal role and visibility.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Entry The created entry.
   * @throws ApiError
   */
  public static appendConversationEntry(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/entries",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Synchronize the agent memory epoch
   * Synchronizes the in-memory context for the conversation. The request body
   * is a single entry whose `content` array contains all messages in the agent's
   * memory. The service compares this content against the flattened content of
   * all entries in the latest memory epoch.
   *
   * If the content matches exactly, it's a no-op. If the incoming content is a
   * prefix extension (starts with existing content plus new items), only the
   * delta is appended to the current epoch. Otherwise, a new epoch is created
   * with the delta content.
   *
   * The entry must target the `memory` channel. Memory sync is scoped to the
   * calling client id (from the API key). Requires a valid agent API key.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.requestBody
   * @returns SyncEntryResponse Result of the sync operation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static syncConversationMemory(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/entries/sync",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * List forks for a conversation
   * Returns all forked conversations that share the same root conversation as the
   * given conversation. Each fork entry includes the message id at which it forked
   * and the timestamp when the forked conversation was created.
   *
   * This is intended for UIs that want to fetch all fork points once per conversation
   * and then decide how to render branch navigation (e.g., which is the oldest fork).
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @returns unknown Forked conversations related to this conversation's root.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationForks(
    data: $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/forks",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Cancel an in-progress response
   * Requests cancellation of an in-progress response stream for the conversation.
   * Requires WRITER access and an authenticated user session.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @returns unknown Cancel request accepted.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static deleteConversationResponse(
    data: $OpenApiTs["/v1/conversations/{conversationId}/response"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/response"]["delete"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/response"]["delete"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/conversations/{conversationId}/response",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
        409: "Error response",
      },
    });
  }
}

export class SharingService {
  /**
   * List pending ownership transfers
   * Returns all pending ownership transfers where the current user is either
   * the current owner (sender) or the proposed new owner (recipient).
   * @param data The data for the request.
   * @param data.role Filter by user's role in the transfer.
   * @returns unknown List of pending transfers.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listPendingTransfers(
    data: $OpenApiTs["/v1/ownership-transfers"]["get"]["req"] = {},
  ): CancelablePromise<
    $OpenApiTs["/v1/ownership-transfers"]["get"]["res"][200] | $OpenApiTs["/v1/ownership-transfers"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/ownership-transfers",
      query: {
        role: data.role,
      },
    });
  }

  /**
   * Request ownership transfer
   * Initiates a transfer of conversation ownership to another user.
   *
   * **Constraints**:
   * - Only the current owner can initiate a transfer
   * - The recipient must be an existing member of the conversation
   * - Only one pending transfer can exist per conversation at a time
   * - If a pending transfer already exists, returns 409 Conflict
   *
   * The recipient must accept the transfer via `POST /v1/ownership-transfers/{transferId}/accept`
   * for the transfer to complete. Either party can delete the pending transfer
   * via `DELETE /v1/ownership-transfers/{transferId}`.
   * @param data The data for the request.
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns OwnershipTransfer Transfer initiated successfully.
   * @throws ApiError
   */
  public static createOwnershipTransfer(
    data: $OpenApiTs["/v1/ownership-transfers"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/ownership-transfers"]["post"]["res"][200]
    | $OpenApiTs["/v1/ownership-transfers"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/ownership-transfers",
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        400: "Error response",
        403: "Error response",
        404: "Resource not found",
        409: "A pending transfer already exists for this conversation.",
      },
    });
  }

  /**
   * Get transfer details
   * Returns details of a specific ownership transfer. Only accessible to
   * the current owner (sender) or proposed new owner (recipient).
   * @param data The data for the request.
   * @param data.transferId Transfer identifier (UUID format).
   * @returns OwnershipTransfer Transfer details.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static getTransfer(
    data: $OpenApiTs["/v1/ownership-transfers/{transferId}"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/ownership-transfers/{transferId}"]["get"]["res"][200]
    | $OpenApiTs["/v1/ownership-transfers/{transferId}"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/ownership-transfers/{transferId}",
      path: {
        transferId: data.transferId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Cancel or reject ownership transfer
   * Deletes a pending ownership transfer. Can be called by either:
   * - The current owner (sender) to cancel the transfer
   * - The proposed new owner (recipient) to reject the transfer
   *
   * The transfer record is **hard deleted** from the database.
   * @param data The data for the request.
   * @param data.transferId Transfer identifier (UUID format).
   * @returns ErrorResponse Error response
   * @returns void Transfer deleted successfully.
   * @throws ApiError
   */
  public static deleteTransfer(
    data: $OpenApiTs["/v1/ownership-transfers/{transferId}"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/ownership-transfers/{transferId}"]["delete"]["res"][200]
    | $OpenApiTs["/v1/ownership-transfers/{transferId}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/ownership-transfers/{transferId}",
      path: {
        transferId: data.transferId,
      },
      errors: {
        403: "Error response",
        404: "Resource not found",
      },
    });
  }

  /**
   * Accept ownership transfer
   * Accepts a pending ownership transfer. Only the proposed new owner
   * (recipient) can accept. Upon acceptance:
   * - The recipient becomes the new owner
   * - The previous owner becomes a manager
   * - The transfer record is deleted (transfers are always pending while they exist)
   * @param data The data for the request.
   * @param data.transferId Transfer identifier (UUID format).
   * @returns ErrorResponse Error response
   * @returns void Transfer accepted successfully. Ownership has been transferred.
   * @throws ApiError
   */
  public static acceptTransfer(
    data: $OpenApiTs["/v1/ownership-transfers/{transferId}/accept"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/ownership-transfers/{transferId}/accept"]["post"]["res"][200]
    | $OpenApiTs["/v1/ownership-transfers/{transferId}/accept"]["post"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/ownership-transfers/{transferId}/accept",
      path: {
        transferId: data.transferId,
      },
      errors: {
        403: "Error response",
        404: "Resource not found",
      },
    });
  }

  /**
   * List conversation memberships
   * Lists all users that have access to the conversation and their access levels.
   * Any conversation member (owner, manager, writer, or reader) can list memberships.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @returns unknown Memberships for the conversation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationMemberships(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/memberships",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Share conversation with another user
   * Grants another user access to the conversation with the specified access level.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns ConversationMembership Created membership.
   * @throws ApiError
   */
  public static shareConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/memberships",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Update a member's access level
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.userId
   * @param data.requestBody
   * @returns ConversationMembership Updated membership.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static updateConversationMembership(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "PATCH",
      url: "/v1/conversations/{conversationId}/memberships/{userId}",
      path: {
        conversationId: data.conversationId,
        userId: data.userId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Remove a member from the conversation
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier (UUID format).
   * @param data.userId
   * @returns ErrorResponse Error response
   * @returns void Membership removed.
   * @throws ApiError
   */
  public static deleteConversationMembership(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/conversations/{conversationId}/memberships/{userId}",
      path: {
        conversationId: data.conversationId,
        userId: data.userId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }
}

export class SearchService {
  /**
   * Semantic search across conversations
   * Performs semantic and/or keyword search across all conversations the user has access to.
   * Backed by an internal vector store (pgvector, MongoDB, etc.).
   * @param data The data for the request.
   * @param data.requestBody
   * @returns unknown Search results.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static searchConversations(
    data: $OpenApiTs["/v1/conversations/search"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/search"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/search"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/search",
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        501: "Requested search type is not available on this server",
      },
    });
  }

  /**
   * Index conversation entries
   * Indexes searchable text for conversation entries. Each item in the request
   * array specifies a single entry with the text that should be searchable.
   *
   * This endpoint is called by batch indexing services after processing
   * conversation entries. The indexed text becomes searchable via
   * `/v1/conversations/search`.
   *
   * If an entry has already been indexed, its text is replaced with the new value.
   * The entry's `indexedAt` timestamp is updated when successfully indexed.
   *
   * **Note:** This endpoint may return successfully even if vector store indexing
   * fails. In that case, the indexed content is stored and a background retry task
   * is created to complete the indexing asynchronously. Entries will become
   * searchable once the retry task succeeds.
   *
   * Requires indexer or admin role.
   * @param data The data for the request.
   * @param data.requestBody
   * @returns IndexConversationsResponse Entries indexed successfully.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static indexConversations(
    data: $OpenApiTs["/v1/conversations/index"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/index"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/index"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/index",
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        403: "Error response",
        404: "Resource not found",
      },
    });
  }

  /**
   * List entries needing indexing
   * Returns entries from the history channel that have not yet had their
   * index content generated (where `indexedContent` is null). This endpoint
   * is used by batch indexing jobs to discover entries that need processing.
   *
   * Entries are returned with their full content so that callers can
   * process the content before submitting index text. Results are sorted
   * by `createdAt` for consistent ordering.
   *
   * Uses cursor-based pagination.
   *
   * Requires indexer or admin role.
   * @param data The data for the request.
   * @param data.limit Maximum number of entries to return.
   * @param data.cursor Pagination cursor from previous response.
   * @returns UnindexedEntriesResponse Paginated list of unindexed entries.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listUnindexedEntries(
    data: $OpenApiTs["/v1/conversations/unindexed"]["get"]["req"] = {},
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/unindexed"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/unindexed"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/unindexed",
      query: {
        limit: data.limit,
        cursor: data.cursor,
      },
      errors: {
        403: "Error response",
      },
    });
  }
}

export class AttachmentsService {
  /**
   * Upload or create an attachment
   * Creates an attachment either by uploading a binary file (multipart/form-data)
   * or by providing a source URL for the server to download (application/json).
   *
   * **Multipart upload**: Uploads a binary file and stores it server-side.
   *
   * **URL-based creation**: Provides a `sourceUrl` for the server to download
   * asynchronously. Returns immediately with status `downloading`. The
   * attachment transitions to `ready` once the download completes, or `failed`
   * on error.
   *
   * Uploaded attachments expire after the specified duration unless they are
   * linked to an entry before expiration.
   * @param data The data for the request.
   * @param data.formData
   * @param data.expiresIn ISO 8601 duration for how long the unlinked attachment should persist.
   * Defaults to 1 hour. Maximum 24 hours. Only used for multipart uploads.
   * @returns ErrorResponse Error response
   * @returns AttachmentUploadResponse Attachment created successfully.
   * @throws ApiError
   */
  public static uploadAttachment(
    data: $OpenApiTs["/v1/attachments"]["post"]["req"],
  ): CancelablePromise<
    $OpenApiTs["/v1/attachments"]["post"]["res"][200] | $OpenApiTs["/v1/attachments"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/attachments",
      query: {
        expiresIn: data.expiresIn,
      },
      formData: data.formData,
      mediaType: "multipart/form-data",
      errors: {
        400: "Error response",
        413: "File too large.",
      },
    });
  }

  /**
   * Retrieve an attachment
   * Downloads the binary content of an attachment.
   *
   * - If the attachment is unlinked (not yet associated with an entry), only
   * the original uploader can access it.
   * - If linked to an entry, anyone with read access to the conversation can
   * access it.
   * - If the FileStore supports signed URLs (e.g., S3), a 302 redirect is
   * returned instead of streaming the bytes directly.
   * @param data The data for the request.
   * @param data.id Attachment identifier (UUID format).
   * @returns binary Attachment binary content.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static getAttachment(
    data: $OpenApiTs["/v1/attachments/{id}"]["get"]["req"],
  ): CancelablePromise<
    $OpenApiTs["/v1/attachments/{id}"]["get"]["res"][200] | $OpenApiTs["/v1/attachments/{id}"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/attachments/{id}",
      path: {
        id: data.id,
      },
      errors: {
        302: "Redirect to a signed URL for the attachment.",
        403: "Error response",
        404: "Resource not found",
      },
    });
  }

  /**
   * Delete an unlinked attachment
   * Deletes an attachment that has not yet been linked to an entry.
   *
   * - Only the original uploader can delete an attachment.
   * - Only unlinked attachments (those without an `entryId`) can be deleted.
   * - Linked attachments return 409 Conflict since they are permanent.
   * - The file is removed from storage first, then the metadata record is deleted.
   * @param data The data for the request.
   * @param data.id Attachment identifier (UUID format).
   * @returns ErrorResponse Error response
   * @returns void Attachment deleted.
   * @throws ApiError
   */
  public static deleteAttachment(
    data: $OpenApiTs["/v1/attachments/{id}"]["delete"]["req"],
  ): CancelablePromise<
    $OpenApiTs["/v1/attachments/{id}"]["delete"]["res"][200] | $OpenApiTs["/v1/attachments/{id}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/attachments/{id}",
      path: {
        id: data.id,
      },
      errors: {
        403: "Error response",
        404: "Resource not found",
        409: "Error response",
      },
    });
  }

  /**
   * Get a signed download URL for an attachment
   * Returns a time-limited, signed URL that can be used to download the
   * attachment without an Authorization header. This is useful for opening
   * files in new browser tabs or triggering downloads.
   *
   * - For S3 storage: returns the S3 pre-signed URL directly.
   * - For DB storage: returns a server-relative URL with an HMAC-signed token.
   *
   * Access control is the same as `GET /v1/attachments/{id}`.
   * @param data The data for the request.
   * @param data.id Attachment identifier (UUID format).
   * @returns AttachmentDownloadUrlResponse Signed download URL.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static getAttachmentDownloadUrl(
    data: $OpenApiTs["/v1/attachments/{id}/download-url"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/attachments/{id}/download-url"]["get"]["res"][200]
    | $OpenApiTs["/v1/attachments/{id}/download-url"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/attachments/{id}/download-url",
      path: {
        id: data.id,
      },
      errors: {
        403: "Error response",
        404: "Resource not found",
      },
    });
  }

  /**
   * Download an attachment via signed token
   * Serves the binary content of an attachment using a time-limited signed
   * token. No authentication header is required.
   *
   * The token is obtained from `GET /v1/attachments/{id}/download-url`.
   * Returns 403 if the token is invalid or expired.
   * @param data The data for the request.
   * @param data.token Signed download token.
   * @param data.filename Filename for the download (used in Content-Disposition).
   * @returns binary Attachment binary content.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static downloadAttachmentByToken(
    data: $OpenApiTs["/v1/attachments/download/{token}/{filename}"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/attachments/download/{token}/{filename}"]["get"]["res"][200]
    | $OpenApiTs["/v1/attachments/download/{token}/{filename}"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/attachments/download/{token}/{filename}",
      path: {
        token: data.token,
        filename: data.filename,
      },
      errors: {
        403: "Invalid or expired token.",
        404: "Resource not found",
      },
    });
  }
}

// This file is auto-generated by @hey-api/openapi-ts

export type ErrorResponse = {
  error?: string;
  code?: string;
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Error response when the requested search type is not available on the server.
 */
export type SearchTypeUnavailableError = {
  /**
   * Error code.
   */
  error?: string;
  /**
   * Human-readable error message.
   */
  message?: string;
  /**
   * List of search types that are available on this server.
   */
  availableTypes?: Array<string>;
};

/**
 * Access level of a user for a conversation.
 */
export type AccessLevel = "owner" | "manager" | "writer" | "reader";

export type ConversationSummary = {
  /**
   * Unique identifier for the conversation.
   */
  id?: string;
  title?: string | null;
  ownerUserId?: string;
  createdAt?: string;
  updatedAt?: string;
  lastMessagePreview?: string | null;
  accessLevel?: AccessLevel;
};

export type Conversation = ConversationSummary & {
  /**
   * Entry ID where this conversation forked from its parent.
   */
  forkedAtEntryId?: string | null;
  /**
   * Conversation ID from which this conversation was forked.
   */
  forkedAtConversationId?: string | null;
};

export type CreateConversationRequest = {
  title?: string | null;
  metadata?: {
    [key: string]: unknown;
  };
};

export type UpdateConversationRequest = {
  title?: string | null;
};

export type ConversationMembership = {
  /**
   * Unique identifier for the conversation.
   */
  conversationId?: string;
  userId?: string;
  accessLevel?: AccessLevel;
  createdAt?: string;
};

/**
 * Summary of a forked conversation originating at a given entry.
 */
export type ConversationForkSummary = {
  /**
   * Unique identifier for the forked conversation.
   */
  conversationId?: string;
  /**
   * Entry ID at which this forked conversation diverged.
   */
  forkedAtEntryId?: string;
  /**
   * Conversation ID where the fork occurred.
   */
  forkedAtConversationId?: string | null;
  title?: string | null;
  createdAt?: string;
};

export type ShareConversationRequest = {
  userId: string;
  accessLevel: AccessLevel;
  createdAt?: string;
};

/**
 * Logical channel of the entry within the conversation.
 */
export type Channel = "history" | "memory";

/**
 * A reference to an attachment on a history entry. Supports two modes:
 *
 * **External URL (Phase 1)**: Provide `href` and `contentType` to reference
 * an externally-hosted resource.
 *
 * **Server-stored (Phase 2)**: Provide `attachmentId` to reference a file
 * previously uploaded via `POST /v1/attachments`. When the entry is created,
 * the server replaces `attachmentId` with an `href` pointing to
 * `/v1/attachments/{id}`.
 *
 * At least one of `href` or `attachmentId` must be present.
 */
export type Attachment = {
  /**
   * URL to the attachment resource (external or server-relative).
   */
  href?: string;
  /**
   * ID of a previously uploaded attachment (from POST /v1/attachments).
   * When the entry is created, this is replaced with an href.
   */
  attachmentId?: string;
  /**
   * MIME type of the attachment (e.g., "image/jpeg", "audio/mp3"). Required when href is provided directly.
   */
  contentType?: string;
  /**
   * Optional display name for the attachment.
   */
  name?: string;
  /**
   * Optional alt text or description.
   */
  description?: string;
  /**
   * File size in bytes (set by server for uploaded attachments).
   */
  size?: number;
  /**
   * SHA-256 hash of the file content (set by server for uploaded attachments).
   */
  sha256?: string;
};

/**
 * Request to create an attachment from a source URL.
 */
export type CreateFromUrlRequest = {
  /**
   * URL of the content to download and store as an attachment.
   */
  sourceUrl: string;
  /**
   * MIME type of the content. Defaults to application/octet-stream.
   */
  contentType?: string;
  /**
   * Display name for the attachment.
   */
  name?: string;
};

/**
 * Response from uploading or creating an attachment.
 */
export type AttachmentUploadResponse = {
  /**
   * Unique identifier for the uploaded attachment.
   */
  id?: string;
  /**
   * Server-relative URL to retrieve the attachment.
   */
  href?: string;
  /**
   * MIME type of the uploaded file.
   */
  contentType?: string;
  /**
   * Original filename of the uploaded file.
   */
  filename?: string | null;
  /**
   * File size in bytes (null for URL-created attachments until download completes).
   */
  size?: number;
  /**
   * SHA-256 hash of the file content (null for URL-created attachments until download completes).
   */
  sha256?: string;
  /**
   * When this unlinked attachment will expire and be deleted.
   */
  expiresAt?: string;
  /**
   * Current status of the attachment:
   * - `uploading` - Multipart upload created but not yet completed
   * - `downloading` - Server is downloading content from sourceUrl
   * - `ready` - Content is available for retrieval
   * - `failed` - Download from sourceUrl failed
   */
  status?: "uploading" | "downloading" | "ready" | "failed";
  /**
   * Original source URL (only present for URL-created attachments).
   */
  sourceUrl?: string;
};

/**
 * Response containing a signed download URL for an attachment.
 */
export type AttachmentDownloadUrlResponse = {
  /**
   * The signed download URL. May be an absolute S3 URL or a server-relative path.
   */
  url?: string;
  /**
   * Number of seconds until the URL expires.
   */
  expiresIn?: number;
};

export type Entry = {
  /**
   * Unique identifier for the entry.
   */
  id: string;
  /**
   * Unique identifier for the conversation this entry belongs to.
   */
  conversationId: string;
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel: Channel;
  /**
   * Logical memory epoch this entry belongs to.
   * For history entries this is typically null. For memory entries,
   * the agent increments the epoch when starting a new memory version.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   *
   * **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
   *
   * Supported content types:
   * - `history` - Simple text-only history entries
   * - `history/lc4j` - LangChain4j rich event format (Quarkus)
   *
   * The content array for history entries contains objects with:
   * - `role` (string, required): Either `"USER"` or `"AI"`.
   * - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
   * - `events` (array, optional): Rich event objects for streaming details.
   * Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
   * - `PartialResponse`: Text chunk (`{eventType, chunk}`)
   * - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
   * - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
   * - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
   * - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
   *
   * Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
   * agent memory entries.
   */
  contentType: string;
  /**
   * Opaque, agent-defined content blocks.
   * Different agents may use different schemas; the memory-service
   * stores and returns them without interpretation.
   *
   * For history channel entries (contentType: `"history"`), each block
   * contains `role` and at least one of `text`, `events`, or `attachments`.
   */
  content: Array<unknown>;
  createdAt: string;
};

export type CreateEntryRequest = {
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel?: Channel;
  /**
   * Describes the schema/format of the content array.
   *
   * **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
   *
   * Supported content types:
   * - `history` - Simple text-only history entries
   * - `history/lc4j` - LangChain4j rich event format (Quarkus)
   *
   * The content array for history entries must contain exactly 1 object with:
   * - `role` (string, required): Either `"USER"` or `"AI"`.
   * - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
   * - `events` (array, optional): Rich event objects for streaming details.
   * Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
   * - `PartialResponse`: Text chunk (`{eventType, chunk}`)
   * - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
   * - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
   * - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
   * - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
   *
   * Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
   * agent memory entries.
   */
  contentType: string;
  /**
   * For history channel entries (contentType: `"history"` or `"history/<subtype>"`), each block
   * contains `role` and at least one of `text`, `events`, or `attachments`.
   */
  content: Array<unknown>;
  /**
   * Optional text to index for search. Only valid for entries in the history
   * channel. If provided, the entry will be indexed for search immediately
   * after creation. Returns 400 Bad Request if specified for non-history channels.
   */
  indexedContent?: string | null;
  /**
   * If the target conversation doesn't exist yet, auto-create it as a fork of this conversation. Ignored when the conversation already exists.
   */
  forkedAtConversationId?: string;
  /**
   * Entry ID marking the fork point. Entries before this point are inherited; entries at and after this point are excluded. Required when forkedAtConversationId is set.
   */
  forkedAtEntryId?: string;
};

export type SyncEntryResponse = {
  /**
   * The epoch number that now reflects the stored memory state.
   */
  epoch?: number | null;
  /**
   * True when the request resulted in no stored changes.
   */
  noOp?: boolean;
  /**
   * True when the provided list diverged and a new epoch was started.
   */
  epochIncremented?: boolean;
  /**
   * The entry that was appended during this sync, or null if no-op.
   */
  entry?: Entry | null;
};

export type IndexEntryRequest = {
  /**
   * The conversation containing the entry.
   */
  conversationId: string;
  /**
   * The entry ID to index.
   */
  entryId: string;
  /**
   * The searchable text for this entry.
   */
  indexedContent: string;
};

export type IndexConversationsResponse = {
  /**
   * Number of entries processed. These entries have their indexed content
   * stored and will be searchable. If vector store indexing failed for some
   * entries, they will become searchable asynchronously via background retry.
   */
  indexed?: number;
};

export type UnindexedEntriesResponse = {
  data?: Array<UnindexedEntry>;
  /**
   * Cursor for fetching next page. Null when no more results.
   */
  afterCursor?: string | null;
};

export type UnindexedEntry = {
  conversationId?: string;
  entry?: Entry;
};

export type SearchConversationsRequest = {
  /**
   * Natural language query.
   */
  query: string;
  /**
   * The search method to use:
   * - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
   * - `semantic`: Use only vector/embedding-based semantic search
   * - `fulltext`: Use only PostgreSQL full-text search with GIN index
   *
   * If the requested search type is not available on the server, a 501 (Not Implemented)
   * error is returned with details about which search types are available.
   *
   */
  searchType?: "auto" | "semantic" | "fulltext";
  /**
   * Cursor for pagination; returns items after this result.
   */
  afterCursor?: string | null;
  /**
   * Maximum number of results to return.
   */
  limit?: number;
  /**
   * Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.
   */
  includeEntry?: boolean;
  /**
   * When true (default), groups results by conversation and returns only
   * the highest-scoring entry per conversation. When false, returns all
   * matching entries ordered by score.
   *
   */
  groupByConversation?: boolean;
};

export type SearchResult = {
  /**
   * Unique identifier of the conversation containing this entry.
   */
  conversationId?: string;
  /**
   * Title of the conversation containing this entry.
   */
  conversationTitle?: string;
  /**
   * ID of the matched entry. Always present for deep-linking.
   */
  entryId?: string;
  /**
   * Relevance score. Higher is more relevant.
   */
  score?: number;
  /**
   * Identifies which search backend produced the score (e.g. `postgres`, `mongo`, `qdrant`, `pgvector`).
   */
  kind?: "postgres" | "mongo" | "qdrant" | "pgvector";
  highlights?: string | null;
  /**
   * The matched entry. Only included when includeEntry is true in the request.
   */
  entry?: Entry;
};

/**
 * Represents a pending ownership transfer request.
 * Transfers are always "pending" while they exist; accepted/rejected transfers
 * are hard deleted from the database.
 */
export type OwnershipTransfer = {
  /**
   * Unique identifier for the transfer.
   */
  id: string;
  /**
   * The conversation being transferred.
   */
  conversationId: string;
  /**
   * Title of the conversation (for display purposes).
   */
  conversationTitle?: string | null;
  /**
   * Current owner initiating the transfer.
   */
  fromUserId: string;
  /**
   * Proposed new owner (recipient).
   */
  toUserId: string;
  /**
   * When the transfer was initiated.
   */
  createdAt: string;
};

export type CreateOwnershipTransferRequest = {
  /**
   * The conversation to transfer ownership of.
   */
  conversationId: string;
  /**
   * User ID of the proposed new owner. Must be an existing member.
   */
  newOwnerUserId: string;
};

export type $OpenApiTs = {
  "/v1/conversations": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id (UUID format).
         */
        afterCursor?: string | null;
        /**
         * Maximum number of conversations to return.
         */
        limit?: number;
        /**
         * Listing mode for conversations. Controls which conversations are returned
         * from each fork tree (conversation group).
         * - `all`: include all conversations the user can access (roots and forks).
         * - `roots`: only include root conversations (conversations that are not forks).
         * - `latest-fork`: include only the most recently updated conversation per fork tree.
         * This is useful for showing a single representative conversation from each tree.
         */
        mode?: "all" | "roots" | "latest-fork";
        /**
         * Optional text query for basic title/metadata search.
         */
        query?: string | null;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created conversation.
         */
        201: Conversation;
      };
    };
  };
  "/v1/conversations/{conversationId}": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    patch: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: UpdateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Conversation deleted.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns entries after this entry id (UUID format).
         */
        afterCursor?: string | null;
        /**
         * Channel of entries to return. Defaults to `history` for the
         * user-visible conversation; `memory` returns agent memory entries
         * scoped to the calling client id.
         */
        channel?: Channel;
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Optional epoch filter when listing the `memory` channel. Valid values
         * are `latest`, `all`, or a numeric epoch identifier. Defaults to
         * `latest` when not provided. The epoch selection is scoped to the
         * calling client id.
         */
        epoch?: string | null;
        /**
         * Controls which fork entries to include. `none` (default) follows the
         * fork ancestry path, returning entries from the target conversation
         * and its ancestors up to fork points. `all` returns entries from all
         * forks in the conversation group, useful for debugging or getting a
         * complete picture of all activity across forks.
         */
        forks?: "none" | "all";
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created entry.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/sync": {
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/forks": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id (UUID format).
         */
        afterCursor?: string | null;
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Maximum number of forks to return.
         */
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/response": {
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this transfer id (UUID format).
         */
        afterCursor?: string | null;
        /**
         * Maximum number of transfers to return.
         */
        limit?: number;
        /**
         * Filter by user's role in the transfer.
         */
        role?: "sender" | "recipient" | "all";
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateOwnershipTransferRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer initiated successfully.
         */
        201: OwnershipTransfer;
        /**
         * Error response
         */
        400: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * A pending transfer already exists for this conversation.
         */
        409: {
          error?: string;
          code?: string;
          /**
           * ID of the existing pending transfer
           */
          existingTransferId?: string;
        };
      };
    };
  };
  "/v1/ownership-transfers/{transferId}": {
    get: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer deleted successfully.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers/{transferId}/accept": {
    post: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer accepted successfully. Ownership has been transferred.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this user id.
         */
        afterCursor?: string | null;
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Maximum number of memberships to return.
         */
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: ShareConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Created membership.
         */
        201: ConversationMembership;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships/{userId}": {
    patch: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: {
          accessLevel?: AccessLevel;
        };
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Membership removed.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/search": {
    post: {
      req: {
        requestBody: SearchConversationsRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Requested search type is not available on this server
         */
        501: SearchTypeUnavailableError;
      };
    };
  };
  "/v1/conversations/index": {
    post: {
      req: {
        requestBody: Array<IndexEntryRequest>;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/unindexed": {
    get: {
      req: {
        /**
         * Pagination cursor from previous response.
         */
        afterCursor?: string;
        /**
         * Maximum number of entries to return.
         */
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
      };
    };
  };
  "/v1/attachments": {
    post: {
      req: {
        /**
         * ISO 8601 duration for how long the unlinked attachment should persist.
         * Defaults to 1 hour. Maximum 24 hours. Only used for multipart uploads.
         */
        expiresIn?: string;
        formData: {
          /**
           * The file to upload.
           */
          file: Blob | File;
        };
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Attachment created successfully.
         */
        201: AttachmentUploadResponse;
        /**
         * Error response
         */
        400: ErrorResponse;
        /**
         * File too large.
         */
        413: ErrorResponse;
      };
    };
  };
  "/v1/attachments/{id}": {
    get: {
      req: {
        /**
         * Attachment identifier (UUID format).
         */
        id: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Redirect to a signed URL for the attachment.
         */
        302: string;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Attachment identifier (UUID format).
         */
        id: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Attachment deleted.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/attachments/{id}/download-url": {
    get: {
      req: {
        /**
         * Attachment identifier (UUID format).
         */
        id: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/attachments/download/{token}/{filename}": {
    get: {
      req: {
        /**
         * Filename for the download (used in Content-Disposition).
         */
        filename: string;
        /**
         * Signed download token.
         */
        token: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Invalid or expired token.
         */
        403: unknown;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
};

// This file is auto-generated by @hey-api/openapi-ts

export type ErrorResponse = {
  error?: string;
  code?: string;
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Access level of a user for a conversation.
 */
export type AccessLevel = "owner" | "manager" | "writer" | "reader";

export type ConversationSummary = {
  id?: string;
  title?: string | null;
  ownerUserId?: string;
  createdAt?: string;
  updatedAt?: string;
  lastMessagePreview?: string | null;
  accessLevel?: AccessLevel;
};

export type Conversation = ConversationSummary & {
  conversationGroupId?: string;
  forkedAtMessageId?: string | null;
  forkedAtConversationId?: string | null;
};

export type CreateConversationRequest = {
  title?: string | null;
  metadata?: {
    [key: string]: unknown;
  };
};

export type ConversationMembership = {
  conversationGroupId?: string;
  userId?: string;
  accessLevel?: AccessLevel;
  createdAt?: string;
};

/**
 * Summary of a forked conversation originating at a given message.
 */
export type ConversationForkSummary = {
  conversationId?: string;
  /**
   * Conversation group id shared by this branch.
   */
  conversationGroupId?: string;
  /**
   * Message id at which this forked conversation diverged.
   */
  forkedAtMessageId?: string;
  /**
   * Conversation id where the fork occurred.
   */
  forkedAtConversationId?: string | null;
  title?: string | null;
  createdAt?: string;
};

export type ShareConversationRequest = {
  userId: string;
  accessLevel: AccessLevel;
  createdAt?: string;
};

export type ForkFromMessageRequest = {
  /**
   * Optional title for the new forked conversation.
   */
  title?: string | null;
};

/**
 * Logical channel of the message within the conversation.
 */
export type MessageChannel = "history" | "memory" | "summary";

export type Message = {
  id: string;
  conversationId: string;
  /**
   * Human user this message is associated with.
   * For history messages authored by a user, this is the sender.
   * For agent messages, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel: MessageChannel;
  /**
   * Logical memory epoch this message belongs to.
   * For history messages this is typically null. For memory messages,
   * the agent increments the epoch when starting a new memory version.
   */
  memoryEpoch?: number | null;
  /**
   * Opaque, agent-defined message content blocks.
   * Different agents may use different schemas; the memory-service
   * stores and returns them without interpretation.
   */
  content: Array<unknown>;
  createdAt: string;
};

export type CreateMessageRequest = {
  /**
   * Human user this message is associated with.
   * For history messages authored by a user, this is the sender.
   * For agent messages, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel?: MessageChannel;
  /**
   * For memory messages, the epoch the agent wants this message to
   * belong to. The agent increments this when starting a new epoch.
   */
  memoryEpoch?: number | null;
  content: Array<unknown>;
};

export type SyncMessagesRequest = {
  /**
   * The desired memory epoch contents. Each entry must include the
   * `memory` channel and should match the ordering that the agent expects to
   * see replayed; only the agent may call this endpoint.
   */
  messages: Array<CreateMessageRequest>;
};

export type SyncMessagesResponse = {
  /**
   * The epoch number that now reflects the stored memory state.
   */
  memoryEpoch?: number | null;
  /**
   * True when the request resulted in no stored changes.
   */
  noOp?: boolean;
  /**
   * True when the provided list diverged and a new epoch was started.
   */
  epochIncremented?: boolean;
  /**
   * List of messages that were appended during this sync.
   */
  messages?: Array<Message>;
};

export type CreateSummaryRequest = {
  /**
   * Conversation title to store/update.
   */
  title: string;
  /**
   * Summary text.
   */
  summary: string;
  /**
   * Highest message id covered by the summary (inclusive).
   */
  untilMessageId: string;
  /**
   * Timestamp of the last message covered by the summary.
   */
  summarizedAt: string;
};

export type SearchMessagesRequest = {
  /**
   * Natural language query.
   */
  query: string;
  topK?: number;
  conversationIds?: Array<string> | null;
  /**
   * Optional upper bound message id for temporal filtering.
   */
  before?: string | null;
};

export type SearchResult = {
  message?: Message;
  score?: number;
  highlights?: string | null;
};

export type $OpenApiTs = {
  "/v1/health": {
    get: {
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
  };
  "/v1/conversations": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id.
         */
        after?: string | null;
        /**
         * Maximum number of conversations to return.
         */
        limit?: number;
        /**
         * Listing mode for conversations.
         * - `all`: include all conversations the user can access (roots and forks).
         * - `roots`: only include root conversations.
         * - `latest-fork`: include the most recently updated conversation per root tree.
         */
        mode?: "all" | "roots" | "latest-fork";
        /**
         * Optional text query for basic title/metadata search.
         */
        query?: string | null;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created conversation.
         */
        201: Conversation;
      };
    };
  };
  "/v1/conversations/{conversationId}": {
    get: {
      req: {
        /**
         * Conversation identifier.
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Conversation deleted.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/messages": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns messages after this message id.
         */
        after?: string | null;
        /**
         * Channel of messages to return. Defaults to `history` for the
         * user-visible conversation; `memory` returns agent memory messages.
         */
        channel?: MessageChannel;
        conversationId: string;
        /**
         * Optional epoch filter when listing the `memory` channel. Valid values
         * are `latest`, `all`, or a numeric epoch identifier. Defaults to
         * `latest` when not provided.
         */
        epoch?: string | null;
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        conversationId: string;
        requestBody: CreateMessageRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created message.
         */
        201: Message;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memory/messages/sync": {
    post: {
      req: {
        conversationId: string;
        requestBody: SyncMessagesRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships": {
    get: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/messages/{messageId}/fork": {
    post: {
      req: {
        conversationId: string;
        messageId: string;
        requestBody?: ForkFromMessageRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The newly created forked conversation.
         */
        201: Conversation;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/forks": {
    get: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        conversationId: string;
        requestBody: ShareConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Created membership.
         */
        201: ConversationMembership;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships/{userId}": {
    patch: {
      req: {
        conversationId: string;
        requestBody: {
          accessLevel?: AccessLevel;
        };
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        conversationId: string;
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Membership removed.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/transfer-ownership": {
    post: {
      req: {
        conversationId: string;
        requestBody: {
          newOwnerUserId: string;
        };
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Ownership transfer requested.
         */
        202: unknown;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/summaries": {
    post: {
      req: {
        conversationId: string;
        requestBody: CreateSummaryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created summary message.
         */
        201: Message;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/cancel-response": {
    post: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/user/search/messages": {
    post: {
      req: {
        requestBody: SearchMessagesRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
  };
};

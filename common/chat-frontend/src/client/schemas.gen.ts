// This file is auto-generated by @hey-api/openapi-ts

export const $ErrorResponse = {
  type: "object",
  properties: {
    error: {
      type: "string",
    },
    code: {
      type: "string",
    },
    details: {
      type: "object",
      additionalProperties: true,
    },
  },
} as const;

export const $SearchTypeUnavailableError = {
  type: "object",
  description: "Error response when the requested search type is not available on the server.",
  properties: {
    error: {
      type: "string",
      description: "Error code.",
      example: "search_type_unavailable",
    },
    message: {
      type: "string",
      description: "Human-readable error message.",
      example: "Semantic search is not available. The embedding service is disabled on this server.",
    },
    availableTypes: {
      type: "array",
      items: {
        type: "string",
      },
      description: "List of search types that are available on this server.",
      example: ["fulltext"],
    },
  },
} as const;

export const $AccessLevel = {
  type: "string",
  description: "Access level of a user for a conversation.",
  enum: ["owner", "manager", "writer", "reader"],
} as const;

export const $ConversationSummary = {
  type: "object",
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    ownerUserId: {
      type: "string",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      format: "date-time",
    },
    lastMessagePreview: {
      type: "string",
      nullable: true,
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
  },
  example: {
    id: "550e8400-e29b-41d4-a716-446655440000",
    title: "Brainstorming UI for memory service",
    ownerUserId: "user_1234",
    createdAt: "2025-01-10T14:32:05Z",
    updatedAt: "2025-01-10T14:45:12Z",
    lastMessagePreview: "Let's try modeling forks as separate conversations…",
    accessLevel: "owner",
  },
} as const;

export const $Conversation = {
  allOf: [
    {
      $ref: "#/components/schemas/ConversationSummary",
    },
    {
      type: "object",
      properties: {
        forkedAtEntryId: {
          type: "string",
          format: "uuid",
          nullable: true,
          description: "Entry ID where this conversation forked from its parent.",
        },
        forkedAtConversationId: {
          type: "string",
          format: "uuid",
          nullable: true,
          description: "Conversation ID from which this conversation was forked.",
        },
      },
      example: {
        id: "550e8400-e29b-41d4-a716-446655440000",
        title: "Brainstorming UI for memory service",
        ownerUserId: "user_1234",
        createdAt: "2025-01-10T14:32:05Z",
        updatedAt: "2025-01-10T14:45:12Z",
        lastMessagePreview: "Let's try modeling forks as separate conversations…",
        accessLevel: "owner",
        forkedAtEntryId: null,
        forkedAtConversationId: null,
      },
    },
  ],
} as const;

export const $CreateConversationRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
    },
    metadata: {
      type: "object",
      additionalProperties: true,
    },
  },
  example: {
    title: "Chat with support bot",
    metadata: {
      source: "web-chat",
      projectId: "proj_7890",
    },
  },
} as const;

export const $ConversationMembership = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation.",
    },
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ConversationForkSummary = {
  type: "object",
  description: "Summary of a forked conversation originating at a given entry.",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the forked conversation.",
    },
    forkedAtEntryId: {
      type: "string",
      format: "uuid",
      description: "Entry ID at which this forked conversation diverged.",
    },
    forkedAtConversationId: {
      type: "string",
      format: "uuid",
      nullable: true,
      description: "Conversation ID where the fork occurred.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ShareConversationRequest = {
  type: "object",
  required: ["userId", "accessLevel"],
  properties: {
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ForkFromEntryRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
      description: "Optional title for the new forked conversation.",
    },
  },
} as const;

export const $Channel = {
  type: "string",
  description: "Logical channel of the entry within the conversation.",
  enum: ["history", "memory"],
} as const;

export const $Entry = {
  type: "object",
  required: ["id", "conversationId", "channel", "contentType", "content", "createdAt"],
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the entry.",
    },
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the conversation this entry belongs to.",
    },
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `Logical memory epoch this entry belongs to.
For history entries this is typically null. For memory entries,
the agent increments the epoch when starting a new memory version.`,
    },
    contentType: {
      type: "string",
      description: `Describes the schema/format of the content array.

**History channel entries must use \`"history"\` as the contentType.**
The content array for history entries contains objects with:
- \`text\` (string): The message text.
- \`role\` (string): Either \`"USER"\` or \`"AI"\`.


Other contentTypes (e.g., \`"LC4J"\`, \`"SpringAI"\`) may be used for
agent memory entries.`,
    },
    content: {
      type: "array",
      description: `Opaque, agent-defined content blocks.
Different agents may use different schemas; the memory-service
stores and returns them without interpretation.

For history channel entries (contentType: \`"history"\`), each block
contains \`text\` and \`role\` fields.`,
      items: {},
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
  example: {
    id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    userId: "user_1234",
    channel: "history",
    epoch: null,
    contentType: "history",
    content: [
      {
        text: "Here is a summary of what we discussed so far…",
        role: "AI",
      },
    ],
    createdAt: "2025-01-10T14:40:12Z",
  },
} as const;

export const $CreateEntryRequest = {
  type: "object",
  required: ["contentType", "content"],
  properties: {
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `For memory entries, the epoch the agent wants this entry to
belong to. The agent increments this when starting a new epoch.`,
    },
    contentType: {
      type: "string",
      description: `Describes the schema/format of the content array.

**History channel entries must use \`"history"\` as the contentType.**
The content array for history entries must contain exactly 1 object with:
- \`text\` (string): The message text.
- \`role\` (string): Either \`"USER"\` or \`"AI"\`.

Other contentTypes (e.g., \`"LC4J"\`, \`"SpringAI"\`) may be used for
agent memory entries.`,
    },
    content: {
      type: "array",
      description: `For history channel entries (contentType: \`"history"\`), each block
contains \`text\` and \`role\` fields.`,
      items: {},
    },
    indexedContent: {
      type: "string",
      nullable: true,
      description: `Optional text to index for search. Only valid for entries in the history
channel. If provided, the entry will be indexed for search immediately
after creation. Returns 400 Bad Request if specified for non-history channels.`,
    },
  },
  example: {
    userId: "user_1234",
    channel: "history",
    contentType: "history",
    content: [
      {
        text: "Based on your past chats, here are three possible approaches…",
        role: "AI",
      },
    ],
  },
} as const;

export const $SyncEntryResponse = {
  type: "object",
  properties: {
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: "The epoch number that now reflects the stored memory state.",
    },
    noOp: {
      type: "boolean",
      description: "True when the request resulted in no stored changes.",
    },
    epochIncremented: {
      type: "boolean",
      description: "True when the provided list diverged and a new epoch was started.",
    },
    entry: {
      $ref: "#/components/schemas/Entry",
      nullable: true,
      description: "The entry that was appended during this sync, or null if no-op.",
    },
  },
  example: {
    epoch: 5,
    noOp: false,
    epochIncremented: true,
    entry: {
      id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
      conversationId: "550e8400-e29b-41d4-a716-446655440000",
      userId: "agent_memory",
      channel: "memory",
      epoch: 5,
      contentType: "LC4J",
      content: [
        {
          type: "text",
          text: "First message in memory.",
        },
        {
          type: "text",
          text: "Second message added during sync.",
        },
      ],
      createdAt: "2025-01-10T14:40:12Z",
    },
  },
} as const;

export const $IndexEntryRequest = {
  type: "object",
  required: ["conversationId", "entryId", "indexedContent"],
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation containing the entry.",
    },
    entryId: {
      type: "string",
      format: "uuid",
      description: "The entry ID to index.",
    },
    indexedContent: {
      type: "string",
      description: "The searchable text for this entry.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    entryId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    indexedContent: "User asked about conversation forking and branching strategies",
  },
} as const;

export const $IndexConversationsResponse = {
  type: "object",
  properties: {
    indexed: {
      type: "integer",
      description: `Number of entries processed. These entries have their indexed content
stored and will be searchable. If vector store indexing failed for some
entries, they will become searchable asynchronously via background retry.`,
    },
  },
  example: {
    indexed: 3,
  },
} as const;

export const $UnindexedEntriesResponse = {
  type: "object",
  properties: {
    data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/UnindexedEntry",
      },
    },
    cursor: {
      type: "string",
      nullable: true,
      description: "Cursor for fetching next page. Null when no more results.",
    },
  },
  example: {
    data: [
      {
        conversationId: "550e8400-e29b-41d4-a716-446655440000",
        entry: {
          id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
          channel: "history",
          contentType: "history",
          content: [
            {
              text: "Help me design a memory service",
              role: "USER",
            },
          ],
          createdAt: "2025-01-10T14:40:12Z",
        },
      },
    ],
    cursor: "eyJjcmVhdGVkQXQiOiIyMDI1LTAxLTEwVDE0OjQwOjEyWiJ9",
  },
} as const;

export const $UnindexedEntry = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
    },
    entry: {
      $ref: "#/components/schemas/Entry",
    },
  },
} as const;

export const $SearchConversationsRequest = {
  type: "object",
  required: ["query"],
  properties: {
    query: {
      type: "string",
      description: "Natural language query.",
    },
    searchType: {
      type: "string",
      enum: ["auto", "semantic", "fulltext"],
      default: "auto",
      description: `The search method to use:
- \`auto\` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
- \`semantic\`: Use only vector/embedding-based semantic search
- \`fulltext\`: Use only PostgreSQL full-text search with GIN index

If the requested search type is not available on the server, a 501 (Not Implemented)
error is returned with details about which search types are available.
`,
    },
    after: {
      type: "string",
      nullable: true,
      description: "Cursor for pagination; returns items after this result.",
    },
    limit: {
      type: "integer",
      default: 20,
      description: "Maximum number of results to return.",
    },
    includeEntry: {
      type: "boolean",
      default: true,
      description:
        "Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.",
    },
    groupByConversation: {
      type: "boolean",
      default: true,
      description: `When true (default), groups results by conversation and returns only
the highest-scoring entry per conversation. When false, returns all
matching entries ordered by score.
`,
    },
  },
  example: {
    query: "summary of memory service design decisions",
    searchType: "auto",
    limit: 20,
    includeEntry: true,
    groupByConversation: true,
  },
} as const;

export const $SearchResult = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "Unique identifier of the conversation containing this entry.",
    },
    conversationTitle: {
      type: "string",
      description: "Title of the conversation containing this entry.",
    },
    entryId: {
      type: "string",
      format: "uuid",
      description: "ID of the matched entry. Always present for deep-linking.",
    },
    score: {
      type: "number",
      format: "float",
    },
    highlights: {
      type: "string",
      nullable: true,
    },
    entry: {
      allOf: [
        {
          $ref: "#/components/schemas/Entry",
        },
      ],
      description: "The matched entry. Only included when includeEntry is true in the request.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    conversationTitle: "Memory Service Design Discussion",
    score: 0.93,
    highlights: "design a memory service for my agent",
    entry: {
      id: "6ba7b810-9dad-11d1-80b4-00c04fd430c9",
      conversationId: "550e8400-e29b-41d4-a716-446655440000",
      userId: "user_1234",
      channel: "history",
      contentType: "history",
      content: [
        {
          text: "Help me design a memory service for my agent.",
          role: "USER",
        },
      ],
      createdAt: "2025-01-10T14:32:05Z",
    },
  },
} as const;

export const $OwnershipTransfer = {
  type: "object",
  description: `Represents a pending ownership transfer request.
Transfers are always "pending" while they exist; accepted/rejected transfers
are hard deleted from the database.`,
  required: ["id", "conversationId", "fromUserId", "toUserId", "createdAt"],
  properties: {
    id: {
      type: "string",
      format: "uuid",
      description: "Unique identifier for the transfer.",
    },
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation being transferred.",
    },
    conversationTitle: {
      type: "string",
      nullable: true,
      description: "Title of the conversation (for display purposes).",
    },
    fromUserId: {
      type: "string",
      description: "Current owner initiating the transfer.",
    },
    toUserId: {
      type: "string",
      description: "Proposed new owner (recipient).",
    },
    createdAt: {
      type: "string",
      format: "date-time",
      description: "When the transfer was initiated.",
    },
  },
  example: {
    id: "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    conversationTitle: "Help with React hooks",
    fromUserId: "user_john_doe",
    toUserId: "user_jane_smith",
    createdAt: "2025-01-28T10:30:00Z",
  },
} as const;

export const $CreateOwnershipTransferRequest = {
  type: "object",
  required: ["conversationId", "newOwnerUserId"],
  properties: {
    conversationId: {
      type: "string",
      format: "uuid",
      description: "The conversation to transfer ownership of.",
    },
    newOwnerUserId: {
      type: "string",
      description: "User ID of the proposed new owner. Must be an existing member.",
    },
  },
  example: {
    conversationId: "550e8400-e29b-41d4-a716-446655440000",
    newOwnerUserId: "user_jane_smith",
  },
} as const;

// This file is auto-generated by @hey-api/openapi-ts

export type ErrorResponse = {
  error?: string;
  code?: string;
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Access level of a user for a conversation.
 */
export type AccessLevel = "owner" | "manager" | "writer" | "reader";

export type ConversationSummary = {
  /**
   * Unique identifier for the conversation.
   */
  id?: string;
  title?: string | null;
  ownerUserId?: string;
  createdAt?: string;
  updatedAt?: string;
  lastMessagePreview?: string | null;
  accessLevel?: AccessLevel;
};

export type Conversation = ConversationSummary & {
  /**
   * Entry ID where this conversation forked from its parent.
   */
  forkedAtEntryId?: string | null;
  /**
   * Conversation ID from which this conversation was forked.
   */
  forkedAtConversationId?: string | null;
};

export type CreateConversationRequest = {
  title?: string | null;
  metadata?: {
    [key: string]: unknown;
  };
};

export type ConversationMembership = {
  /**
   * Unique identifier for the conversation.
   */
  conversationId?: string;
  userId?: string;
  accessLevel?: AccessLevel;
  createdAt?: string;
};

/**
 * Summary of a forked conversation originating at a given entry.
 */
export type ConversationForkSummary = {
  /**
   * Unique identifier for the forked conversation.
   */
  conversationId?: string;
  /**
   * Entry ID at which this forked conversation diverged.
   */
  forkedAtEntryId?: string;
  /**
   * Conversation ID where the fork occurred.
   */
  forkedAtConversationId?: string | null;
  title?: string | null;
  createdAt?: string;
};

export type ShareConversationRequest = {
  userId: string;
  accessLevel: AccessLevel;
  createdAt?: string;
};

export type ForkFromEntryRequest = {
  /**
   * Optional title for the new forked conversation.
   */
  title?: string | null;
};

/**
 * Logical channel of the entry within the conversation.
 */
export type Channel = "history" | "memory" | "transcript";

export type Entry = {
  /**
   * Unique identifier for the entry.
   */
  id: string;
  /**
   * Unique identifier for the conversation this entry belongs to.
   */
  conversationId: string;
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel: Channel;
  /**
   * Logical memory epoch this entry belongs to.
   * For history entries this is typically null. For memory entries,
   * the agent increments the epoch when starting a new memory version.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   * Examples: "message", "LC4J", "SpringAI"
   */
  contentType: string;
  /**
   * Opaque, agent-defined content blocks.
   * Different agents may use different schemas; the memory-service
   * stores and returns them without interpretation.
   */
  content: Array<unknown>;
  createdAt: string;
};

export type CreateEntryRequest = {
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel?: Channel;
  /**
   * For memory entries, the epoch the agent wants this entry to
   * belong to. The agent increments this when starting a new epoch.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   * Examples: "message", "LC4J", "SpringAI"
   */
  contentType: string;
  content: Array<unknown>;
};

export type SyncEntriesRequest = {
  /**
   * The desired memory epoch contents. Each entry must include the
   * `memory` channel and should match the ordering that the agent expects to
   * see replayed; only the agent may call this endpoint.
   */
  entries: Array<CreateEntryRequest>;
};

export type SyncEntriesResponse = {
  /**
   * The epoch number that now reflects the stored memory state.
   */
  epoch?: number | null;
  /**
   * True when the request resulted in no stored changes.
   */
  noOp?: boolean;
  /**
   * True when the provided list diverged and a new epoch was started.
   */
  epochIncremented?: boolean;
  /**
   * List of entries that were appended during this sync.
   */
  entries?: Array<Entry>;
};

export type IndexTranscriptRequest = {
  /**
   * The conversation to index.
   */
  conversationId: string;
  /**
   * Optional conversation title to store/update.
   */
  title?: string | null;
  /**
   * Transcript text to index for semantic search.
   */
  transcript: string;
  /**
   * Highest entry ID covered by the index (inclusive).
   */
  untilEntryId: string;
};

export type SearchConversationsRequest = {
  /**
   * Natural language query.
   */
  query: string;
  topK?: number;
  /**
   * Filter search to specific conversations (UUID format).
   */
  conversationIds?: Array<string> | null;
  /**
   * Optional upper bound entry ID for temporal filtering.
   */
  before?: string | null;
};

export type SearchResult = {
  entry?: Entry;
  score?: number;
  highlights?: string | null;
};

/**
 * Represents a pending ownership transfer request.
 * Transfers are always "pending" while they exist; accepted/rejected transfers
 * are hard deleted from the database.
 */
export type OwnershipTransfer = {
  /**
   * Unique identifier for the transfer.
   */
  id: string;
  /**
   * The conversation being transferred.
   */
  conversationId: string;
  /**
   * Title of the conversation (for display purposes).
   */
  conversationTitle?: string | null;
  /**
   * Current owner initiating the transfer.
   */
  fromUserId: string;
  /**
   * Proposed new owner (recipient).
   */
  toUserId: string;
  /**
   * When the transfer was initiated.
   */
  createdAt: string;
};

export type CreateOwnershipTransferRequest = {
  /**
   * The conversation to transfer ownership of.
   */
  conversationId: string;
  /**
   * User ID of the proposed new owner. Must be an existing member.
   */
  newOwnerUserId: string;
};

export type $OpenApiTs = {
  "/v1/conversations": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id (UUID format).
         */
        after?: string | null;
        /**
         * Maximum number of conversations to return.
         */
        limit?: number;
        /**
         * Listing mode for conversations.
         * - `all`: include all conversations the user can access (roots and forks).
         * - `roots`: only include root conversations.
         * - `latest-fork`: include the most recently updated conversation per root tree.
         */
        mode?: "all" | "roots" | "latest-fork";
        /**
         * Optional text query for basic title/metadata search.
         */
        query?: string | null;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created conversation.
         */
        201: Conversation;
      };
    };
  };
  "/v1/conversations/{conversationId}": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Conversation deleted.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns entries after this entry id (UUID format).
         */
        after?: string | null;
        /**
         * Channel of entries to return. Defaults to `history` for the
         * user-visible conversation; `memory` returns agent memory entries
         * scoped to the calling client id.
         */
        channel?: Channel;
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Optional epoch filter when listing the `memory` channel. Valid values
         * are `latest`, `all`, or a numeric epoch identifier. Defaults to
         * `latest` when not provided. The epoch selection is scoped to the
         * calling client id.
         */
        epoch?: string | null;
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created entry.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/sync": {
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: SyncEntriesRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/{entryId}/fork": {
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Entry identifier (UUID format).
         */
        entryId: string;
        requestBody?: ForkFromEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The newly created forked conversation.
         */
        201: Conversation;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/forks": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/response": {
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers": {
    get: {
      req: {
        /**
         * Filter by user's role in the transfer.
         */
        role?: "sender" | "recipient" | "all";
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateOwnershipTransferRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer initiated successfully.
         */
        201: OwnershipTransfer;
        /**
         * Error response
         */
        400: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * A pending transfer already exists for this conversation.
         */
        409: {
          error?: string;
          code?: string;
          /**
           * ID of the existing pending transfer
           */
          existingTransferId?: string;
        };
      };
    };
  };
  "/v1/ownership-transfers/{transferId}": {
    get: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer deleted successfully.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers/{transferId}/accept": {
    post: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer accepted successfully. Ownership has been transferred.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: ShareConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Created membership.
         */
        201: ConversationMembership;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships/{userId}": {
    patch: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: {
          accessLevel?: AccessLevel;
        };
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Membership removed.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/search": {
    post: {
      req: {
        requestBody: SearchConversationsRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
  };
  "/v1/conversations/index": {
    post: {
      req: {
        requestBody: IndexTranscriptRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The index entry was created.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
};

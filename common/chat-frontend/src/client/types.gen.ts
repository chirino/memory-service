// This file is auto-generated by @hey-api/openapi-ts

export type ErrorResponse = {
  error?: string;
  code?: string;
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Error response when the requested search type is not available on the server.
 */
export type SearchTypeUnavailableError = {
  /**
   * Error code.
   */
  error?: string;
  /**
   * Human-readable error message.
   */
  message?: string;
  /**
   * List of search types that are available on this server.
   */
  availableTypes?: Array<string>;
};

/**
 * Access level of a user for a conversation.
 */
export type AccessLevel = "owner" | "manager" | "writer" | "reader";

export type ConversationSummary = {
  /**
   * Unique identifier for the conversation.
   */
  id?: string;
  title?: string | null;
  ownerUserId?: string;
  createdAt?: string;
  updatedAt?: string;
  lastMessagePreview?: string | null;
  accessLevel?: AccessLevel;
};

export type Conversation = ConversationSummary & {
  /**
   * Entry ID where this conversation forked from its parent.
   */
  forkedAtEntryId?: string | null;
  /**
   * Conversation ID from which this conversation was forked.
   */
  forkedAtConversationId?: string | null;
};

export type CreateConversationRequest = {
  title?: string | null;
  metadata?: {
    [key: string]: unknown;
  };
};

export type ConversationMembership = {
  /**
   * Unique identifier for the conversation.
   */
  conversationId?: string;
  userId?: string;
  accessLevel?: AccessLevel;
  createdAt?: string;
};

/**
 * Summary of a forked conversation originating at a given entry.
 */
export type ConversationForkSummary = {
  /**
   * Unique identifier for the forked conversation.
   */
  conversationId?: string;
  /**
   * Entry ID at which this forked conversation diverged.
   */
  forkedAtEntryId?: string;
  /**
   * Conversation ID where the fork occurred.
   */
  forkedAtConversationId?: string | null;
  title?: string | null;
  createdAt?: string;
};

export type ShareConversationRequest = {
  userId: string;
  accessLevel: AccessLevel;
  createdAt?: string;
};

export type ForkFromEntryRequest = {
  /**
   * Optional title for the new forked conversation.
   */
  title?: string | null;
};

/**
 * Logical channel of the entry within the conversation.
 */
export type Channel = "history" | "memory";

export type Entry = {
  /**
   * Unique identifier for the entry.
   */
  id: string;
  /**
   * Unique identifier for the conversation this entry belongs to.
   */
  conversationId: string;
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel: Channel;
  /**
   * Logical memory epoch this entry belongs to.
   * For history entries this is typically null. For memory entries,
   * the agent increments the epoch when starting a new memory version.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   *
   * **History channel entries must use `"history"` as the contentType.**
   * The content array for history entries contains objects with:
   * - `text` (string): The message text.
   * - `role` (string): Either `"USER"` or `"AI"`.
   *
   *
   * Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
   * agent memory entries.
   */
  contentType: string;
  /**
   * Opaque, agent-defined content blocks.
   * Different agents may use different schemas; the memory-service
   * stores and returns them without interpretation.
   *
   * For history channel entries (contentType: `"history"`), each block
   * contains `text` and `role` fields.
   */
  content: Array<unknown>;
  createdAt: string;
};

export type CreateEntryRequest = {
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel?: Channel;
  /**
   * Describes the schema/format of the content array.
   *
   * **History channel entries must use `"history"` as the contentType.**
   * The content array for history entries must contain exactly 1 object with:
   * - `text` (string): The message text.
   * - `role` (string): Either `"USER"` or `"AI"`.
   *
   * Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
   * agent memory entries.
   */
  contentType: string;
  /**
   * For history channel entries (contentType: `"history"`), each block
   * contains `text` and `role` fields.
   */
  content: Array<unknown>;
  /**
   * Optional text to index for search. Only valid for entries in the history
   * channel. If provided, the entry will be indexed for search immediately
   * after creation. Returns 400 Bad Request if specified for non-history channels.
   */
  indexedContent?: string | null;
};

export type SyncEntryResponse = {
  /**
   * The epoch number that now reflects the stored memory state.
   */
  epoch?: number | null;
  /**
   * True when the request resulted in no stored changes.
   */
  noOp?: boolean;
  /**
   * True when the provided list diverged and a new epoch was started.
   */
  epochIncremented?: boolean;
  /**
   * The entry that was appended during this sync, or null if no-op.
   */
  entry?: Entry | null;
};

export type IndexEntryRequest = {
  /**
   * The conversation containing the entry.
   */
  conversationId: string;
  /**
   * The entry ID to index.
   */
  entryId: string;
  /**
   * The searchable text for this entry.
   */
  indexedContent: string;
};

export type IndexConversationsResponse = {
  /**
   * Number of entries processed. These entries have their indexed content
   * stored and will be searchable. If vector store indexing failed for some
   * entries, they will become searchable asynchronously via background retry.
   */
  indexed?: number;
};

export type UnindexedEntriesResponse = {
  data?: Array<UnindexedEntry>;
  /**
   * Cursor for fetching next page. Null when no more results.
   */
  cursor?: string | null;
};

export type UnindexedEntry = {
  conversationId?: string;
  entry?: Entry;
};

export type SearchConversationsRequest = {
  /**
   * Natural language query.
   */
  query: string;
  /**
   * The search method to use:
   * - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
   * - `semantic`: Use only vector/embedding-based semantic search
   * - `fulltext`: Use only PostgreSQL full-text search with GIN index
   *
   * If the requested search type is not available on the server, a 501 (Not Implemented)
   * error is returned with details about which search types are available.
   *
   */
  searchType?: "auto" | "semantic" | "fulltext";
  /**
   * Cursor for pagination; returns items after this result.
   */
  after?: string | null;
  /**
   * Maximum number of results to return.
   */
  limit?: number;
  /**
   * Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.
   */
  includeEntry?: boolean;
  /**
   * When true (default), groups results by conversation and returns only
   * the highest-scoring entry per conversation. When false, returns all
   * matching entries ordered by score.
   *
   */
  groupByConversation?: boolean;
};

export type SearchResult = {
  /**
   * Unique identifier of the conversation containing this entry.
   */
  conversationId?: string;
  /**
   * Title of the conversation containing this entry.
   */
  conversationTitle?: string;
  /**
   * ID of the matched entry. Always present for deep-linking.
   */
  entryId?: string;
  score?: number;
  highlights?: string | null;
  /**
   * The matched entry. Only included when includeEntry is true in the request.
   */
  entry?: Entry;
};

/**
 * Represents a pending ownership transfer request.
 * Transfers are always "pending" while they exist; accepted/rejected transfers
 * are hard deleted from the database.
 */
export type OwnershipTransfer = {
  /**
   * Unique identifier for the transfer.
   */
  id: string;
  /**
   * The conversation being transferred.
   */
  conversationId: string;
  /**
   * Title of the conversation (for display purposes).
   */
  conversationTitle?: string | null;
  /**
   * Current owner initiating the transfer.
   */
  fromUserId: string;
  /**
   * Proposed new owner (recipient).
   */
  toUserId: string;
  /**
   * When the transfer was initiated.
   */
  createdAt: string;
};

export type CreateOwnershipTransferRequest = {
  /**
   * The conversation to transfer ownership of.
   */
  conversationId: string;
  /**
   * User ID of the proposed new owner. Must be an existing member.
   */
  newOwnerUserId: string;
};

export type $OpenApiTs = {
  "/v1/conversations": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id (UUID format).
         */
        after?: string | null;
        /**
         * Maximum number of conversations to return.
         */
        limit?: number;
        /**
         * Listing mode for conversations. Controls which conversations are returned
         * from each fork tree (conversation group).
         * - `all`: include all conversations the user can access (roots and forks).
         * - `roots`: only include root conversations (conversations that are not forks).
         * - `latest-fork`: include only the most recently updated conversation per fork tree.
         * This is useful for showing a single representative conversation from each tree.
         */
        mode?: "all" | "roots" | "latest-fork";
        /**
         * Optional text query for basic title/metadata search.
         */
        query?: string | null;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created conversation.
         */
        201: Conversation;
      };
    };
  };
  "/v1/conversations/{conversationId}": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Conversation deleted.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns entries after this entry id (UUID format).
         */
        after?: string | null;
        /**
         * Channel of entries to return. Defaults to `history` for the
         * user-visible conversation; `memory` returns agent memory entries
         * scoped to the calling client id.
         */
        channel?: Channel;
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Optional epoch filter when listing the `memory` channel. Valid values
         * are `latest`, `all`, or a numeric epoch identifier. Defaults to
         * `latest` when not provided. The epoch selection is scoped to the
         * calling client id.
         */
        epoch?: string | null;
        /**
         * Controls which fork entries to include. `none` (default) follows the
         * fork ancestry path, returning entries from the target conversation
         * and its ancestors up to fork points. `all` returns entries from all
         * forks in the conversation group, useful for debugging or getting a
         * complete picture of all activity across forks.
         */
        forks?: "none" | "all";
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created entry.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/sync": {
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/{entryId}/fork": {
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        /**
         * Entry identifier (UUID format).
         */
        entryId: string;
        requestBody?: ForkFromEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The newly created forked conversation.
         */
        201: Conversation;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/forks": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/response": {
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers": {
    get: {
      req: {
        /**
         * Filter by user's role in the transfer.
         */
        role?: "sender" | "recipient" | "all";
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateOwnershipTransferRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer initiated successfully.
         */
        201: OwnershipTransfer;
        /**
         * Error response
         */
        400: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * A pending transfer already exists for this conversation.
         */
        409: {
          error?: string;
          code?: string;
          /**
           * ID of the existing pending transfer
           */
          existingTransferId?: string;
        };
      };
    };
  };
  "/v1/ownership-transfers/{transferId}": {
    get: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer deleted successfully.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/ownership-transfers/{transferId}/accept": {
    post: {
      req: {
        /**
         * Transfer identifier (UUID format).
         */
        transferId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Transfer accepted successfully. Ownership has been transferred.
         */
        204: void;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships": {
    get: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: ShareConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Created membership.
         */
        201: ConversationMembership;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships/{userId}": {
    patch: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        requestBody: {
          accessLevel?: AccessLevel;
        };
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        /**
         * Conversation identifier (UUID format).
         */
        conversationId: string;
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Membership removed.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/search": {
    post: {
      req: {
        requestBody: SearchConversationsRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Requested search type is not available on this server
         */
        501: SearchTypeUnavailableError;
      };
    };
  };
  "/v1/conversations/index": {
    post: {
      req: {
        requestBody: Array<IndexEntryRequest>;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/unindexed": {
    get: {
      req: {
        /**
         * Pagination cursor from previous response.
         */
        cursor?: string;
        /**
         * Maximum number of entries to return.
         */
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Error response
         */
        403: ErrorResponse;
      };
    };
  };
};

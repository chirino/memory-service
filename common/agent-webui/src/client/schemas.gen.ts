// This file is auto-generated by @hey-api/openapi-ts

export const $ErrorResponse = {
  type: "object",
  properties: {
    error: {
      type: "string",
    },
    code: {
      type: "string",
    },
    details: {
      type: "object",
      additionalProperties: true,
    },
  },
} as const;

export const $AccessLevel = {
  type: "string",
  description: "Access level of a user for a conversation.",
  enum: ["owner", "manager", "writer", "reader"],
} as const;

export const $ConversationSummary = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    title: {
      type: "string",
      nullable: true,
    },
    ownerUserId: {
      type: "string",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      format: "date-time",
    },
    lastMessagePreview: {
      type: "string",
      nullable: true,
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
  },
  example: {
    id: "conv_01HF8XH1XABCD1234EFGH5678",
    title: "Brainstorming UI for memory service",
    ownerUserId: "user_1234",
    createdAt: "2025-01-10T14:32:05Z",
    updatedAt: "2025-01-10T14:45:12Z",
    lastMessagePreview: "Let’s try modeling forks as separate conversations…",
    accessLevel: "owner",
  },
} as const;

export const $Conversation = {
  allOf: [
    {
      $ref: "#/components/schemas/ConversationSummary",
    },
    {
      type: "object",
      properties: {
        forkedAtMessageId: {
          type: "string",
          nullable: true,
        },
        forkedAtConversationId: {
          type: "string",
          nullable: true,
        },
      },
      example: {
        id: "conv_01HF8XH1XABCD1234EFGH5678",
        title: "Brainstorming UI for memory service",
        ownerUserId: "user_1234",
        createdAt: "2025-01-10T14:32:05Z",
        updatedAt: "2025-01-10T14:45:12Z",
        lastMessagePreview: "Let's try modeling forks as separate conversations…",
        accessLevel: "owner",
        forkedAtMessageId: null,
        forkedAtConversationId: null,
      },
    },
  ],
} as const;

export const $CreateConversationRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
    },
    metadata: {
      type: "object",
      additionalProperties: true,
    },
  },
  example: {
    title: "Chat with support bot",
    metadata: {
      source: "web-chat",
      projectId: "proj_7890",
    },
  },
} as const;

export const $ConversationMembership = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
    },
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ConversationForkSummary = {
  type: "object",
  description: "Summary of a forked conversation originating at a given message.",
  properties: {
    conversationId: {
      type: "string",
    },
    forkedAtMessageId: {
      type: "string",
      description: "Message id at which this forked conversation diverged.",
    },
    forkedAtConversationId: {
      type: "string",
      nullable: true,
      description: "Conversation id where the fork occurred.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ShareConversationRequest = {
  type: "object",
  required: ["userId", "accessLevel"],
  properties: {
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ForkFromMessageRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
      description: "Optional title for the new forked conversation.",
    },
  },
} as const;

export const $MessageChannel = {
  type: "string",
  description: "Logical channel of the message within the conversation.",
  enum: ["history", "memory", "summary"],
} as const;

export const $Message = {
  type: "object",
  required: ["id", "conversationId", "channel", "content", "createdAt"],
  properties: {
    id: {
      type: "string",
    },
    conversationId: {
      type: "string",
    },
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this message is associated with.
For history messages authored by a user, this is the sender.
For agent messages, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/MessageChannel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `Logical memory epoch this message belongs to.
For history messages this is typically null. For memory messages,
the agent increments the epoch when starting a new memory version.`,
    },
    content: {
      type: "array",
      description: `Opaque, agent-defined message content blocks.
Different agents may use different schemas; the memory-service
stores and returns them without interpretation.`,
      items: {},
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
  example: {
    id: "msg_01HF8XJQWXYZ9876ABCD5432",
    conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
    userId: "user_1234",
    channel: "history",
    epoch: null,
    content: [
      {
        type: "text",
        text: "Here is a summary of what we discussed so far…",
      },
    ],
    createdAt: "2025-01-10T14:40:12Z",
  },
} as const;

export const $CreateMessageRequest = {
  type: "object",
  required: ["content"],
  properties: {
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this message is associated with.
For history messages authored by a user, this is the sender.
For agent messages, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/MessageChannel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `For memory messages, the epoch the agent wants this message to
belong to. The agent increments this when starting a new epoch.`,
    },
    content: {
      type: "array",
      items: {},
    },
  },
  example: {
    senderId: "user_1234",
    channel: "history",
    content: [
      {
        type: "text",
        text: "Based on your past chats, here are three possible approaches…",
      },
    ],
  },
} as const;

export const $SyncMessagesRequest = {
  type: "object",
  required: ["messages"],
  properties: {
    messages: {
      type: "array",
      description: `The desired memory epoch contents. Each entry must include the
\`memory\` channel and should match the ordering that the agent expects to
see replayed; only the agent may call this endpoint.`,
      items: {
        $ref: "#/components/schemas/CreateMessageRequest",
      },
    },
  },
  example: {
    messages: [
      {
        userId: "user_1234",
        channel: "memory",
        content: [
          {
            type: "text",
            text: "The user asked about memory sync.",
          },
        ],
      },
      {
        userId: "user_1234",
        channel: "memory",
        content: [
          {
            type: "text",
            text: "I learned that child steps matter.",
          },
        ],
      },
    ],
  },
} as const;

export const $SyncMessagesResponse = {
  type: "object",
  properties: {
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: "The epoch number that now reflects the stored memory state.",
    },
    noOp: {
      type: "boolean",
      description: "True when the request resulted in no stored changes.",
    },
    epochIncremented: {
      type: "boolean",
      description: "True when the provided list diverged and a new epoch was started.",
    },
    messages: {
      type: "array",
      description: "List of messages that were appended during this sync.",
      items: {
        $ref: "#/components/schemas/Message",
      },
    },
  },
  example: {
    epoch: 5,
    noOp: false,
    epochIncremented: true,
    messages: [
      {
        id: "msg_01HF8XJQWXYZ9876ABCD5432",
        conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
        userId: "agent_memory",
        channel: "memory",
        epoch: 5,
        content: [
          {
            type: "text",
            text: "Updated memory after re-sync.",
          },
        ],
        createdAt: "2025-01-10T14:40:12Z",
      },
    ],
  },
} as const;

export const $CreateSummaryRequest = {
  type: "object",
  required: ["title", "summary", "untilMessageId", "summarizedAt"],
  properties: {
    title: {
      type: "string",
      description: "Conversation title to store/update.",
    },
    summary: {
      type: "string",
      description: "Summary text.",
    },
    untilMessageId: {
      type: "string",
      description: "Highest message id covered by the summary (inclusive).",
    },
    summarizedAt: {
      type: "string",
      format: "date-time",
      description: "Timestamp of the last message covered by the summary.",
    },
  },
  example: {
    title: "Conversation forking design",
    summary:
      "User asked several questions about conversation forking. They want to support branching at any message with independent access control per branch.",
    untilMessageId: "msg_01HF8XJQWXYZ9876ABCD5431",
    summarizedAt: "2024-05-01T12:34:56Z",
  },
} as const;

export const $SearchMessagesRequest = {
  type: "object",
  required: ["query"],
  properties: {
    query: {
      type: "string",
      description: "Natural language query.",
    },
    topK: {
      type: "integer",
      default: 20,
    },
    conversationIds: {
      type: "array",
      items: {
        type: "string",
      },
      nullable: true,
    },
    before: {
      type: "string",
      nullable: true,
      description: "Optional upper bound message id for temporal filtering.",
    },
  },
  example: {
    query: "summary of memory service design decisions",
    topK: 5,
    conversationIds: ["conv_01HF8XH1XABCD1234EFGH5678", "conv_01HF8XH1XABCD1234EFGH5679"],
    before: "msg_01HF8XJQWXYZ9876ABCD5431",
  },
} as const;

export const $SearchResult = {
  type: "object",
  properties: {
    message: {
      $ref: "#/components/schemas/Message",
    },
    score: {
      type: "number",
      format: "float",
    },
    highlights: {
      type: "string",
      nullable: true,
    },
  },
  example: {
    message: {
      id: "msg_01HF8XJQWXYZ9876ABCD5430",
      conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
      role: "user",
      visibility: "user",
      content: [
        {
          type: "text",
          text: "Help me design a memory service for my agent.",
        },
      ],
      metadata: {
        source: "search",
      },
      createdAt: "2025-01-10T14:32:05Z",
    },
    score: 0.93,
    highlights: "design a memory service for my agent",
  },
} as const;

// This file is auto-generated by @hey-api/openapi-ts

export const $ErrorResponse = {
  type: "object",
  properties: {
    error: {
      type: "string",
    },
    code: {
      type: "string",
    },
    details: {
      type: "object",
      additionalProperties: true,
    },
  },
} as const;

export const $AccessLevel = {
  type: "string",
  description: "Access level of a user for a conversation.",
  enum: ["owner", "manager", "writer", "reader"],
} as const;

export const $ConversationSummary = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    title: {
      type: "string",
      nullable: true,
    },
    ownerUserId: {
      type: "string",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      format: "date-time",
    },
    lastMessagePreview: {
      type: "string",
      nullable: true,
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
  },
  example: {
    id: "conv_01HF8XH1XABCD1234EFGH5678",
    title: "Brainstorming UI for memory service",
    ownerUserId: "user_1234",
    createdAt: "2025-01-10T14:32:05Z",
    updatedAt: "2025-01-10T14:45:12Z",
    lastMessagePreview: "Let’s try modeling forks as separate conversations…",
    accessLevel: "owner",
  },
} as const;

export const $Conversation = {
  allOf: [
    {
      $ref: "#/components/schemas/ConversationSummary",
    },
    {
      type: "object",
      properties: {
        forkedAtEntryId: {
          type: "string",
          nullable: true,
        },
        forkedAtConversationId: {
          type: "string",
          nullable: true,
        },
      },
      example: {
        id: "conv_01HF8XH1XABCD1234EFGH5678",
        title: "Brainstorming UI for memory service",
        ownerUserId: "user_1234",
        createdAt: "2025-01-10T14:32:05Z",
        updatedAt: "2025-01-10T14:45:12Z",
        lastMessagePreview: "Let's try modeling forks as separate conversations…",
        accessLevel: "owner",
        forkedAtEntryId: null,
        forkedAtConversationId: null,
      },
    },
  ],
} as const;

export const $CreateConversationRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
    },
    metadata: {
      type: "object",
      additionalProperties: true,
    },
  },
  example: {
    title: "Chat with support bot",
    metadata: {
      source: "web-chat",
      projectId: "proj_7890",
    },
  },
} as const;

export const $ConversationMembership = {
  type: "object",
  properties: {
    conversationId: {
      type: "string",
    },
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ConversationForkSummary = {
  type: "object",
  description: "Summary of a forked conversation originating at a given entry.",
  properties: {
    conversationId: {
      type: "string",
    },
    forkedAtEntryId: {
      type: "string",
      description: "Entry id at which this forked conversation diverged.",
    },
    forkedAtConversationId: {
      type: "string",
      nullable: true,
      description: "Conversation id where the fork occurred.",
    },
    title: {
      type: "string",
      nullable: true,
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ShareConversationRequest = {
  type: "object",
  required: ["userId", "accessLevel"],
  properties: {
    userId: {
      type: "string",
    },
    accessLevel: {
      $ref: "#/components/schemas/AccessLevel",
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
} as const;

export const $ForkFromEntryRequest = {
  type: "object",
  properties: {
    title: {
      type: "string",
      nullable: true,
      description: "Optional title for the new forked conversation.",
    },
  },
} as const;

export const $Channel = {
  type: "string",
  description: "Logical channel of the entry within the conversation.",
  enum: ["history", "memory", "transcript"],
} as const;

export const $Entry = {
  type: "object",
  required: ["id", "conversationId", "channel", "contentType", "content", "createdAt"],
  properties: {
    id: {
      type: "string",
    },
    conversationId: {
      type: "string",
    },
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `Logical memory epoch this entry belongs to.
For history entries this is typically null. For memory entries,
the agent increments the epoch when starting a new memory version.`,
    },
    contentType: {
      type: "string",
      description: `Describes the schema/format of the content array.
Examples: "message", "LC4J", "SpringAI"`,
    },
    content: {
      type: "array",
      description: `Opaque, agent-defined content blocks.
Different agents may use different schemas; the memory-service
stores and returns them without interpretation.`,
      items: {},
    },
    createdAt: {
      type: "string",
      format: "date-time",
    },
  },
  example: {
    id: "entry_01HF8XJQWXYZ9876ABCD5432",
    conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
    userId: "user_1234",
    channel: "history",
    epoch: null,
    contentType: "message",
    content: [
      {
        type: "text",
        text: "Here is a summary of what we discussed so far…",
      },
    ],
    createdAt: "2025-01-10T14:40:12Z",
  },
} as const;

export const $CreateEntryRequest = {
  type: "object",
  required: ["contentType", "content"],
  properties: {
    userId: {
      type: "string",
      nullable: true,
      description: `Human user this entry is associated with.
For history entries authored by a user, this is the sender.
For agent entries, this is the user the agent is responding to.`,
    },
    channel: {
      $ref: "#/components/schemas/Channel",
    },
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: `For memory entries, the epoch the agent wants this entry to
belong to. The agent increments this when starting a new epoch.`,
    },
    contentType: {
      type: "string",
      description: `Describes the schema/format of the content array.
Examples: "message", "LC4J", "SpringAI"`,
    },
    content: {
      type: "array",
      items: {},
    },
  },
  example: {
    userId: "user_1234",
    channel: "history",
    contentType: "message",
    content: [
      {
        type: "text",
        text: "Based on your past chats, here are three possible approaches…",
      },
    ],
  },
} as const;

export const $SyncEntriesRequest = {
  type: "object",
  required: ["entries"],
  properties: {
    entries: {
      type: "array",
      description: `The desired memory epoch contents. Each entry must include the
\`memory\` channel and should match the ordering that the agent expects to
see replayed; only the agent may call this endpoint.`,
      items: {
        $ref: "#/components/schemas/CreateEntryRequest",
      },
    },
  },
  example: {
    entries: [
      {
        userId: "user_1234",
        channel: "memory",
        contentType: "LC4J",
        content: [
          {
            type: "text",
            text: "The user asked about memory sync.",
          },
        ],
      },
      {
        userId: "user_1234",
        channel: "memory",
        contentType: "LC4J",
        content: [
          {
            type: "text",
            text: "I learned that child steps matter.",
          },
        ],
      },
    ],
  },
} as const;

export const $SyncEntriesResponse = {
  type: "object",
  properties: {
    epoch: {
      type: "integer",
      format: "int64",
      nullable: true,
      description: "The epoch number that now reflects the stored memory state.",
    },
    noOp: {
      type: "boolean",
      description: "True when the request resulted in no stored changes.",
    },
    epochIncremented: {
      type: "boolean",
      description: "True when the provided list diverged and a new epoch was started.",
    },
    entries: {
      type: "array",
      description: "List of entries that were appended during this sync.",
      items: {
        $ref: "#/components/schemas/Entry",
      },
    },
  },
  example: {
    epoch: 5,
    noOp: false,
    epochIncremented: true,
    entries: [
      {
        id: "entry_01HF8XJQWXYZ9876ABCD5432",
        conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
        userId: "agent_memory",
        channel: "memory",
        epoch: 5,
        contentType: "LC4J",
        content: [
          {
            type: "text",
            text: "Updated memory after re-sync.",
          },
        ],
        createdAt: "2025-01-10T14:40:12Z",
      },
    ],
  },
} as const;

export const $IndexTranscriptRequest = {
  type: "object",
  required: ["conversationId", "transcript", "untilEntryId"],
  properties: {
    conversationId: {
      type: "string",
      description: "The conversation to index.",
    },
    title: {
      type: "string",
      nullable: true,
      description: "Optional conversation title to store/update.",
    },
    transcript: {
      type: "string",
      description: "Transcript text to index for semantic search.",
    },
    untilEntryId: {
      type: "string",
      description: "Highest entry id covered by the index (inclusive).",
    },
  },
  example: {
    conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
    title: "Conversation forking design",
    transcript:
      "User asked several questions about conversation forking. They want to support branching at any message with independent access control per branch.",
    untilEntryId: "entry_01HF8XJQWXYZ9876ABCD5431",
  },
} as const;

export const $SearchConversationsRequest = {
  type: "object",
  required: ["query"],
  properties: {
    query: {
      type: "string",
      description: "Natural language query.",
    },
    topK: {
      type: "integer",
      default: 20,
    },
    conversationIds: {
      type: "array",
      items: {
        type: "string",
      },
      nullable: true,
    },
    before: {
      type: "string",
      nullable: true,
      description: "Optional upper bound entry id for temporal filtering.",
    },
  },
  example: {
    query: "summary of memory service design decisions",
    topK: 5,
    conversationIds: ["conv_01HF8XH1XABCD1234EFGH5678", "conv_01HF8XH1XABCD1234EFGH5679"],
    before: "entry_01HF8XJQWXYZ9876ABCD5431",
  },
} as const;

export const $SearchResult = {
  type: "object",
  properties: {
    entry: {
      $ref: "#/components/schemas/Entry",
    },
    score: {
      type: "number",
      format: "float",
    },
    highlights: {
      type: "string",
      nullable: true,
    },
  },
  example: {
    entry: {
      id: "entry_01HF8XJQWXYZ9876ABCD5430",
      conversationId: "conv_01HF8XH1XABCD1234EFGH5678",
      userId: "user_1234",
      channel: "history",
      contentType: "message",
      content: [
        {
          type: "text",
          text: "Help me design a memory service for my agent.",
        },
      ],
      createdAt: "2025-01-10T14:32:05Z",
    },
    score: 0.93,
    highlights: "design a memory service for my agent",
  },
} as const;

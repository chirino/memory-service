// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from "./core/CancelablePromise";
import { OpenAPI } from "./core/OpenAPI";
import { request as __request } from "./core/request";
import type { $OpenApiTs } from "./types.gen";

export class ConversationsService {
  /**
   * List conversations visible to current user
   * Lists all conversations the current user has access to (owner, manager, writer, or reader).
   * @param data The data for the request.
   * @param data.mode Listing mode for conversations.
   * - `all`: include all conversations the user can access (roots and forks).
   * - `roots`: only include root conversations.
   * - `latest-fork`: include the most recently updated conversation per root tree.
   * @param data.after Cursor for pagination; returns items after this conversation id.
   * @param data.limit Maximum number of conversations to return.
   * @param data.query Optional text query for basic title/metadata search.
   * @returns unknown A list of conversations.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversations(
    data: $OpenApiTs["/v1/conversations"]["get"]["req"] = {},
  ): CancelablePromise<
    $OpenApiTs["/v1/conversations"]["get"]["res"][200] | $OpenApiTs["/v1/conversations"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations",
      query: {
        mode: data.mode,
        after: data.after,
        limit: data.limit,
        query: data.query,
      },
    });
  }

  /**
   * Create a conversation
   * Creates a new conversation owned by the current user.
   * @param data The data for the request.
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Conversation The created conversation.
   * @throws ApiError
   */
  public static createConversation(
    data: $OpenApiTs["/v1/conversations"]["post"]["req"],
  ): CancelablePromise<
    $OpenApiTs["/v1/conversations"]["post"]["res"][200] | $OpenApiTs["/v1/conversations"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations",
      body: data.requestBody,
      mediaType: "application/json",
    });
  }

  /**
   * Get a conversation
   * Retrieve a conversation the user has access to.
   * @param data The data for the request.
   * @param data.conversationId Conversation identifier.
   * @returns Conversation The conversation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static getConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Delete a conversation
   * Deletes a conversation. Only the owner (or manager, depending on policy) may delete.
   *
   * **Deleting a conversation deletes all conversations in the same fork tree** (the root conversation and all its forks). Memberships and messages associated with these conversations are also deleted.
   * @param data The data for the request.
   * @param data.conversationId
   * @returns ErrorResponse Error response
   * @returns void Conversation deleted.
   * @throws ApiError
   */
  public static deleteConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/conversations/{conversationId}",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * List conversation entries
   * Returns entries in a conversation, ordered by creation time.
   *
   * The `channel` parameter determines which logical channel of entries
   * is returned:
   *
   * - `history` (default) returns the user-visible conversation between
   * users and the agent.
   * - `memory` returns agent memory entries which are typically not
   * shown directly to end users. Memory entries are scoped to the
   * calling client id derived from the API key.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.after Cursor for pagination; returns entries after this entry id.
   * @param data.limit
   * @param data.channel Channel of entries to return. Defaults to `history` for the
   * user-visible conversation; `memory` returns agent memory entries
   * scoped to the calling client id.
   * @param data.epoch Optional epoch filter when listing the `memory` channel. Valid values
   * are `latest`, `all`, or a numeric epoch identifier. Defaults to
   * `latest` when not provided. The epoch selection is scoped to the
   * calling client id.
   * @returns unknown A list of entries.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationEntries(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/entries",
      path: {
        conversationId: data.conversationId,
      },
      query: {
        after: data.after,
        limit: data.limit,
        channel: data.channel,
        epoch: data.epoch,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Append an entry
   * Appends a new entry to the conversation.
   *
   * This endpoint is used by both end-user clients and agents.
   * The service determines whether the caller is a user or an agent
   * based on authentication (for example, API keys or tokens) and
   * stores the entry with the appropriate internal role and visibility.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Entry The created entry.
   * @throws ApiError
   */
  public static appendConversationEntry(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/entries",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Synchronize the agent memory epoch
   * Synchronizes the in-memory context for the conversation. The service fails
   * when any entry is not targeting the `memory` channel, then compares the
   * provided list to the entries already stored in the latest memory epoch.
   * If there is no difference it is a no-op, if the list merely appends more
   * entries they are added to the current epoch, otherwise a new epoch is
   * created and all provided entries are stored under the new epoch. Memory
   * sync is scoped to the calling client id (from the API key). Requires a
   * valid agent API key.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.requestBody
   * @returns SyncEntriesResponse Result of the sync operation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static syncConversationMemory(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/sync"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/entries/sync",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Fork a conversation at a given user entry
   * Creates a new conversation that replays history up to just before the selected
   * user entry and then diverges starting at that point.
   *
   * The fork point must be an existing user-authored entry; in the new forked
   * conversation that original entry is not present and the next user entry
   * is supplied by the caller in a follow-up request.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.entryId
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Conversation The newly created forked conversation.
   * @throws ApiError
   */
  public static forkConversationAtEntry(
    data: $OpenApiTs["/v1/conversations/{conversationId}/entries/{entryId}/fork"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/{entryId}/fork"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/entries/{entryId}/fork"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/entries/{entryId}/fork",
      path: {
        conversationId: data.conversationId,
        entryId: data.entryId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * List forks for a conversation
   * Returns all forked conversations that share the same root conversation as the
   * given conversation. Each fork entry includes the message id at which it forked
   * and the timestamp when the forked conversation was created.
   *
   * This is intended for UIs that want to fetch all fork points once per conversation
   * and then decide how to render branch navigation (e.g., which is the oldest fork).
   * @param data The data for the request.
   * @param data.conversationId
   * @returns unknown Forked conversations related to this conversation's root.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationForks(
    data: $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/forks",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Share conversation with another user
   * Grants another user access to the conversation with the specified access level.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns ConversationMembership Created membership.
   * @throws ApiError
   */
  public static shareConversation(
    data: $OpenApiTs["/v1/conversations/{conversationId}/forks"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/forks"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/forks",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Cancel an in-progress response
   * Requests cancellation of an in-progress response stream for the conversation.
   * Requires WRITER access and an authenticated user session.
   * @param data The data for the request.
   * @param data.conversationId
   * @returns unknown Cancel request accepted.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static cancelConversationResponse(
    data: $OpenApiTs["/v1/conversations/{conversationId}/cancel-response"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/cancel-response"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/cancel-response"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/cancel-response",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
        409: "Error response",
      },
    });
  }
}

export class SharingService {
  /**
   * Request ownership transfer
   * Initiates a transfer of conversation ownership to another user. The other
   * user must accept the transfer via a separate API or out-of-band process.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns unknown Ownership transfer requested.
   * @throws ApiError
   */
  public static transferConversationOwnership(
    data: $OpenApiTs["/v1/conversations/{conversationId}/transfer-ownership"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/transfer-ownership"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/transfer-ownership"]["post"]["res"][202]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/transfer-ownership",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * List conversation memberships
   * Lists all users that have access to the conversation and their access levels.
   * @param data The data for the request.
   * @param data.conversationId
   * @returns unknown Memberships for the conversation.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static listConversationMemberships(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships"]["get"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "GET",
      url: "/v1/conversations/{conversationId}/memberships",
      path: {
        conversationId: data.conversationId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Update a member's access level
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.userId
   * @param data.requestBody
   * @returns ConversationMembership Updated membership.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static updateConversationMembership(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["patch"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "PATCH",
      url: "/v1/conversations/{conversationId}/memberships/{userId}",
      path: {
        conversationId: data.conversationId,
        userId: data.userId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }

  /**
   * Remove a member from the conversation
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.userId
   * @returns ErrorResponse Error response
   * @returns void Membership removed.
   * @throws ApiError
   */
  public static deleteConversationMembership(
    data: $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/memberships/{userId}"]["delete"]["res"][204]
  > {
    return __request(OpenAPI, {
      method: "DELETE",
      url: "/v1/conversations/{conversationId}/memberships/{userId}",
      path: {
        conversationId: data.conversationId,
        userId: data.userId,
      },
      errors: {
        404: "Resource not found",
      },
    });
  }
}

export class SearchService {
  /**
   * Semantic search across user's conversations
   * Performs semantic and/or keyword search across all conversations the user has access to.
   * Backed by an internal vector store (pgvector, MongoDB, etc.).
   * @param data The data for the request.
   * @param data.requestBody
   * @returns unknown Search results.
   * @returns ErrorResponse Error response
   * @throws ApiError
   */
  public static searchEntries(
    data: $OpenApiTs["/v1/user/search/entries"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/user/search/entries"]["post"]["res"][200]
    | $OpenApiTs["/v1/user/search/entries"]["post"]["res"][200]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/user/search/entries",
      body: data.requestBody,
      mediaType: "application/json",
    });
  }

  /**
   * Store a summarization of previous entries
   * Stores an internal summarization of previous entries in the conversation.
   * Summary entries are not visible in user-facing entry lists.
   * Requires a valid agent API key.
   * @param data The data for the request.
   * @param data.conversationId
   * @param data.requestBody
   * @returns ErrorResponse Error response
   * @returns Entry The created summary entry.
   * @throws ApiError
   */
  public static createConversationSummary(
    data: $OpenApiTs["/v1/conversations/{conversationId}/summaries"]["post"]["req"],
  ): CancelablePromise<
    | $OpenApiTs["/v1/conversations/{conversationId}/summaries"]["post"]["res"][200]
    | $OpenApiTs["/v1/conversations/{conversationId}/summaries"]["post"]["res"][201]
  > {
    return __request(OpenAPI, {
      method: "POST",
      url: "/v1/conversations/{conversationId}/summaries",
      path: {
        conversationId: data.conversationId,
      },
      body: data.requestBody,
      mediaType: "application/json",
      errors: {
        404: "Resource not found",
      },
    });
  }
}

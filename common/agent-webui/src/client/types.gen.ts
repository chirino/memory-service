// This file is auto-generated by @hey-api/openapi-ts

export type ErrorResponse = {
  error?: string;
  code?: string;
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Access level of a user for a conversation.
 */
export type AccessLevel = "owner" | "manager" | "writer" | "reader";

export type ConversationSummary = {
  id?: string;
  title?: string | null;
  ownerUserId?: string;
  createdAt?: string;
  updatedAt?: string;
  lastMessagePreview?: string | null;
  accessLevel?: AccessLevel;
};

export type Conversation = ConversationSummary & {
  forkedAtEntryId?: string | null;
  forkedAtConversationId?: string | null;
};

export type CreateConversationRequest = {
  title?: string | null;
  metadata?: {
    [key: string]: unknown;
  };
};

export type ConversationMembership = {
  conversationId?: string;
  userId?: string;
  accessLevel?: AccessLevel;
  createdAt?: string;
};

/**
 * Summary of a forked conversation originating at a given entry.
 */
export type ConversationForkSummary = {
  conversationId?: string;
  /**
   * Entry id at which this forked conversation diverged.
   */
  forkedAtEntryId?: string;
  /**
   * Conversation id where the fork occurred.
   */
  forkedAtConversationId?: string | null;
  title?: string | null;
  createdAt?: string;
};

export type ShareConversationRequest = {
  userId: string;
  accessLevel: AccessLevel;
  createdAt?: string;
};

export type ForkFromEntryRequest = {
  /**
   * Optional title for the new forked conversation.
   */
  title?: string | null;
};

/**
 * Logical channel of the entry within the conversation.
 */
export type Channel = "history" | "memory" | "summary";

export type Entry = {
  id: string;
  conversationId: string;
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel: Channel;
  /**
   * Logical memory epoch this entry belongs to.
   * For history entries this is typically null. For memory entries,
   * the agent increments the epoch when starting a new memory version.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   * Examples: "message", "LC4J", "SpringAI"
   */
  contentType: string;
  /**
   * Opaque, agent-defined content blocks.
   * Different agents may use different schemas; the memory-service
   * stores and returns them without interpretation.
   */
  content: Array<unknown>;
  createdAt: string;
};

export type CreateEntryRequest = {
  /**
   * Human user this entry is associated with.
   * For history entries authored by a user, this is the sender.
   * For agent entries, this is the user the agent is responding to.
   */
  userId?: string | null;
  channel?: Channel;
  /**
   * For memory entries, the epoch the agent wants this entry to
   * belong to. The agent increments this when starting a new epoch.
   */
  epoch?: number | null;
  /**
   * Describes the schema/format of the content array.
   * Examples: "message", "LC4J", "SpringAI"
   */
  contentType: string;
  content: Array<unknown>;
};

export type SyncEntriesRequest = {
  /**
   * The desired memory epoch contents. Each entry must include the
   * `memory` channel and should match the ordering that the agent expects to
   * see replayed; only the agent may call this endpoint.
   */
  entries: Array<CreateEntryRequest>;
};

export type SyncEntriesResponse = {
  /**
   * The epoch number that now reflects the stored memory state.
   */
  epoch?: number | null;
  /**
   * True when the request resulted in no stored changes.
   */
  noOp?: boolean;
  /**
   * True when the provided list diverged and a new epoch was started.
   */
  epochIncremented?: boolean;
  /**
   * List of entries that were appended during this sync.
   */
  entries?: Array<Entry>;
};

export type CreateSummaryRequest = {
  /**
   * Conversation title to store/update.
   */
  title: string;
  /**
   * Summary text.
   */
  summary: string;
  /**
   * Highest message id covered by the summary (inclusive).
   */
  untilEntryId: string;
  /**
   * Timestamp of the last message covered by the summary.
   */
  summarizedAt: string;
};

export type SearchEntriesRequest = {
  /**
   * Natural language query.
   */
  query: string;
  topK?: number;
  conversationIds?: Array<string> | null;
  /**
   * Optional upper bound entry id for temporal filtering.
   */
  before?: string | null;
};

export type SearchResult = {
  entry?: Entry;
  score?: number;
  highlights?: string | null;
};

export type $OpenApiTs = {
  "/v1/conversations": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns items after this conversation id.
         */
        after?: string | null;
        /**
         * Maximum number of conversations to return.
         */
        limit?: number;
        /**
         * Listing mode for conversations.
         * - `all`: include all conversations the user can access (roots and forks).
         * - `roots`: only include root conversations.
         * - `latest-fork`: include the most recently updated conversation per root tree.
         */
        mode?: "all" | "roots" | "latest-fork";
        /**
         * Optional text query for basic title/metadata search.
         */
        query?: string | null;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
    post: {
      req: {
        requestBody: CreateConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created conversation.
         */
        201: Conversation;
      };
    };
  };
  "/v1/conversations/{conversationId}": {
    get: {
      req: {
        /**
         * Conversation identifier.
         */
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Conversation deleted.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries": {
    get: {
      req: {
        /**
         * Cursor for pagination; returns entries after this entry id.
         */
        after?: string | null;
        /**
         * Channel of entries to return. Defaults to `history` for the
         * user-visible conversation; `memory` returns agent memory entries
         * scoped to the calling client id.
         */
        channel?: Channel;
        conversationId: string;
        /**
         * Optional epoch filter when listing the `memory` channel. Valid values
         * are `latest`, `all`, or a numeric epoch identifier. Defaults to
         * `latest` when not provided. The epoch selection is scoped to the
         * calling client id.
         */
        epoch?: string | null;
        limit?: number;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        conversationId: string;
        requestBody: CreateEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created entry.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/sync": {
    post: {
      req: {
        conversationId: string;
        requestBody: SyncEntriesRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/entries/{entryId}/fork": {
    post: {
      req: {
        conversationId: string;
        entryId: string;
        requestBody?: ForkFromEntryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The newly created forked conversation.
         */
        201: Conversation;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/forks": {
    get: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    post: {
      req: {
        conversationId: string;
        requestBody: ShareConversationRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Created membership.
         */
        201: ConversationMembership;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/response": {
    delete: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
        /**
         * Error response
         */
        409: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/transfer-ownership": {
    post: {
      req: {
        conversationId: string;
        requestBody: {
          newOwnerUserId: string;
        };
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Ownership transfer requested.
         */
        202: unknown;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships": {
    get: {
      req: {
        conversationId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/memberships/{userId}": {
    patch: {
      req: {
        conversationId: string;
        requestBody: {
          accessLevel?: AccessLevel;
        };
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
    delete: {
      req: {
        conversationId: string;
        userId: string;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * Membership removed.
         */
        204: void;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
  "/v1/user/search/entries": {
    post: {
      req: {
        requestBody: SearchEntriesRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
      };
    };
  };
  "/v1/conversations/{conversationId}/summaries": {
    post: {
      req: {
        conversationId: string;
        requestBody: CreateSummaryRequest;
      };
      res: {
        /**
         * Error response
         */
        200: ErrorResponse;
        /**
         * The created summary entry.
         */
        201: Entry;
        /**
         * Resource not found
         */
        404: ErrorResponse;
      };
    };
  };
};

package io.github.chirino.memoryservice.docstest;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

/**
 * Generates Cucumber feature files from JSON test data generated by Astro build.
 * Much simpler - no MDX parsing needed!
 */
public class TestGenerator {

    public void generateFeatureFile(
            List<TestScenarioLoader.TestScenarioData> scenarios, Path outputFeatureFile)
            throws IOException {

        if (scenarios.isEmpty()) {
            return;
        }

        StringBuilder feature = new StringBuilder();

        // Feature header - derive from first scenario's source file
        String featureName = deriveFeatureName(scenarios.get(0).sourceFile);
        feature.append("# Generated from test-scenarios.json (built from MDX)\n");
        feature.append("# DO NOT EDIT: This file is auto-generated\n");
        feature.append("Feature: ").append(featureName).append("\n\n");

        // Background
        feature.append("  Background:\n");
        feature.append("    Given the memory-service is running via docker compose\n");
        feature.append("    And I set up authentication tokens\n\n");

        // Generate scenario for each test scenario - use unique port for each
        int scenarioNum = 1;
        int portNum =
                10090; // Start from port 10090 (avoids conflicts with docker compose services)
        for (TestScenarioLoader.TestScenarioData scenario : scenarios) {
            generateScenario(feature, scenario, scenarioNum++, portNum++);
        }

        // Write to file
        Files.createDirectories(outputFeatureFile.getParent());
        Files.writeString(outputFeatureFile, feature.toString());

        System.out.println("Generated: " + outputFeatureFile);
    }

    private void generateScenario(
            StringBuilder feature,
            TestScenarioLoader.TestScenarioData scenario,
            int scenarioNum,
            int port) {
        // Scenario header
        String checkpointName =
                scenario.checkpoint.substring(scenario.checkpoint.lastIndexOf('/') + 1);
        feature.append("  Scenario: Test ").append(checkpointName).append("\n");
        feature.append("    # From ").append(scenario.sourceFile).append("\n");

        // Set up checkpoint
        feature.append("    Given I have checkpoint \"").append(scenario.checkpoint).append("\"\n");

        // Build and start
        feature.append("    When I build the checkpoint\n");
        feature.append("    Then the build should succeed\n\n");
        feature.append("    When I start the checkpoint on port ").append(port).append("\n");
        feature.append("    Then the application should be running\n\n");

        // Execute each command (only blocks containing curl commands)
        for (TestScenarioLoader.ScenarioCommand command : scenario.scenarios) {
            if (containsCurlCommand(command.bash)) {
                generateCommand(feature, command, port);
            }
        }

        // Stop checkpoint
        feature.append("    When I stop the checkpoint\n\n");
    }

    private void generateCommand(
            StringBuilder feature, TestScenarioLoader.ScenarioCommand command, int port) {
        // Execute bash command with port replacement
        feature.append("    When I execute curl command:\n");
        feature.append("      \"\"\"\n");

        // Replace localhost:9090 with the actual port for this scenario
        String bashCommand = command.bash.replaceAll("localhost:9090", "localhost:" + port);

        for (String line : bashCommand.split("\n")) {
            feature.append("      ").append(line.trim()).append("\n");
        }

        feature.append("      \"\"\"\n");

        // Add simple expectations (from **Expected**: lines)
        for (TestScenarioLoader.Expectation expectation : command.expectations) {
            switch (expectation.type) {
                case "contains":
                    feature.append("    Then the response should contain \"")
                            .append(escapeQuotes(expectation.value))
                            .append("\"\n");
                    break;

                case "not_contains":
                    feature.append("    Then the response should not contain \"")
                            .append(escapeQuotes(expectation.value))
                            .append("\"\n");
                    break;

                case "status_code":
                    feature.append("    Then the response status should be ")
                            .append(expectation.value)
                            .append("\n");
                    break;
            }
        }

        // Add custom steps (from <Steps> block)
        if (command.customSteps != null && !command.customSteps.isEmpty()) {
            for (String step : command.customSteps) {
                // Custom steps are already properly formatted Cucumber steps
                // Just need to add proper indentation
                if (step.trim().isEmpty()) {
                    continue;
                }

                // Handle multi-line steps (like JSON fixtures with """)
                if (step.contains("\"\"\"")) {
                    // This is a doc string - output as-is with indentation
                    feature.append("    ").append(step).append("\n");
                } else if (!step.startsWith("And")
                        && !step.startsWith("Then")
                        && !step.startsWith("Given")
                        && !step.startsWith("When")) {
                    // This is a continuation line (like JSON content)
                    feature.append("    ").append(step).append("\n");
                } else {
                    // This is a Cucumber step
                    feature.append("    ").append(step).append("\n");
                }
            }
        }

        feature.append("\n");
    }

    private String deriveFeatureName(String sourceFile) {
        // Extract filename from path like "/docs/spring/getting-started/" or
        // "/docs/spring/getting-started"
        // Remove trailing slash if present
        String cleanPath =
                sourceFile.endsWith("/")
                        ? sourceFile.substring(0, sourceFile.length() - 1)
                        : sourceFile;
        String filename = cleanPath.substring(cleanPath.lastIndexOf('/') + 1);

        // Convert kebab-case to Title Case
        String[] parts = filename.split("-");
        StringBuilder name = new StringBuilder();

        for (String part : parts) {
            if (part.isEmpty()) continue; // Skip empty parts
            if (name.length() > 0) name.append(" ");
            name.append(Character.toUpperCase(part.charAt(0))).append(part.substring(1));
        }

        return name.toString() + " Tutorial";
    }

    /**
     * Checks if a bash block contains a curl command (at start of line or start of block).
     * Blocks that are pure comments, variable assignments, or non-curl commands are skipped.
     */
    private boolean containsCurlCommand(String bash) {
        String trimmed = bash.trim();
        if (trimmed.startsWith("curl")) {
            return true;
        }
        // Check for curl at start of any line (after comments or variable assignments)
        for (String line : trimmed.split("\n")) {
            if (line.trim().startsWith("curl")) {
                return true;
            }
        }
        return false;
    }

    private String escapeQuotes(String text) {
        return text.replace("\"", "\\\"");
    }
}

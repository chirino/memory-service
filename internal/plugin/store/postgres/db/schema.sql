-- Liquibase-managed PostgreSQL schema for Memory Service
-- Copied from the top-level schema.sql specification.

-- PostgreSQL schema for Memory Service
-- UUID values are generated by the application; the database does not rely
-- on the uuid-ossp extension. If pgvector is used, enable it separately
-- where appropriate (e.g., via migrations or deployment scripts).
-- Example (optional): CREATE EXTENSION IF NOT EXISTS vector;

-- Conversations & ownership
-------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_groups (
    id              UUID PRIMARY KEY,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS conversations (
    id              UUID PRIMARY KEY,
    title           BYTEA,
    -- External user identifier (e.g., OAuth subject); no local users table.
    owner_user_id   TEXT NOT NULL,
    metadata        JSONB NOT NULL DEFAULT '{}'::JSONB,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    forked_at_entry_id UUID,
    forked_at_conversation_id UUID REFERENCES conversations (id) ON DELETE CASCADE,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    vectorized_at   TIMESTAMPTZ,
    deleted_at      TIMESTAMPTZ
);

-- Per-user access to conversations.
-- Exactly one row per conversation with access_level = 'owner'.
-- Memberships are hard-deleted (not soft-deleted) with audit logging.
CREATE TABLE IF NOT EXISTS conversation_memberships (
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifier (e.g., OAuth subject); no local users table.
    user_id           TEXT NOT NULL,
    access_level      TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (conversation_group_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_user
    ON conversation_memberships (user_id, conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversation_memberships_group
    ON conversation_memberships (conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversation_groups_not_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_conversations_not_deleted
    ON conversations (deleted_at) WHERE deleted_at IS NULL;

-- Index for eviction queries (deleted records past retention)
CREATE INDEX IF NOT EXISTS idx_conversation_groups_deleted
    ON conversation_groups (deleted_at) WHERE deleted_at IS NOT NULL;

------------------------------------------------------------
-- Entries & summaries
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS entries (
    id                UUID NOT NULL,
    conversation_id   UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
    conversation_group_id UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    user_id           TEXT,
    client_id         TEXT,
    channel           TEXT NOT NULL,
    epoch             BIGINT,
    content_type      TEXT NOT NULL,
    content           BYTEA NOT NULL,
    indexed_content   TEXT,
    indexed_at        TIMESTAMPTZ,
    indexed_content_tsv tsvector GENERATED ALWAYS AS (to_tsvector('english', COALESCE(indexed_content, ''))) STORED,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (id, conversation_group_id)
) PARTITION BY HASH (conversation_group_id);

CREATE TABLE IF NOT EXISTS entries_p0  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 0);
CREATE TABLE IF NOT EXISTS entries_p1  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 1);
CREATE TABLE IF NOT EXISTS entries_p2  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 2);
CREATE TABLE IF NOT EXISTS entries_p3  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 3);
CREATE TABLE IF NOT EXISTS entries_p4  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 4);
CREATE TABLE IF NOT EXISTS entries_p5  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 5);
CREATE TABLE IF NOT EXISTS entries_p6  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 6);
CREATE TABLE IF NOT EXISTS entries_p7  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 7);
CREATE TABLE IF NOT EXISTS entries_p8  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 8);
CREATE TABLE IF NOT EXISTS entries_p9  PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 9);
CREATE TABLE IF NOT EXISTS entries_p10 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 10);
CREATE TABLE IF NOT EXISTS entries_p11 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 11);
CREATE TABLE IF NOT EXISTS entries_p12 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 12);
CREATE TABLE IF NOT EXISTS entries_p13 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 13);
CREATE TABLE IF NOT EXISTS entries_p14 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 14);
CREATE TABLE IF NOT EXISTS entries_p15 PARTITION OF entries FOR VALUES WITH (MODULUS 16, REMAINDER 15);

-- Index for finding unindexed history entries (batch indexing job)
CREATE INDEX IF NOT EXISTS idx_entries_unindexed
    ON entries (channel, created_at)
    WHERE indexed_content IS NULL;

-- Index for finding entries pending vector store indexing (retry task)
CREATE INDEX IF NOT EXISTS idx_entries_pending_vector_indexing
    ON entries (indexed_at)
    WHERE indexed_content IS NOT NULL AND indexed_at IS NULL;

-- GIN index for fast full-text search
CREATE INDEX IF NOT EXISTS idx_entries_indexed_content_fts
    ON entries USING GIN (indexed_content_tsv);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_created_at
    ON entries (conversation_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_group_created_at
    ON entries (conversation_group_id, created_at);

CREATE INDEX IF NOT EXISTS idx_entries_conversation_channel_client_epoch_created_at
    ON entries (conversation_id, channel, client_id, epoch, created_at);

CREATE INDEX IF NOT EXISTS idx_conversations_group
    ON conversations (conversation_group_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_conversation
    ON conversations (forked_at_conversation_id);

CREATE INDEX IF NOT EXISTS idx_conversations_forked_at_entry
    ON conversations (forked_at_entry_id);

------------------------------------------------------------
-- Semantic search (pgvector-backed, optional)
------------------------------------------------------------

-- If pgvector is enabled, uncomment the extension above and this table.
-- Embeddings are associated with individual entries.
-- CREATE TABLE IF NOT EXISTS entry_embeddings (
--     entry_id         UUID PRIMARY KEY REFERENCES entries (id) ON DELETE CASCADE,
--     conversation_id  UUID NOT NULL REFERENCES conversations (id) ON DELETE CASCADE,
--     -- Adjust dimension to match the configured embedding model.
--     embedding        vector(768) NOT NULL,
--     created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW()
-- );
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_conversation
--     ON entry_embeddings (conversation_id);
--
-- CREATE INDEX IF NOT EXISTS idx_entry_embeddings_embedding
--     ON entry_embeddings
--     USING ivfflat (embedding vector_cosine_ops)
--     WITH (lists = 100);

------------------------------------------------------------
-- Ownership transfer tracking
-- Transfers are always "pending" while they exist; accepted/rejected transfers are hard deleted.
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS conversation_ownership_transfers (
    id                UUID PRIMARY KEY,
    conversation_group_id   UUID NOT NULL REFERENCES conversation_groups (id) ON DELETE CASCADE,
    -- External user identifiers (e.g., OAuth subjects).
    from_user_id      TEXT NOT NULL,
    to_user_id        TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- Only one pending transfer per conversation (transfer is deleted when accepted/rejected)
    CONSTRAINT unique_transfer_per_conversation UNIQUE (conversation_group_id),
    CONSTRAINT different_users CHECK (from_user_id != to_user_id)
);

-- Index for listing user's transfers as recipient
CREATE INDEX IF NOT EXISTS idx_ownership_transfers_to_user
    ON conversation_ownership_transfers (to_user_id);

-- Index for listing user's transfers as sender
CREATE INDEX IF NOT EXISTS idx_ownership_transfers_from_user
    ON conversation_ownership_transfers (from_user_id);

------------------------------------------------------------
-- Background task queue
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS tasks (
    id              UUID PRIMARY KEY,
    task_name       TEXT UNIQUE,
    task_type       TEXT NOT NULL,
    task_body       JSONB NOT NULL,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    retry_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_error      TEXT,
    retry_count     INT NOT NULL DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_tasks_ready
    ON tasks (task_type, retry_at);

-- Unique partial index for singleton tasks (allows multiple NULL task_name values)
CREATE UNIQUE INDEX IF NOT EXISTS idx_tasks_name
    ON tasks (task_name) WHERE task_name IS NOT NULL;

------------------------------------------------------------
-- Attachments
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS attachments (
    id              UUID PRIMARY KEY,
    storage_key     VARCHAR(255),
    filename        VARCHAR(255),
    content_type    VARCHAR(127) NOT NULL,
    size            BIGINT,
    sha256          VARCHAR(64),
    user_id         TEXT NOT NULL,
    entry_id        UUID,
    status          VARCHAR(20) NOT NULL DEFAULT 'ready',
    source_url      VARCHAR(2048),
    expires_at      TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_attachments_expires_at
    ON attachments(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_entry_id
    ON attachments(entry_id) WHERE entry_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_storage_key
    ON attachments(storage_key) WHERE storage_key IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_deleted_at
    ON attachments(deleted_at) WHERE deleted_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_attachments_status
    ON attachments(status) WHERE status != 'ready';
CREATE INDEX IF NOT EXISTS idx_attachments_user_id
    ON attachments(user_id);
CREATE INDEX IF NOT EXISTS idx_attachments_created_at_id
    ON attachments(created_at DESC, id DESC);

------------------------------------------------------------
-- Encryption DEK table (vault and kms providers)
-- One row per provider; wrapped_deks[1] is the primary (newest),
-- subsequent elements are legacy (decryption-only key rotation).
-- revision enables optimistic updates (key rotation).
------------------------------------------------------------

CREATE TABLE IF NOT EXISTS encryption_deks (
    provider     TEXT    NOT NULL PRIMARY KEY,   -- "vault" or "kms"
    wrapped_deks BYTEA[] NOT NULL,               -- wrapped by Vault Transit / KMS Encrypt
    revision     BIGINT  NOT NULL DEFAULT 0
);

------------------------------------------------------------
-- Namespaced Episodic Memory
-- Each row is a write event for a (namespace, key).
-- The active value of a key is the single row where deleted_at IS NULL.
-- On update: a new row is inserted; the previous active row is soft-deleted
--            with deleted_at set to the same timestamp (same txn).
-- On delete: the active row is soft-deleted with deleted_at = NOW(); no new row.
-- When a row is soft-deleted its indexed_at is reset to NULL so the background
-- indexer removes it from the vector store on its next cycle.
------------------------------------------------------------

-- kind values (SMALLINT): 0=add (first write), 1=update (subsequent write)
-- deleted_reason values (SMALLINT):
--   0 = updated  — superseded by a newer write; hard-deleted on eviction
--   1 = deleted  — explicit DELETE; tombstoned on eviction (data cleared, row kept for event history)
--   2 = expired  — TTL elapsed;    tombstoned on eviction (data cleared, row kept for event history)
CREATE TABLE IF NOT EXISTS memories (
    id                UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
    namespace         TEXT        NOT NULL,   -- RS-encoded: "users\x1ealice\x1ememories"
    key               TEXT        NOT NULL,
    value_encrypted   BYTEA,                  -- AES-256-GCM encrypted JSON value; NULL for tombstones
    attributes        BYTEA,                  -- AES-256-GCM encrypted user-supplied attributes; NULL for tombstones
    policy_attributes JSONB,                  -- plaintext OPA-extracted attributes for filtering
    index_fields      JSONB,                  -- optional explicit value field names to embed
    index_disabled    BOOLEAN     NOT NULL DEFAULT FALSE,
    kind              SMALLINT    NOT NULL DEFAULT 0,  -- 0=add, 1=update — set at write time, never changed
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at        TIMESTAMPTZ,            -- NULL = no TTL
    deleted_at        TIMESTAMPTZ,            -- NULL = active; non-NULL = superseded or deleted
    deleted_reason    SMALLINT,               -- NULL=active, 0=updated, 1=deleted, 2=expired
    indexed_at        TIMESTAMPTZ             -- NULL = pending vector index sync
);

-- History / audit queries: all versions of a key, ordered by creation
CREATE INDEX IF NOT EXISTS memories_namespace_key_idx
    ON memories (namespace, key, created_at DESC);

-- Active-record point lookups (GET, search)
CREATE INDEX IF NOT EXISTS memories_active_idx
    ON memories (namespace, key) WHERE deleted_at IS NULL;

-- TTL expiry cleanup
CREATE INDEX IF NOT EXISTS memories_expires_idx
    ON memories (expires_at) WHERE expires_at IS NOT NULL;

-- Background vector indexer queue (pending sync)
CREATE INDEX IF NOT EXISTS memories_indexed_at_idx
    ON memories (indexed_at) WHERE indexed_at IS NULL;

-- Attribute-based pre-filtering
CREATE INDEX IF NOT EXISTS memories_policy_attrs_gin_idx
    ON memories USING GIN (policy_attributes) WHERE policy_attributes IS NOT NULL;

-- Event timeline queries
CREATE INDEX IF NOT EXISTS memories_write_events_idx
    ON memories (namespace, created_at, id) WHERE kind IN (0, 1);
CREATE INDEX IF NOT EXISTS memories_delete_events_idx
    ON memories (namespace, deleted_at, id) WHERE deleted_reason IN (1, 2);

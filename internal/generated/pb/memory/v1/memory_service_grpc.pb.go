// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v7.34.0
// source: memory/v1/memory_service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SystemService_GetHealth_FullMethodName = "/memory.v1.SystemService/GetHealth"
)

// SystemServiceClient is the client API for SystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemServiceClient interface {
	GetHealth(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error)
}

type systemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemServiceClient(cc grpc.ClientConnInterface) SystemServiceClient {
	return &systemServiceClient{cc}
}

func (c *systemServiceClient) GetHealth(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, SystemService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemServiceServer is the server API for SystemService service.
// All implementations must embed UnimplementedSystemServiceServer
// for forward compatibility.
type SystemServiceServer interface {
	GetHealth(context.Context, *emptypb.Empty) (*HealthResponse, error)
	mustEmbedUnimplementedSystemServiceServer()
}

// UnimplementedSystemServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSystemServiceServer struct{}

func (UnimplementedSystemServiceServer) GetHealth(context.Context, *emptypb.Empty) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedSystemServiceServer) mustEmbedUnimplementedSystemServiceServer() {}
func (UnimplementedSystemServiceServer) testEmbeddedByValue()                       {}

// UnsafeSystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemServiceServer will
// result in compilation errors.
type UnsafeSystemServiceServer interface {
	mustEmbedUnimplementedSystemServiceServer()
}

func RegisterSystemServiceServer(s grpc.ServiceRegistrar, srv SystemServiceServer) {
	// If the following call panics, it indicates UnimplementedSystemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SystemService_ServiceDesc, srv)
}

func _SystemService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).GetHealth(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemService_ServiceDesc is the grpc.ServiceDesc for SystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.SystemService",
	HandlerType: (*SystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHealth",
			Handler:    _SystemService_GetHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	ConversationsService_ListConversations_FullMethodName  = "/memory.v1.ConversationsService/ListConversations"
	ConversationsService_CreateConversation_FullMethodName = "/memory.v1.ConversationsService/CreateConversation"
	ConversationsService_GetConversation_FullMethodName    = "/memory.v1.ConversationsService/GetConversation"
	ConversationsService_UpdateConversation_FullMethodName = "/memory.v1.ConversationsService/UpdateConversation"
	ConversationsService_DeleteConversation_FullMethodName = "/memory.v1.ConversationsService/DeleteConversation"
	ConversationsService_ListForks_FullMethodName          = "/memory.v1.ConversationsService/ListForks"
)

// ConversationsServiceClient is the client API for ConversationsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConversationsServiceClient interface {
	// ListConversations returns conversations the user has access to.
	// The mode parameter controls which conversations from each fork tree are returned.
	// See ConversationListMode for available modes.
	ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error)
	CreateConversation(ctx context.Context, in *CreateConversationRequest, opts ...grpc.CallOption) (*Conversation, error)
	GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*Conversation, error)
	UpdateConversation(ctx context.Context, in *UpdateConversationRequest, opts ...grpc.CallOption) (*Conversation, error)
	// DeleteConversation deletes a conversation. Deleting a conversation deletes all conversations in the same fork tree (the root conversation and all its forks). Memberships and entries associated with these conversations are also deleted.
	DeleteConversation(ctx context.Context, in *DeleteConversationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListForks(ctx context.Context, in *ListForksRequest, opts ...grpc.CallOption) (*ListForksResponse, error)
}

type conversationsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConversationsServiceClient(cc grpc.ClientConnInterface) ConversationsServiceClient {
	return &conversationsServiceClient{cc}
}

func (c *conversationsServiceClient) ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConversationsResponse)
	err := c.cc.Invoke(ctx, ConversationsService_ListConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) CreateConversation(ctx context.Context, in *CreateConversationRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationsService_CreateConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationsService_GetConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) UpdateConversation(ctx context.Context, in *UpdateConversationRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationsService_UpdateConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) DeleteConversation(ctx context.Context, in *DeleteConversationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConversationsService_DeleteConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) ListForks(ctx context.Context, in *ListForksRequest, opts ...grpc.CallOption) (*ListForksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListForksResponse)
	err := c.cc.Invoke(ctx, ConversationsService_ListForks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationsServiceServer is the server API for ConversationsService service.
// All implementations must embed UnimplementedConversationsServiceServer
// for forward compatibility.
type ConversationsServiceServer interface {
	// ListConversations returns conversations the user has access to.
	// The mode parameter controls which conversations from each fork tree are returned.
	// See ConversationListMode for available modes.
	ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error)
	CreateConversation(context.Context, *CreateConversationRequest) (*Conversation, error)
	GetConversation(context.Context, *GetConversationRequest) (*Conversation, error)
	UpdateConversation(context.Context, *UpdateConversationRequest) (*Conversation, error)
	// DeleteConversation deletes a conversation. Deleting a conversation deletes all conversations in the same fork tree (the root conversation and all its forks). Memberships and entries associated with these conversations are also deleted.
	DeleteConversation(context.Context, *DeleteConversationRequest) (*emptypb.Empty, error)
	ListForks(context.Context, *ListForksRequest) (*ListForksResponse, error)
	mustEmbedUnimplementedConversationsServiceServer()
}

// UnimplementedConversationsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConversationsServiceServer struct{}

func (UnimplementedConversationsServiceServer) ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListConversations not implemented")
}
func (UnimplementedConversationsServiceServer) CreateConversation(context.Context, *CreateConversationRequest) (*Conversation, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateConversation not implemented")
}
func (UnimplementedConversationsServiceServer) GetConversation(context.Context, *GetConversationRequest) (*Conversation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConversation not implemented")
}
func (UnimplementedConversationsServiceServer) UpdateConversation(context.Context, *UpdateConversationRequest) (*Conversation, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateConversation not implemented")
}
func (UnimplementedConversationsServiceServer) DeleteConversation(context.Context, *DeleteConversationRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteConversation not implemented")
}
func (UnimplementedConversationsServiceServer) ListForks(context.Context, *ListForksRequest) (*ListForksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListForks not implemented")
}
func (UnimplementedConversationsServiceServer) mustEmbedUnimplementedConversationsServiceServer() {}
func (UnimplementedConversationsServiceServer) testEmbeddedByValue()                              {}

// UnsafeConversationsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConversationsServiceServer will
// result in compilation errors.
type UnsafeConversationsServiceServer interface {
	mustEmbedUnimplementedConversationsServiceServer()
}

func RegisterConversationsServiceServer(s grpc.ServiceRegistrar, srv ConversationsServiceServer) {
	// If the following call panics, it indicates UnimplementedConversationsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConversationsService_ServiceDesc, srv)
}

func _ConversationsService_ListConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).ListConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_ListConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).ListConversations(ctx, req.(*ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_CreateConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).CreateConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_CreateConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).CreateConversation(ctx, req.(*CreateConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_GetConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).GetConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_GetConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).GetConversation(ctx, req.(*GetConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_UpdateConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).UpdateConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_UpdateConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).UpdateConversation(ctx, req.(*UpdateConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_DeleteConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).DeleteConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_DeleteConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).DeleteConversation(ctx, req.(*DeleteConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_ListForks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListForksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).ListForks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_ListForks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).ListForks(ctx, req.(*ListForksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConversationsService_ServiceDesc is the grpc.ServiceDesc for ConversationsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConversationsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.ConversationsService",
	HandlerType: (*ConversationsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListConversations",
			Handler:    _ConversationsService_ListConversations_Handler,
		},
		{
			MethodName: "CreateConversation",
			Handler:    _ConversationsService_CreateConversation_Handler,
		},
		{
			MethodName: "GetConversation",
			Handler:    _ConversationsService_GetConversation_Handler,
		},
		{
			MethodName: "UpdateConversation",
			Handler:    _ConversationsService_UpdateConversation_Handler,
		},
		{
			MethodName: "DeleteConversation",
			Handler:    _ConversationsService_DeleteConversation_Handler,
		},
		{
			MethodName: "ListForks",
			Handler:    _ConversationsService_ListForks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	ConversationMembershipsService_ListMemberships_FullMethodName   = "/memory.v1.ConversationMembershipsService/ListMemberships"
	ConversationMembershipsService_ShareConversation_FullMethodName = "/memory.v1.ConversationMembershipsService/ShareConversation"
	ConversationMembershipsService_UpdateMembership_FullMethodName  = "/memory.v1.ConversationMembershipsService/UpdateMembership"
	ConversationMembershipsService_DeleteMembership_FullMethodName  = "/memory.v1.ConversationMembershipsService/DeleteMembership"
)

// ConversationMembershipsServiceClient is the client API for ConversationMembershipsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConversationMembershipsServiceClient interface {
	ListMemberships(ctx context.Context, in *ListMembershipsRequest, opts ...grpc.CallOption) (*ListMembershipsResponse, error)
	ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ConversationMembership, error)
	UpdateMembership(ctx context.Context, in *UpdateMembershipRequest, opts ...grpc.CallOption) (*ConversationMembership, error)
	DeleteMembership(ctx context.Context, in *DeleteMembershipRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type conversationMembershipsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConversationMembershipsServiceClient(cc grpc.ClientConnInterface) ConversationMembershipsServiceClient {
	return &conversationMembershipsServiceClient{cc}
}

func (c *conversationMembershipsServiceClient) ListMemberships(ctx context.Context, in *ListMembershipsRequest, opts ...grpc.CallOption) (*ListMembershipsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMembershipsResponse)
	err := c.cc.Invoke(ctx, ConversationMembershipsService_ListMemberships_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMembershipsServiceClient) ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ConversationMembership, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationMembership)
	err := c.cc.Invoke(ctx, ConversationMembershipsService_ShareConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMembershipsServiceClient) UpdateMembership(ctx context.Context, in *UpdateMembershipRequest, opts ...grpc.CallOption) (*ConversationMembership, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationMembership)
	err := c.cc.Invoke(ctx, ConversationMembershipsService_UpdateMembership_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMembershipsServiceClient) DeleteMembership(ctx context.Context, in *DeleteMembershipRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConversationMembershipsService_DeleteMembership_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationMembershipsServiceServer is the server API for ConversationMembershipsService service.
// All implementations must embed UnimplementedConversationMembershipsServiceServer
// for forward compatibility.
type ConversationMembershipsServiceServer interface {
	ListMemberships(context.Context, *ListMembershipsRequest) (*ListMembershipsResponse, error)
	ShareConversation(context.Context, *ShareConversationRequest) (*ConversationMembership, error)
	UpdateMembership(context.Context, *UpdateMembershipRequest) (*ConversationMembership, error)
	DeleteMembership(context.Context, *DeleteMembershipRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedConversationMembershipsServiceServer()
}

// UnimplementedConversationMembershipsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConversationMembershipsServiceServer struct{}

func (UnimplementedConversationMembershipsServiceServer) ListMemberships(context.Context, *ListMembershipsRequest) (*ListMembershipsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMemberships not implemented")
}
func (UnimplementedConversationMembershipsServiceServer) ShareConversation(context.Context, *ShareConversationRequest) (*ConversationMembership, error) {
	return nil, status.Error(codes.Unimplemented, "method ShareConversation not implemented")
}
func (UnimplementedConversationMembershipsServiceServer) UpdateMembership(context.Context, *UpdateMembershipRequest) (*ConversationMembership, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMembership not implemented")
}
func (UnimplementedConversationMembershipsServiceServer) DeleteMembership(context.Context, *DeleteMembershipRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMembership not implemented")
}
func (UnimplementedConversationMembershipsServiceServer) mustEmbedUnimplementedConversationMembershipsServiceServer() {
}
func (UnimplementedConversationMembershipsServiceServer) testEmbeddedByValue() {}

// UnsafeConversationMembershipsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConversationMembershipsServiceServer will
// result in compilation errors.
type UnsafeConversationMembershipsServiceServer interface {
	mustEmbedUnimplementedConversationMembershipsServiceServer()
}

func RegisterConversationMembershipsServiceServer(s grpc.ServiceRegistrar, srv ConversationMembershipsServiceServer) {
	// If the following call panics, it indicates UnimplementedConversationMembershipsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConversationMembershipsService_ServiceDesc, srv)
}

func _ConversationMembershipsService_ListMemberships_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMembershipsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMembershipsServiceServer).ListMemberships(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMembershipsService_ListMemberships_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMembershipsServiceServer).ListMemberships(ctx, req.(*ListMembershipsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMembershipsService_ShareConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMembershipsServiceServer).ShareConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMembershipsService_ShareConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMembershipsServiceServer).ShareConversation(ctx, req.(*ShareConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMembershipsService_UpdateMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMembershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMembershipsServiceServer).UpdateMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMembershipsService_UpdateMembership_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMembershipsServiceServer).UpdateMembership(ctx, req.(*UpdateMembershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMembershipsService_DeleteMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMembershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMembershipsServiceServer).DeleteMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMembershipsService_DeleteMembership_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMembershipsServiceServer).DeleteMembership(ctx, req.(*DeleteMembershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConversationMembershipsService_ServiceDesc is the grpc.ServiceDesc for ConversationMembershipsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConversationMembershipsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.ConversationMembershipsService",
	HandlerType: (*ConversationMembershipsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMemberships",
			Handler:    _ConversationMembershipsService_ListMemberships_Handler,
		},
		{
			MethodName: "ShareConversation",
			Handler:    _ConversationMembershipsService_ShareConversation_Handler,
		},
		{
			MethodName: "UpdateMembership",
			Handler:    _ConversationMembershipsService_UpdateMembership_Handler,
		},
		{
			MethodName: "DeleteMembership",
			Handler:    _ConversationMembershipsService_DeleteMembership_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	OwnershipTransfersService_ListOwnershipTransfers_FullMethodName  = "/memory.v1.OwnershipTransfersService/ListOwnershipTransfers"
	OwnershipTransfersService_GetOwnershipTransfer_FullMethodName    = "/memory.v1.OwnershipTransfersService/GetOwnershipTransfer"
	OwnershipTransfersService_CreateOwnershipTransfer_FullMethodName = "/memory.v1.OwnershipTransfersService/CreateOwnershipTransfer"
	OwnershipTransfersService_AcceptOwnershipTransfer_FullMethodName = "/memory.v1.OwnershipTransfersService/AcceptOwnershipTransfer"
	OwnershipTransfersService_DeleteOwnershipTransfer_FullMethodName = "/memory.v1.OwnershipTransfersService/DeleteOwnershipTransfer"
)

// OwnershipTransfersServiceClient is the client API for OwnershipTransfersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OwnershipTransfersServiceClient interface {
	// List pending ownership transfers for the current user
	ListOwnershipTransfers(ctx context.Context, in *ListOwnershipTransfersRequest, opts ...grpc.CallOption) (*ListOwnershipTransfersResponse, error)
	// Get a specific ownership transfer
	GetOwnershipTransfer(ctx context.Context, in *GetOwnershipTransferRequest, opts ...grpc.CallOption) (*OwnershipTransfer, error)
	// Create a new ownership transfer (initiates transfer to another user)
	CreateOwnershipTransfer(ctx context.Context, in *CreateOwnershipTransferRequest, opts ...grpc.CallOption) (*OwnershipTransfer, error)
	// Accept an ownership transfer (recipient becomes owner, sender becomes manager)
	AcceptOwnershipTransfer(ctx context.Context, in *AcceptOwnershipTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete/cancel an ownership transfer
	DeleteOwnershipTransfer(ctx context.Context, in *DeleteOwnershipTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type ownershipTransfersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOwnershipTransfersServiceClient(cc grpc.ClientConnInterface) OwnershipTransfersServiceClient {
	return &ownershipTransfersServiceClient{cc}
}

func (c *ownershipTransfersServiceClient) ListOwnershipTransfers(ctx context.Context, in *ListOwnershipTransfersRequest, opts ...grpc.CallOption) (*ListOwnershipTransfersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOwnershipTransfersResponse)
	err := c.cc.Invoke(ctx, OwnershipTransfersService_ListOwnershipTransfers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownershipTransfersServiceClient) GetOwnershipTransfer(ctx context.Context, in *GetOwnershipTransferRequest, opts ...grpc.CallOption) (*OwnershipTransfer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OwnershipTransfer)
	err := c.cc.Invoke(ctx, OwnershipTransfersService_GetOwnershipTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownershipTransfersServiceClient) CreateOwnershipTransfer(ctx context.Context, in *CreateOwnershipTransferRequest, opts ...grpc.CallOption) (*OwnershipTransfer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OwnershipTransfer)
	err := c.cc.Invoke(ctx, OwnershipTransfersService_CreateOwnershipTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownershipTransfersServiceClient) AcceptOwnershipTransfer(ctx context.Context, in *AcceptOwnershipTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OwnershipTransfersService_AcceptOwnershipTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownershipTransfersServiceClient) DeleteOwnershipTransfer(ctx context.Context, in *DeleteOwnershipTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OwnershipTransfersService_DeleteOwnershipTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OwnershipTransfersServiceServer is the server API for OwnershipTransfersService service.
// All implementations must embed UnimplementedOwnershipTransfersServiceServer
// for forward compatibility.
type OwnershipTransfersServiceServer interface {
	// List pending ownership transfers for the current user
	ListOwnershipTransfers(context.Context, *ListOwnershipTransfersRequest) (*ListOwnershipTransfersResponse, error)
	// Get a specific ownership transfer
	GetOwnershipTransfer(context.Context, *GetOwnershipTransferRequest) (*OwnershipTransfer, error)
	// Create a new ownership transfer (initiates transfer to another user)
	CreateOwnershipTransfer(context.Context, *CreateOwnershipTransferRequest) (*OwnershipTransfer, error)
	// Accept an ownership transfer (recipient becomes owner, sender becomes manager)
	AcceptOwnershipTransfer(context.Context, *AcceptOwnershipTransferRequest) (*emptypb.Empty, error)
	// Delete/cancel an ownership transfer
	DeleteOwnershipTransfer(context.Context, *DeleteOwnershipTransferRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedOwnershipTransfersServiceServer()
}

// UnimplementedOwnershipTransfersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOwnershipTransfersServiceServer struct{}

func (UnimplementedOwnershipTransfersServiceServer) ListOwnershipTransfers(context.Context, *ListOwnershipTransfersRequest) (*ListOwnershipTransfersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOwnershipTransfers not implemented")
}
func (UnimplementedOwnershipTransfersServiceServer) GetOwnershipTransfer(context.Context, *GetOwnershipTransferRequest) (*OwnershipTransfer, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOwnershipTransfer not implemented")
}
func (UnimplementedOwnershipTransfersServiceServer) CreateOwnershipTransfer(context.Context, *CreateOwnershipTransferRequest) (*OwnershipTransfer, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOwnershipTransfer not implemented")
}
func (UnimplementedOwnershipTransfersServiceServer) AcceptOwnershipTransfer(context.Context, *AcceptOwnershipTransferRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptOwnershipTransfer not implemented")
}
func (UnimplementedOwnershipTransfersServiceServer) DeleteOwnershipTransfer(context.Context, *DeleteOwnershipTransferRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteOwnershipTransfer not implemented")
}
func (UnimplementedOwnershipTransfersServiceServer) mustEmbedUnimplementedOwnershipTransfersServiceServer() {
}
func (UnimplementedOwnershipTransfersServiceServer) testEmbeddedByValue() {}

// UnsafeOwnershipTransfersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OwnershipTransfersServiceServer will
// result in compilation errors.
type UnsafeOwnershipTransfersServiceServer interface {
	mustEmbedUnimplementedOwnershipTransfersServiceServer()
}

func RegisterOwnershipTransfersServiceServer(s grpc.ServiceRegistrar, srv OwnershipTransfersServiceServer) {
	// If the following call panics, it indicates UnimplementedOwnershipTransfersServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OwnershipTransfersService_ServiceDesc, srv)
}

func _OwnershipTransfersService_ListOwnershipTransfers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOwnershipTransfersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnershipTransfersServiceServer).ListOwnershipTransfers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnershipTransfersService_ListOwnershipTransfers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnershipTransfersServiceServer).ListOwnershipTransfers(ctx, req.(*ListOwnershipTransfersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnershipTransfersService_GetOwnershipTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOwnershipTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnershipTransfersServiceServer).GetOwnershipTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnershipTransfersService_GetOwnershipTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnershipTransfersServiceServer).GetOwnershipTransfer(ctx, req.(*GetOwnershipTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnershipTransfersService_CreateOwnershipTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOwnershipTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnershipTransfersServiceServer).CreateOwnershipTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnershipTransfersService_CreateOwnershipTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnershipTransfersServiceServer).CreateOwnershipTransfer(ctx, req.(*CreateOwnershipTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnershipTransfersService_AcceptOwnershipTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptOwnershipTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnershipTransfersServiceServer).AcceptOwnershipTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnershipTransfersService_AcceptOwnershipTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnershipTransfersServiceServer).AcceptOwnershipTransfer(ctx, req.(*AcceptOwnershipTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnershipTransfersService_DeleteOwnershipTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOwnershipTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnershipTransfersServiceServer).DeleteOwnershipTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnershipTransfersService_DeleteOwnershipTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnershipTransfersServiceServer).DeleteOwnershipTransfer(ctx, req.(*DeleteOwnershipTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OwnershipTransfersService_ServiceDesc is the grpc.ServiceDesc for OwnershipTransfersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OwnershipTransfersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.OwnershipTransfersService",
	HandlerType: (*OwnershipTransfersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListOwnershipTransfers",
			Handler:    _OwnershipTransfersService_ListOwnershipTransfers_Handler,
		},
		{
			MethodName: "GetOwnershipTransfer",
			Handler:    _OwnershipTransfersService_GetOwnershipTransfer_Handler,
		},
		{
			MethodName: "CreateOwnershipTransfer",
			Handler:    _OwnershipTransfersService_CreateOwnershipTransfer_Handler,
		},
		{
			MethodName: "AcceptOwnershipTransfer",
			Handler:    _OwnershipTransfersService_AcceptOwnershipTransfer_Handler,
		},
		{
			MethodName: "DeleteOwnershipTransfer",
			Handler:    _OwnershipTransfersService_DeleteOwnershipTransfer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	EntriesService_ListEntries_FullMethodName = "/memory.v1.EntriesService/ListEntries"
	EntriesService_AppendEntry_FullMethodName = "/memory.v1.EntriesService/AppendEntry"
	EntriesService_SyncEntries_FullMethodName = "/memory.v1.EntriesService/SyncEntries"
)

// EntriesServiceClient is the client API for EntriesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EntriesServiceClient interface {
	ListEntries(ctx context.Context, in *ListEntriesRequest, opts ...grpc.CallOption) (*ListEntriesResponse, error)
	AppendEntry(ctx context.Context, in *AppendEntryRequest, opts ...grpc.CallOption) (*Entry, error)
	SyncEntries(ctx context.Context, in *SyncEntriesRequest, opts ...grpc.CallOption) (*SyncEntriesResponse, error)
}

type entriesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEntriesServiceClient(cc grpc.ClientConnInterface) EntriesServiceClient {
	return &entriesServiceClient{cc}
}

func (c *entriesServiceClient) ListEntries(ctx context.Context, in *ListEntriesRequest, opts ...grpc.CallOption) (*ListEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEntriesResponse)
	err := c.cc.Invoke(ctx, EntriesService_ListEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entriesServiceClient) AppendEntry(ctx context.Context, in *AppendEntryRequest, opts ...grpc.CallOption) (*Entry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Entry)
	err := c.cc.Invoke(ctx, EntriesService_AppendEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entriesServiceClient) SyncEntries(ctx context.Context, in *SyncEntriesRequest, opts ...grpc.CallOption) (*SyncEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncEntriesResponse)
	err := c.cc.Invoke(ctx, EntriesService_SyncEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EntriesServiceServer is the server API for EntriesService service.
// All implementations must embed UnimplementedEntriesServiceServer
// for forward compatibility.
type EntriesServiceServer interface {
	ListEntries(context.Context, *ListEntriesRequest) (*ListEntriesResponse, error)
	AppendEntry(context.Context, *AppendEntryRequest) (*Entry, error)
	SyncEntries(context.Context, *SyncEntriesRequest) (*SyncEntriesResponse, error)
	mustEmbedUnimplementedEntriesServiceServer()
}

// UnimplementedEntriesServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEntriesServiceServer struct{}

func (UnimplementedEntriesServiceServer) ListEntries(context.Context, *ListEntriesRequest) (*ListEntriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEntries not implemented")
}
func (UnimplementedEntriesServiceServer) AppendEntry(context.Context, *AppendEntryRequest) (*Entry, error) {
	return nil, status.Error(codes.Unimplemented, "method AppendEntry not implemented")
}
func (UnimplementedEntriesServiceServer) SyncEntries(context.Context, *SyncEntriesRequest) (*SyncEntriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncEntries not implemented")
}
func (UnimplementedEntriesServiceServer) mustEmbedUnimplementedEntriesServiceServer() {}
func (UnimplementedEntriesServiceServer) testEmbeddedByValue()                        {}

// UnsafeEntriesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EntriesServiceServer will
// result in compilation errors.
type UnsafeEntriesServiceServer interface {
	mustEmbedUnimplementedEntriesServiceServer()
}

func RegisterEntriesServiceServer(s grpc.ServiceRegistrar, srv EntriesServiceServer) {
	// If the following call panics, it indicates UnimplementedEntriesServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EntriesService_ServiceDesc, srv)
}

func _EntriesService_ListEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntriesServiceServer).ListEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EntriesService_ListEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntriesServiceServer).ListEntries(ctx, req.(*ListEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntriesService_AppendEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntriesServiceServer).AppendEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EntriesService_AppendEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntriesServiceServer).AppendEntry(ctx, req.(*AppendEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntriesService_SyncEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntriesServiceServer).SyncEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EntriesService_SyncEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntriesServiceServer).SyncEntries(ctx, req.(*SyncEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EntriesService_ServiceDesc is the grpc.ServiceDesc for EntriesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EntriesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.EntriesService",
	HandlerType: (*EntriesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListEntries",
			Handler:    _EntriesService_ListEntries_Handler,
		},
		{
			MethodName: "AppendEntry",
			Handler:    _EntriesService_AppendEntry_Handler,
		},
		{
			MethodName: "SyncEntries",
			Handler:    _EntriesService_SyncEntries_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	SearchService_SearchConversations_FullMethodName  = "/memory.v1.SearchService/SearchConversations"
	SearchService_IndexConversations_FullMethodName   = "/memory.v1.SearchService/IndexConversations"
	SearchService_ListUnindexedEntries_FullMethodName = "/memory.v1.SearchService/ListUnindexedEntries"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearchServiceClient interface {
	SearchConversations(ctx context.Context, in *SearchEntriesRequest, opts ...grpc.CallOption) (*SearchEntriesResponse, error)
	// Index conversation entries for search. Requires indexer or admin role.
	IndexConversations(ctx context.Context, in *IndexConversationsRequest, opts ...grpc.CallOption) (*IndexConversationsResponse, error)
	// List entries needing indexing. Requires indexer or admin role.
	ListUnindexedEntries(ctx context.Context, in *ListUnindexedEntriesRequest, opts ...grpc.CallOption) (*ListUnindexedEntriesResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) SearchConversations(ctx context.Context, in *SearchEntriesRequest, opts ...grpc.CallOption) (*SearchEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchEntriesResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) IndexConversations(ctx context.Context, in *IndexConversationsRequest, opts ...grpc.CallOption) (*IndexConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IndexConversationsResponse)
	err := c.cc.Invoke(ctx, SearchService_IndexConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) ListUnindexedEntries(ctx context.Context, in *ListUnindexedEntriesRequest, opts ...grpc.CallOption) (*ListUnindexedEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUnindexedEntriesResponse)
	err := c.cc.Invoke(ctx, SearchService_ListUnindexedEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
type SearchServiceServer interface {
	SearchConversations(context.Context, *SearchEntriesRequest) (*SearchEntriesResponse, error)
	// Index conversation entries for search. Requires indexer or admin role.
	IndexConversations(context.Context, *IndexConversationsRequest) (*IndexConversationsResponse, error)
	// List entries needing indexing. Requires indexer or admin role.
	ListUnindexedEntries(context.Context, *ListUnindexedEntriesRequest) (*ListUnindexedEntriesResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) SearchConversations(context.Context, *SearchEntriesRequest) (*SearchEntriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchConversations not implemented")
}
func (UnimplementedSearchServiceServer) IndexConversations(context.Context, *IndexConversationsRequest) (*IndexConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IndexConversations not implemented")
}
func (UnimplementedSearchServiceServer) ListUnindexedEntries(context.Context, *ListUnindexedEntriesRequest) (*ListUnindexedEntriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUnindexedEntries not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call panics, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_SearchConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchConversations(ctx, req.(*SearchEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_IndexConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).IndexConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_IndexConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).IndexConversations(ctx, req.(*IndexConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_ListUnindexedEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnindexedEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).ListUnindexedEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_ListUnindexedEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).ListUnindexedEntries(ctx, req.(*ListUnindexedEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchConversations",
			Handler:    _SearchService_SearchConversations_Handler,
		},
		{
			MethodName: "IndexConversations",
			Handler:    _SearchService_IndexConversations_Handler,
		},
		{
			MethodName: "ListUnindexedEntries",
			Handler:    _SearchService_ListUnindexedEntries_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	ResponseRecorderService_Record_FullMethodName          = "/memory.v1.ResponseRecorderService/Record"
	ResponseRecorderService_Replay_FullMethodName          = "/memory.v1.ResponseRecorderService/Replay"
	ResponseRecorderService_Cancel_FullMethodName          = "/memory.v1.ResponseRecorderService/Cancel"
	ResponseRecorderService_IsEnabled_FullMethodName       = "/memory.v1.ResponseRecorderService/IsEnabled"
	ResponseRecorderService_CheckRecordings_FullMethodName = "/memory.v1.ResponseRecorderService/CheckRecordings"
)

// ResponseRecorderServiceClient is the client API for ResponseRecorderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResponseRecorderServiceClient interface {
	// Record response content for a conversation (client streaming, unary response)
	Record(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RecordRequest, RecordResponse], error)
	// Replay a recording of a conversation
	Replay(ctx context.Context, in *ReplayRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplayResponse], error)
	// Cancel an in-progress recording
	Cancel(ctx context.Context, in *CancelRecordRequest, opts ...grpc.CallOption) (*CancelRecordResponse, error)
	// Check if response recorder is enabled
	IsEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IsEnabledResponse, error)
	// Check which conversations have active recordings
	CheckRecordings(ctx context.Context, in *CheckRecordingsRequest, opts ...grpc.CallOption) (*CheckRecordingsResponse, error)
}

type responseRecorderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResponseRecorderServiceClient(cc grpc.ClientConnInterface) ResponseRecorderServiceClient {
	return &responseRecorderServiceClient{cc}
}

func (c *responseRecorderServiceClient) Record(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RecordRequest, RecordResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ResponseRecorderService_ServiceDesc.Streams[0], ResponseRecorderService_Record_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecordRequest, RecordResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResponseRecorderService_RecordClient = grpc.ClientStreamingClient[RecordRequest, RecordResponse]

func (c *responseRecorderServiceClient) Replay(ctx context.Context, in *ReplayRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplayResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ResponseRecorderService_ServiceDesc.Streams[1], ResponseRecorderService_Replay_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReplayRequest, ReplayResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResponseRecorderService_ReplayClient = grpc.ServerStreamingClient[ReplayResponse]

func (c *responseRecorderServiceClient) Cancel(ctx context.Context, in *CancelRecordRequest, opts ...grpc.CallOption) (*CancelRecordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelRecordResponse)
	err := c.cc.Invoke(ctx, ResponseRecorderService_Cancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *responseRecorderServiceClient) IsEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IsEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsEnabledResponse)
	err := c.cc.Invoke(ctx, ResponseRecorderService_IsEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *responseRecorderServiceClient) CheckRecordings(ctx context.Context, in *CheckRecordingsRequest, opts ...grpc.CallOption) (*CheckRecordingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckRecordingsResponse)
	err := c.cc.Invoke(ctx, ResponseRecorderService_CheckRecordings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResponseRecorderServiceServer is the server API for ResponseRecorderService service.
// All implementations must embed UnimplementedResponseRecorderServiceServer
// for forward compatibility.
type ResponseRecorderServiceServer interface {
	// Record response content for a conversation (client streaming, unary response)
	Record(grpc.ClientStreamingServer[RecordRequest, RecordResponse]) error
	// Replay a recording of a conversation
	Replay(*ReplayRequest, grpc.ServerStreamingServer[ReplayResponse]) error
	// Cancel an in-progress recording
	Cancel(context.Context, *CancelRecordRequest) (*CancelRecordResponse, error)
	// Check if response recorder is enabled
	IsEnabled(context.Context, *emptypb.Empty) (*IsEnabledResponse, error)
	// Check which conversations have active recordings
	CheckRecordings(context.Context, *CheckRecordingsRequest) (*CheckRecordingsResponse, error)
	mustEmbedUnimplementedResponseRecorderServiceServer()
}

// UnimplementedResponseRecorderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedResponseRecorderServiceServer struct{}

func (UnimplementedResponseRecorderServiceServer) Record(grpc.ClientStreamingServer[RecordRequest, RecordResponse]) error {
	return status.Error(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedResponseRecorderServiceServer) Replay(*ReplayRequest, grpc.ServerStreamingServer[ReplayResponse]) error {
	return status.Error(codes.Unimplemented, "method Replay not implemented")
}
func (UnimplementedResponseRecorderServiceServer) Cancel(context.Context, *CancelRecordRequest) (*CancelRecordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedResponseRecorderServiceServer) IsEnabled(context.Context, *emptypb.Empty) (*IsEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsEnabled not implemented")
}
func (UnimplementedResponseRecorderServiceServer) CheckRecordings(context.Context, *CheckRecordingsRequest) (*CheckRecordingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckRecordings not implemented")
}
func (UnimplementedResponseRecorderServiceServer) mustEmbedUnimplementedResponseRecorderServiceServer() {
}
func (UnimplementedResponseRecorderServiceServer) testEmbeddedByValue() {}

// UnsafeResponseRecorderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResponseRecorderServiceServer will
// result in compilation errors.
type UnsafeResponseRecorderServiceServer interface {
	mustEmbedUnimplementedResponseRecorderServiceServer()
}

func RegisterResponseRecorderServiceServer(s grpc.ServiceRegistrar, srv ResponseRecorderServiceServer) {
	// If the following call panics, it indicates UnimplementedResponseRecorderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ResponseRecorderService_ServiceDesc, srv)
}

func _ResponseRecorderService_Record_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ResponseRecorderServiceServer).Record(&grpc.GenericServerStream[RecordRequest, RecordResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResponseRecorderService_RecordServer = grpc.ClientStreamingServer[RecordRequest, RecordResponse]

func _ResponseRecorderService_Replay_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplayRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResponseRecorderServiceServer).Replay(m, &grpc.GenericServerStream[ReplayRequest, ReplayResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResponseRecorderService_ReplayServer = grpc.ServerStreamingServer[ReplayResponse]

func _ResponseRecorderService_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResponseRecorderServiceServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResponseRecorderService_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResponseRecorderServiceServer).Cancel(ctx, req.(*CancelRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResponseRecorderService_IsEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResponseRecorderServiceServer).IsEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResponseRecorderService_IsEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResponseRecorderServiceServer).IsEnabled(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResponseRecorderService_CheckRecordings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRecordingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResponseRecorderServiceServer).CheckRecordings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResponseRecorderService_CheckRecordings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResponseRecorderServiceServer).CheckRecordings(ctx, req.(*CheckRecordingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ResponseRecorderService_ServiceDesc is the grpc.ServiceDesc for ResponseRecorderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResponseRecorderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.ResponseRecorderService",
	HandlerType: (*ResponseRecorderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Cancel",
			Handler:    _ResponseRecorderService_Cancel_Handler,
		},
		{
			MethodName: "IsEnabled",
			Handler:    _ResponseRecorderService_IsEnabled_Handler,
		},
		{
			MethodName: "CheckRecordings",
			Handler:    _ResponseRecorderService_CheckRecordings_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Record",
			Handler:       _ResponseRecorderService_Record_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Replay",
			Handler:       _ResponseRecorderService_Replay_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "memory/v1/memory_service.proto",
}

const (
	AttachmentsService_UploadAttachment_FullMethodName   = "/memory.v1.AttachmentsService/UploadAttachment"
	AttachmentsService_GetAttachment_FullMethodName      = "/memory.v1.AttachmentsService/GetAttachment"
	AttachmentsService_DownloadAttachment_FullMethodName = "/memory.v1.AttachmentsService/DownloadAttachment"
)

// AttachmentsServiceClient is the client API for AttachmentsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AttachmentsServiceClient interface {
	// Upload a file as a stream of chunks. First message must contain metadata.
	// Subsequent messages contain file data chunks.
	// Server responds once the upload is complete or an error occurs.
	UploadAttachment(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadAttachmentRequest, UploadAttachmentResponse], error)
	// Retrieve attachment metadata (not the file content).
	GetAttachment(ctx context.Context, in *GetAttachmentRequest, opts ...grpc.CallOption) (*AttachmentInfo, error)
	// Download a file as a stream of chunks.
	DownloadAttachment(ctx context.Context, in *DownloadAttachmentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadAttachmentResponse], error)
}

type attachmentsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAttachmentsServiceClient(cc grpc.ClientConnInterface) AttachmentsServiceClient {
	return &attachmentsServiceClient{cc}
}

func (c *attachmentsServiceClient) UploadAttachment(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadAttachmentRequest, UploadAttachmentResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AttachmentsService_ServiceDesc.Streams[0], AttachmentsService_UploadAttachment_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UploadAttachmentRequest, UploadAttachmentResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AttachmentsService_UploadAttachmentClient = grpc.ClientStreamingClient[UploadAttachmentRequest, UploadAttachmentResponse]

func (c *attachmentsServiceClient) GetAttachment(ctx context.Context, in *GetAttachmentRequest, opts ...grpc.CallOption) (*AttachmentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttachmentInfo)
	err := c.cc.Invoke(ctx, AttachmentsService_GetAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentsServiceClient) DownloadAttachment(ctx context.Context, in *DownloadAttachmentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadAttachmentResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AttachmentsService_ServiceDesc.Streams[1], AttachmentsService_DownloadAttachment_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DownloadAttachmentRequest, DownloadAttachmentResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AttachmentsService_DownloadAttachmentClient = grpc.ServerStreamingClient[DownloadAttachmentResponse]

// AttachmentsServiceServer is the server API for AttachmentsService service.
// All implementations must embed UnimplementedAttachmentsServiceServer
// for forward compatibility.
type AttachmentsServiceServer interface {
	// Upload a file as a stream of chunks. First message must contain metadata.
	// Subsequent messages contain file data chunks.
	// Server responds once the upload is complete or an error occurs.
	UploadAttachment(grpc.ClientStreamingServer[UploadAttachmentRequest, UploadAttachmentResponse]) error
	// Retrieve attachment metadata (not the file content).
	GetAttachment(context.Context, *GetAttachmentRequest) (*AttachmentInfo, error)
	// Download a file as a stream of chunks.
	DownloadAttachment(*DownloadAttachmentRequest, grpc.ServerStreamingServer[DownloadAttachmentResponse]) error
	mustEmbedUnimplementedAttachmentsServiceServer()
}

// UnimplementedAttachmentsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAttachmentsServiceServer struct{}

func (UnimplementedAttachmentsServiceServer) UploadAttachment(grpc.ClientStreamingServer[UploadAttachmentRequest, UploadAttachmentResponse]) error {
	return status.Error(codes.Unimplemented, "method UploadAttachment not implemented")
}
func (UnimplementedAttachmentsServiceServer) GetAttachment(context.Context, *GetAttachmentRequest) (*AttachmentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttachment not implemented")
}
func (UnimplementedAttachmentsServiceServer) DownloadAttachment(*DownloadAttachmentRequest, grpc.ServerStreamingServer[DownloadAttachmentResponse]) error {
	return status.Error(codes.Unimplemented, "method DownloadAttachment not implemented")
}
func (UnimplementedAttachmentsServiceServer) mustEmbedUnimplementedAttachmentsServiceServer() {}
func (UnimplementedAttachmentsServiceServer) testEmbeddedByValue()                            {}

// UnsafeAttachmentsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AttachmentsServiceServer will
// result in compilation errors.
type UnsafeAttachmentsServiceServer interface {
	mustEmbedUnimplementedAttachmentsServiceServer()
}

func RegisterAttachmentsServiceServer(s grpc.ServiceRegistrar, srv AttachmentsServiceServer) {
	// If the following call panics, it indicates UnimplementedAttachmentsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AttachmentsService_ServiceDesc, srv)
}

func _AttachmentsService_UploadAttachment_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AttachmentsServiceServer).UploadAttachment(&grpc.GenericServerStream[UploadAttachmentRequest, UploadAttachmentResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AttachmentsService_UploadAttachmentServer = grpc.ClientStreamingServer[UploadAttachmentRequest, UploadAttachmentResponse]

func _AttachmentsService_GetAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentsServiceServer).GetAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AttachmentsService_GetAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentsServiceServer).GetAttachment(ctx, req.(*GetAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttachmentsService_DownloadAttachment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadAttachmentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AttachmentsServiceServer).DownloadAttachment(m, &grpc.GenericServerStream[DownloadAttachmentRequest, DownloadAttachmentResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AttachmentsService_DownloadAttachmentServer = grpc.ServerStreamingServer[DownloadAttachmentResponse]

// AttachmentsService_ServiceDesc is the grpc.ServiceDesc for AttachmentsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AttachmentsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "memory.v1.AttachmentsService",
	HandlerType: (*AttachmentsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAttachment",
			Handler:    _AttachmentsService_GetAttachment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadAttachment",
			Handler:       _AttachmentsService_UploadAttachment_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadAttachment",
			Handler:       _AttachmentsService_DownloadAttachment_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "memory/v1/memory_service.proto",
}

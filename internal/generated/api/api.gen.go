// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AccessLevel.
const (
	Manager AccessLevel = "manager"
	Owner   AccessLevel = "owner"
	Reader  AccessLevel = "reader"
	Writer  AccessLevel = "writer"
)

// Defines values for AttachmentUploadResponseStatus.
const (
	Downloading AttachmentUploadResponseStatus = "downloading"
	Failed      AttachmentUploadResponseStatus = "failed"
	Ready       AttachmentUploadResponseStatus = "ready"
	Uploading   AttachmentUploadResponseStatus = "uploading"
)

// Defines values for Channel.
const (
	History Channel = "history"
	Memory  Channel = "memory"
)

// Defines values for SearchConversationsRequestSearchType.
const (
	Auto     SearchConversationsRequestSearchType = "auto"
	Fulltext SearchConversationsRequestSearchType = "fulltext"
	Semantic SearchConversationsRequestSearchType = "semantic"
)

// Defines values for SearchResultKind.
const (
	Mongo    SearchResultKind = "mongo"
	Pgvector SearchResultKind = "pgvector"
	Postgres SearchResultKind = "postgres"
	Qdrant   SearchResultKind = "qdrant"
)

// Defines values for ListConversationsParamsMode.
const (
	ListConversationsParamsModeAll        ListConversationsParamsMode = "all"
	ListConversationsParamsModeLatestFork ListConversationsParamsMode = "latest-fork"
	ListConversationsParamsModeRoots      ListConversationsParamsMode = "roots"
)

// Defines values for ListConversationEntriesParamsForks.
const (
	ListConversationEntriesParamsForksAll  ListConversationEntriesParamsForks = "all"
	ListConversationEntriesParamsForksNone ListConversationEntriesParamsForks = "none"
)

// Defines values for ListPendingTransfersParamsRole.
const (
	All       ListPendingTransfersParamsRole = "all"
	Recipient ListPendingTransfersParamsRole = "recipient"
	Sender    ListPendingTransfersParamsRole = "sender"
)

// AccessLevel Access level of a user for a conversation.
type AccessLevel string

// Attachment A reference to an attachment on a history entry. Supports two modes:
//
// **External URL (Phase 1)**: Provide `href` and `contentType` to reference
// an externally-hosted resource.
//
// **Server-stored (Phase 2)**: Provide `attachmentId` to reference a file
// previously uploaded via `POST /v1/attachments`. When the entry is created,
// the server replaces `attachmentId` with an `href` pointing to
// `/v1/attachments/{id}`.
//
// At least one of `href` or `attachmentId` must be present.
type Attachment struct {
	// AttachmentId ID of a previously uploaded attachment (from POST /v1/attachments).
	// When the entry is created, this is replaced with an href.
	AttachmentId *string `json:"attachmentId,omitempty"`

	// ContentType MIME type of the attachment (e.g., "image/jpeg", "audio/mp3"). Required when href is provided directly.
	ContentType *string `json:"contentType,omitempty"`

	// Description Optional alt text or description.
	Description *string `json:"description,omitempty"`

	// Href URL to the attachment resource (external or server-relative).
	Href *string `json:"href,omitempty"`

	// Name Optional display name for the attachment.
	Name *string `json:"name,omitempty"`

	// Sha256 SHA-256 hash of the file content (set by server for uploaded attachments).
	Sha256 *string `json:"sha256,omitempty"`

	// Size File size in bytes (set by server for uploaded attachments).
	Size *int64 `json:"size,omitempty"`
}

// AttachmentDownloadUrlResponse Response containing a signed download URL for an attachment.
type AttachmentDownloadUrlResponse struct {
	// ExpiresIn Number of seconds until the URL expires.
	ExpiresIn *int `json:"expiresIn,omitempty"`

	// Url The signed download URL. May be an absolute S3 URL or a server-relative path.
	Url *string `json:"url,omitempty"`
}

// AttachmentUploadResponse Response from uploading or creating an attachment.
type AttachmentUploadResponse struct {
	// ContentType MIME type of the uploaded file.
	ContentType *string `json:"contentType,omitempty"`

	// ExpiresAt When this unlinked attachment will expire and be deleted.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Filename Original filename of the uploaded file.
	Filename *string `json:"filename"`

	// Href Server-relative URL to retrieve the attachment.
	Href *string `json:"href,omitempty"`

	// Id Unique identifier for the uploaded attachment.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Sha256 SHA-256 hash of the file content (null for URL-created attachments until download completes).
	Sha256 *string `json:"sha256,omitempty"`

	// Size File size in bytes (null for URL-created attachments until download completes).
	Size *int64 `json:"size,omitempty"`

	// SourceUrl Original source URL (only present for URL-created attachments).
	SourceUrl *string `json:"sourceUrl,omitempty"`

	// Status Current status of the attachment:
	// - `uploading` - Multipart upload created but not yet completed
	// - `downloading` - Server is downloading content from sourceUrl
	// - `ready` - Content is available for retrieval
	// - `failed` - Download from sourceUrl failed
	Status *AttachmentUploadResponseStatus `json:"status,omitempty"`
}

// AttachmentUploadResponseStatus Current status of the attachment:
// - `uploading` - Multipart upload created but not yet completed
// - `downloading` - Server is downloading content from sourceUrl
// - `ready` - Content is available for retrieval
// - `failed` - Download from sourceUrl failed
type AttachmentUploadResponseStatus string

// Channel Logical channel of the entry within the conversation.
type Channel string

// Conversation defines model for Conversation.
type Conversation struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`

	// ForkedAtConversationId Conversation ID from which this conversation was forked.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId"`

	// ForkedAtEntryId Entry ID where this conversation forked from its parent.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId"`

	// Id Unique identifier for the conversation.
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	LastMessagePreview *string             `json:"lastMessagePreview"`
	OwnerUserId        *string             `json:"ownerUserId,omitempty"`
	Title              *string             `json:"title"`
	UpdatedAt          *time.Time          `json:"updatedAt,omitempty"`
}

// ConversationForkSummary Summary of a forked conversation originating at a given entry.
type ConversationForkSummary struct {
	// ConversationId Unique identifier for the forked conversation.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	CreatedAt      *time.Time          `json:"createdAt,omitempty"`

	// ForkedAtConversationId Conversation ID where the fork occurred.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId"`

	// ForkedAtEntryId Entry ID at which this forked conversation diverged.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId,omitempty"`
	Title           *string             `json:"title"`
}

// ConversationMembership defines model for ConversationMembership.
type ConversationMembership struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`

	// ConversationId Unique identifier for the conversation.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	CreatedAt      *time.Time          `json:"createdAt,omitempty"`
	UserId         *string             `json:"userId,omitempty"`
}

// ConversationSummary defines model for ConversationSummary.
type ConversationSummary struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`

	// Id Unique identifier for the conversation.
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	LastMessagePreview *string             `json:"lastMessagePreview"`
	OwnerUserId        *string             `json:"ownerUserId,omitempty"`
	Title              *string             `json:"title"`
	UpdatedAt          *time.Time          `json:"updatedAt,omitempty"`
}

// CreateConversationRequest defines model for CreateConversationRequest.
type CreateConversationRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Title    *string                 `json:"title"`
}

// CreateEntryRequest defines model for CreateEntryRequest.
type CreateEntryRequest struct {
	// Channel Logical channel of the entry within the conversation.
	Channel *Channel `json:"channel,omitempty"`

	// Content For history channel entries (contentType: `"history"` or `"history/<subtype>"`), each block
	// contains `role` and at least one of `text`, `events`, or `attachments`.
	Content []interface{} `json:"content"`

	// ContentType Describes the schema/format of the content array.
	//
	// **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
	//
	// Supported content types:
	// - `history` - Simple text-only history entries
	// - `history/lc4j` - LangChain4j rich event format (Quarkus)
	//
	// The content array for history entries must contain exactly 1 object with:
	// - `role` (string, required): Either `"USER"` or `"AI"`.
	// - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
	// - `events` (array, optional): Rich event objects for streaming details.
	//   Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
	//   - `PartialResponse`: Text chunk (`{eventType, chunk}`)
	//   - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
	//   - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
	//   - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
	// - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
	//
	// Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
	// agent memory entries.
	ContentType string `json:"contentType"`

	// ForkedAtConversationId If the target conversation doesn't exist yet, auto-create it as a fork of this conversation. Ignored when the conversation already exists.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId,omitempty"`

	// ForkedAtEntryId Entry ID marking the fork point. Entries before this point are inherited; entries at and after this point are excluded. Required when forkedAtConversationId is set.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId,omitempty"`

	// IndexedContent Optional text to index for search. Only valid for entries in the history
	// channel. If provided, the entry will be indexed for search immediately
	// after creation. Returns 400 Bad Request if specified for non-history channels.
	IndexedContent *string `json:"indexedContent"`

	// UserId Human user this entry is associated with.
	// For history entries authored by a user, this is the sender.
	// For agent entries, this is the user the agent is responding to.
	UserId *string `json:"userId"`
}

// CreateFromUrlRequest Request to create an attachment from a source URL.
type CreateFromUrlRequest struct {
	// ContentType MIME type of the content. Defaults to application/octet-stream.
	ContentType *string `json:"contentType,omitempty"`

	// Name Display name for the attachment.
	Name *string `json:"name,omitempty"`

	// SourceUrl URL of the content to download and store as an attachment.
	SourceUrl string `json:"sourceUrl"`
}

// CreateOwnershipTransferRequest defines model for CreateOwnershipTransferRequest.
type CreateOwnershipTransferRequest struct {
	// ConversationId The conversation to transfer ownership of.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// NewOwnerUserId User ID of the proposed new owner. Must be an existing member.
	NewOwnerUserId string `json:"newOwnerUserId"`
}

// Entry defines model for Entry.
type Entry struct {
	// Channel Logical channel of the entry within the conversation.
	Channel Channel `json:"channel"`

	// Content Opaque, agent-defined content blocks.
	// Different agents may use different schemas; the memory-service
	// stores and returns them without interpretation.
	//
	// For history channel entries (contentType: `"history"`), each block
	// contains `role` and at least one of `text`, `events`, or `attachments`.
	Content []interface{} `json:"content"`

	// ContentType Describes the schema/format of the content array.
	//
	// **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
	//
	// Supported content types:
	// - `history` - Simple text-only history entries
	// - `history/lc4j` - LangChain4j rich event format (Quarkus)
	//
	// The content array for history entries contains objects with:
	// - `role` (string, required): Either `"USER"` or `"AI"`.
	// - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
	// - `events` (array, optional): Rich event objects for streaming details.
	//   Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
	//   - `PartialResponse`: Text chunk (`{eventType, chunk}`)
	//   - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
	//   - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
	//   - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
	// - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
	//
	// Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
	// agent memory entries.
	ContentType string `json:"contentType"`

	// ConversationId Unique identifier for the conversation this entry belongs to.
	ConversationId openapi_types.UUID `json:"conversationId"`
	CreatedAt      time.Time          `json:"createdAt"`

	// Epoch Logical memory epoch this entry belongs to.
	// For history entries this is typically null. For memory entries,
	// the agent increments the epoch when starting a new memory version.
	Epoch *int64 `json:"epoch"`

	// Id Unique identifier for the entry.
	Id openapi_types.UUID `json:"id"`

	// UserId Human user this entry is associated with.
	// For history entries authored by a user, this is the sender.
	// For agent entries, this is the user the agent is responding to.
	UserId *string `json:"userId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
}

// IndexConversationsResponse defines model for IndexConversationsResponse.
type IndexConversationsResponse struct {
	// Indexed Number of entries processed. These entries have their indexed content
	// stored and will be searchable. If vector store indexing failed for some
	// entries, they will become searchable asynchronously via background retry.
	Indexed *int `json:"indexed,omitempty"`
}

// IndexEntryRequest defines model for IndexEntryRequest.
type IndexEntryRequest struct {
	// ConversationId The conversation containing the entry.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// EntryId The entry ID to index.
	EntryId openapi_types.UUID `json:"entryId"`

	// IndexedContent The searchable text for this entry.
	IndexedContent string `json:"indexedContent"`
}

// OwnershipTransfer Represents a pending ownership transfer request.
// Transfers are always "pending" while they exist; accepted/rejected transfers
// are hard deleted from the database.
type OwnershipTransfer struct {
	// ConversationId The conversation being transferred.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// ConversationTitle Title of the conversation (for display purposes).
	ConversationTitle *string `json:"conversationTitle"`

	// CreatedAt When the transfer was initiated.
	CreatedAt time.Time `json:"createdAt"`

	// FromUserId Current owner initiating the transfer.
	FromUserId string `json:"fromUserId"`

	// Id Unique identifier for the transfer.
	Id openapi_types.UUID `json:"id"`

	// ToUserId Proposed new owner (recipient).
	ToUserId string `json:"toUserId"`
}

// SearchConversationsRequest defines model for SearchConversationsRequest.
type SearchConversationsRequest struct {
	// AfterCursor Cursor for pagination; returns items after this result.
	AfterCursor *string `json:"afterCursor"`

	// GroupByConversation When true (default), groups results by conversation and returns only
	// the highest-scoring entry per conversation. When false, returns all
	// matching entries ordered by score.
	GroupByConversation *bool `json:"groupByConversation,omitempty"`

	// IncludeEntry Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.
	IncludeEntry *bool `json:"includeEntry,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `json:"limit,omitempty"`

	// Query Natural language query.
	Query string `json:"query"`

	// SearchType The search method to use:
	// - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
	// - `semantic`: Use only vector/embedding-based semantic search
	// - `fulltext`: Use only PostgreSQL full-text search with GIN index
	//
	// If the requested search type is not available on the server, a 501 (Not Implemented)
	// error is returned with details about which search types are available.
	SearchType *SearchConversationsRequestSearchType `json:"searchType,omitempty"`
}

// SearchConversationsRequestSearchType The search method to use:
// - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
// - `semantic`: Use only vector/embedding-based semantic search
// - `fulltext`: Use only PostgreSQL full-text search with GIN index
//
// If the requested search type is not available on the server, a 501 (Not Implemented)
// error is returned with details about which search types are available.
type SearchConversationsRequestSearchType string

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// ConversationId Unique identifier of the conversation containing this entry.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`

	// ConversationTitle Title of the conversation containing this entry.
	ConversationTitle *string `json:"conversationTitle,omitempty"`

	// Entry The matched entry. Only included when includeEntry is true in the request.
	Entry *Entry `json:"entry,omitempty"`

	// EntryId ID of the matched entry. Always present for deep-linking.
	EntryId    *openapi_types.UUID `json:"entryId,omitempty"`
	Highlights *string             `json:"highlights"`

	// Kind Identifies which search backend produced the score (e.g. `postgres`, `mongo`, `qdrant`, `pgvector`).
	Kind *SearchResultKind `json:"kind,omitempty"`

	// Score Relevance score. Higher is more relevant.
	Score *float32 `json:"score,omitempty"`
}

// SearchResultKind Identifies which search backend produced the score (e.g. `postgres`, `mongo`, `qdrant`, `pgvector`).
type SearchResultKind string

// SearchTypeUnavailableError Error response when the requested search type is not available on the server.
type SearchTypeUnavailableError struct {
	// AvailableTypes List of search types that are available on this server.
	AvailableTypes *[]string `json:"availableTypes,omitempty"`

	// Error Error code.
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message.
	Message *string `json:"message,omitempty"`
}

// ShareConversationRequest defines model for ShareConversationRequest.
type ShareConversationRequest struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel AccessLevel `json:"accessLevel"`
	CreatedAt   *time.Time  `json:"createdAt,omitempty"`
	UserId      string      `json:"userId"`
}

// SyncEntryResponse defines model for SyncEntryResponse.
type SyncEntryResponse struct {
	Entry *Entry `json:"entry,omitempty"`

	// Epoch The epoch number that now reflects the stored memory state.
	Epoch *int64 `json:"epoch"`

	// EpochIncremented True when the provided list diverged and a new epoch was started.
	EpochIncremented *bool `json:"epochIncremented,omitempty"`

	// NoOp True when the request resulted in no stored changes.
	NoOp *bool `json:"noOp,omitempty"`
}

// UnindexedEntriesResponse defines model for UnindexedEntriesResponse.
type UnindexedEntriesResponse struct {
	// AfterCursor Cursor for fetching next page. Null when no more results.
	AfterCursor *string           `json:"afterCursor"`
	Data        *[]UnindexedEntry `json:"data,omitempty"`
}

// UnindexedEntry defines model for UnindexedEntry.
type UnindexedEntry struct {
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	Entry          *Entry              `json:"entry,omitempty"`
}

// UpdateConversationRequest defines model for UpdateConversationRequest.
type UpdateConversationRequest struct {
	Title *string `json:"title"`
}

// Error defines model for Error.
type Error = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// SearchTypeUnavailable Error response when the requested search type is not available on the server.
type SearchTypeUnavailable = SearchTypeUnavailableError

// UploadAttachmentMultipartBody defines parameters for UploadAttachment.
type UploadAttachmentMultipartBody struct {
	// File The file to upload.
	File openapi_types.File `json:"file"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// ExpiresIn ISO 8601 duration for how long the unlinked attachment should persist.
	// Defaults to 1 hour. Maximum 24 hours. Only used for multipart uploads.
	ExpiresIn *string `form:"expiresIn,omitempty" json:"expiresIn,omitempty"`
}

// ListConversationsParams defines parameters for ListConversations.
type ListConversationsParams struct {
	// Mode Listing mode for conversations. Controls which conversations are returned
	// from each fork tree (conversation group).
	// - `all`: include all conversations the user can access (roots and forks).
	// - `roots`: only include root conversations (conversations that are not forks).
	// - `latest-fork`: include only the most recently updated conversation per fork tree.
	//   This is useful for showing a single representative conversation from each tree.
	Mode *ListConversationsParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// AfterCursor Cursor for pagination; returns items after this conversation id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of conversations to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Query Optional text query for basic title/metadata search.
	Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// ListConversationsParamsMode defines parameters for ListConversations.
type ListConversationsParamsMode string

// IndexConversationsJSONBody defines parameters for IndexConversations.
type IndexConversationsJSONBody = []IndexEntryRequest

// ListUnindexedEntriesParams defines parameters for ListUnindexedEntries.
type ListUnindexedEntriesParams struct {
	// Limit Maximum number of entries to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AfterCursor Pagination cursor from previous response.
	AfterCursor *string `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`
}

// ListConversationEntriesParams defines parameters for ListConversationEntries.
type ListConversationEntriesParams struct {
	// AfterCursor Cursor for pagination; returns entries after this entry id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`
	Limit       *int                `form:"limit,omitempty" json:"limit,omitempty"`

	// Channel Channel of entries to return. Defaults to `history` for the
	// user-visible conversation; `memory` returns agent memory entries
	// scoped to the calling client id.
	Channel *Channel `form:"channel,omitempty" json:"channel,omitempty"`

	// Epoch Optional epoch filter when listing the `memory` channel. Valid values
	// are `latest`, `all`, or a numeric epoch identifier. Defaults to
	// `latest` when not provided. The epoch selection is scoped to the
	// calling client id.
	Epoch *string `form:"epoch,omitempty" json:"epoch,omitempty"`

	// Forks Controls which fork entries to include. `none` (default) follows the
	// fork ancestry path, returning entries from the target conversation
	// and its ancestors up to fork points. `all` returns entries from all
	// forks in the conversation group, useful for debugging or getting a
	// complete picture of all activity across forks.
	Forks *ListConversationEntriesParamsForks `form:"forks,omitempty" json:"forks,omitempty"`
}

// ListConversationEntriesParamsForks defines parameters for ListConversationEntries.
type ListConversationEntriesParamsForks string

// ListConversationForksParams defines parameters for ListConversationForks.
type ListConversationForksParams struct {
	// AfterCursor Cursor for pagination; returns items after this conversation id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of forks to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListConversationMembershipsParams defines parameters for ListConversationMemberships.
type ListConversationMembershipsParams struct {
	// AfterCursor Cursor for pagination; returns items after this user id.
	AfterCursor *string `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of memberships to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateConversationMembershipJSONBody defines parameters for UpdateConversationMembership.
type UpdateConversationMembershipJSONBody struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
}

// ListPendingTransfersParams defines parameters for ListPendingTransfers.
type ListPendingTransfersParams struct {
	// Role Filter by user's role in the transfer.
	Role *ListPendingTransfersParamsRole `form:"role,omitempty" json:"role,omitempty"`

	// AfterCursor Cursor for pagination; returns items after this transfer id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of transfers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListPendingTransfersParamsRole defines parameters for ListPendingTransfers.
type ListPendingTransfersParamsRole string

// UploadAttachmentJSONRequestBody defines body for UploadAttachment for application/json ContentType.
type UploadAttachmentJSONRequestBody = CreateFromUrlRequest

// UploadAttachmentMultipartRequestBody defines body for UploadAttachment for multipart/form-data ContentType.
type UploadAttachmentMultipartRequestBody UploadAttachmentMultipartBody

// CreateConversationJSONRequestBody defines body for CreateConversation for application/json ContentType.
type CreateConversationJSONRequestBody = CreateConversationRequest

// IndexConversationsJSONRequestBody defines body for IndexConversations for application/json ContentType.
type IndexConversationsJSONRequestBody = IndexConversationsJSONBody

// SearchConversationsJSONRequestBody defines body for SearchConversations for application/json ContentType.
type SearchConversationsJSONRequestBody = SearchConversationsRequest

// UpdateConversationJSONRequestBody defines body for UpdateConversation for application/json ContentType.
type UpdateConversationJSONRequestBody = UpdateConversationRequest

// AppendConversationEntryJSONRequestBody defines body for AppendConversationEntry for application/json ContentType.
type AppendConversationEntryJSONRequestBody = CreateEntryRequest

// SyncConversationMemoryJSONRequestBody defines body for SyncConversationMemory for application/json ContentType.
type SyncConversationMemoryJSONRequestBody = CreateEntryRequest

// ShareConversationJSONRequestBody defines body for ShareConversation for application/json ContentType.
type ShareConversationJSONRequestBody = ShareConversationRequest

// UpdateConversationMembershipJSONRequestBody defines body for UpdateConversationMembership for application/json ContentType.
type UpdateConversationMembershipJSONRequestBody UpdateConversationMembershipJSONBody

// CreateOwnershipTransferJSONRequestBody defines body for CreateOwnershipTransfer for application/json ContentType.
type CreateOwnershipTransferJSONRequestBody = CreateOwnershipTransferRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload or create an attachment
	// (POST /v1/attachments)
	UploadAttachment(c *gin.Context, params UploadAttachmentParams)
	// Download an attachment via signed token
	// (GET /v1/attachments/download/{token}/{filename})
	DownloadAttachmentByToken(c *gin.Context, token string, filename string)
	// Delete an unlinked attachment
	// (DELETE /v1/attachments/{id})
	DeleteAttachment(c *gin.Context, id openapi_types.UUID)
	// Retrieve an attachment
	// (GET /v1/attachments/{id})
	GetAttachment(c *gin.Context, id openapi_types.UUID)
	// Get a signed download URL for an attachment
	// (GET /v1/attachments/{id}/download-url)
	GetAttachmentDownloadUrl(c *gin.Context, id openapi_types.UUID)
	// List conversations visible to current user
	// (GET /v1/conversations)
	ListConversations(c *gin.Context, params ListConversationsParams)
	// Create a conversation
	// (POST /v1/conversations)
	CreateConversation(c *gin.Context)
	// Index conversation entries
	// (POST /v1/conversations/index)
	IndexConversations(c *gin.Context)
	// Semantic search across conversations
	// (POST /v1/conversations/search)
	SearchConversations(c *gin.Context)
	// List entries needing indexing
	// (GET /v1/conversations/unindexed)
	ListUnindexedEntries(c *gin.Context, params ListUnindexedEntriesParams)
	// Delete a conversation
	// (DELETE /v1/conversations/{conversationId})
	DeleteConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Get a conversation
	// (GET /v1/conversations/{conversationId})
	GetConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Update a conversation
	// (PATCH /v1/conversations/{conversationId})
	UpdateConversation(c *gin.Context, conversationId openapi_types.UUID)
	// List conversation entries
	// (GET /v1/conversations/{conversationId}/entries)
	ListConversationEntries(c *gin.Context, conversationId openapi_types.UUID, params ListConversationEntriesParams)
	// Append an entry
	// (POST /v1/conversations/{conversationId}/entries)
	AppendConversationEntry(c *gin.Context, conversationId openapi_types.UUID)
	// Synchronize the agent memory epoch
	// (POST /v1/conversations/{conversationId}/entries/sync)
	SyncConversationMemory(c *gin.Context, conversationId openapi_types.UUID)
	// List forks for a conversation
	// (GET /v1/conversations/{conversationId}/forks)
	ListConversationForks(c *gin.Context, conversationId openapi_types.UUID, params ListConversationForksParams)
	// List conversation memberships
	// (GET /v1/conversations/{conversationId}/memberships)
	ListConversationMemberships(c *gin.Context, conversationId openapi_types.UUID, params ListConversationMembershipsParams)
	// Share conversation with another user
	// (POST /v1/conversations/{conversationId}/memberships)
	ShareConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Remove a member from the conversation
	// (DELETE /v1/conversations/{conversationId}/memberships/{userId})
	DeleteConversationMembership(c *gin.Context, conversationId openapi_types.UUID, userId string)
	// Update a member's access level
	// (PATCH /v1/conversations/{conversationId}/memberships/{userId})
	UpdateConversationMembership(c *gin.Context, conversationId openapi_types.UUID, userId string)
	// Cancel an in-progress response
	// (DELETE /v1/conversations/{conversationId}/response)
	DeleteConversationResponse(c *gin.Context, conversationId openapi_types.UUID)
	// List pending ownership transfers
	// (GET /v1/ownership-transfers)
	ListPendingTransfers(c *gin.Context, params ListPendingTransfersParams)
	// Request ownership transfer
	// (POST /v1/ownership-transfers)
	CreateOwnershipTransfer(c *gin.Context)
	// Cancel or reject ownership transfer
	// (DELETE /v1/ownership-transfers/{transferId})
	DeleteTransfer(c *gin.Context, transferId openapi_types.UUID)
	// Get transfer details
	// (GET /v1/ownership-transfers/{transferId})
	GetTransfer(c *gin.Context, transferId openapi_types.UUID)
	// Accept ownership transfer
	// (POST /v1/ownership-transfers/{transferId}/accept)
	AcceptTransfer(c *gin.Context, transferId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadAttachment operation middleware
func (siw *ServerInterfaceWrapper) UploadAttachment(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadAttachmentParams

	// ------------- Optional query parameter "expiresIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "expiresIn", c.Request.URL.Query(), &params.ExpiresIn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter expiresIn: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadAttachment(c, params)
}

// DownloadAttachmentByToken operation middleware
func (siw *ServerInterfaceWrapper) DownloadAttachmentByToken(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", c.Param("filename"), &filename, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter filename: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DownloadAttachmentByToken(c, token, filename)
}

// DeleteAttachment operation middleware
func (siw *ServerInterfaceWrapper) DeleteAttachment(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAttachment(c, id)
}

// GetAttachment operation middleware
func (siw *ServerInterfaceWrapper) GetAttachment(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAttachment(c, id)
}

// GetAttachmentDownloadUrl operation middleware
func (siw *ServerInterfaceWrapper) GetAttachmentDownloadUrl(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAttachmentDownloadUrl(c, id)
}

// ListConversations operation middleware
func (siw *ServerInterfaceWrapper) ListConversations(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationsParams

	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", c.Request.URL.Query(), &params.Mode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", c.Request.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter query: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversations(c, params)
}

// CreateConversation operation middleware
func (siw *ServerInterfaceWrapper) CreateConversation(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateConversation(c)
}

// IndexConversations operation middleware
func (siw *ServerInterfaceWrapper) IndexConversations(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.IndexConversations(c)
}

// SearchConversations operation middleware
func (siw *ServerInterfaceWrapper) SearchConversations(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchConversations(c)
}

// ListUnindexedEntries operation middleware
func (siw *ServerInterfaceWrapper) ListUnindexedEntries(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUnindexedEntriesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListUnindexedEntries(c, params)
}

// DeleteConversation operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversation(c, conversationId)
}

// GetConversation operation middleware
func (siw *ServerInterfaceWrapper) GetConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConversation(c, conversationId)
}

// UpdateConversation operation middleware
func (siw *ServerInterfaceWrapper) UpdateConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateConversation(c, conversationId)
}

// ListConversationEntries operation middleware
func (siw *ServerInterfaceWrapper) ListConversationEntries(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationEntriesParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "channel" -------------

	err = runtime.BindQueryParameter("form", true, false, "channel", c.Request.URL.Query(), &params.Channel)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter channel: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "epoch" -------------

	err = runtime.BindQueryParameter("form", true, false, "epoch", c.Request.URL.Query(), &params.Epoch)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter epoch: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "forks" -------------

	err = runtime.BindQueryParameter("form", true, false, "forks", c.Request.URL.Query(), &params.Forks)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter forks: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationEntries(c, conversationId, params)
}

// AppendConversationEntry operation middleware
func (siw *ServerInterfaceWrapper) AppendConversationEntry(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AppendConversationEntry(c, conversationId)
}

// SyncConversationMemory operation middleware
func (siw *ServerInterfaceWrapper) SyncConversationMemory(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SyncConversationMemory(c, conversationId)
}

// ListConversationForks operation middleware
func (siw *ServerInterfaceWrapper) ListConversationForks(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationForksParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationForks(c, conversationId, params)
}

// ListConversationMemberships operation middleware
func (siw *ServerInterfaceWrapper) ListConversationMemberships(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationMembershipsParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationMemberships(c, conversationId, params)
}

// ShareConversation operation middleware
func (siw *ServerInterfaceWrapper) ShareConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ShareConversation(c, conversationId)
}

// DeleteConversationMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversationMembership(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversationMembership(c, conversationId, userId)
}

// UpdateConversationMembership operation middleware
func (siw *ServerInterfaceWrapper) UpdateConversationMembership(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateConversationMembership(c, conversationId, userId)
}

// DeleteConversationResponse operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversationResponse(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversationResponse(c, conversationId)
}

// ListPendingTransfers operation middleware
func (siw *ServerInterfaceWrapper) ListPendingTransfers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPendingTransfersParams

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", c.Request.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter role: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPendingTransfers(c, params)
}

// CreateOwnershipTransfer operation middleware
func (siw *ServerInterfaceWrapper) CreateOwnershipTransfer(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateOwnershipTransfer(c)
}

// DeleteTransfer operation middleware
func (siw *ServerInterfaceWrapper) DeleteTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTransfer(c, transferId)
}

// GetTransfer operation middleware
func (siw *ServerInterfaceWrapper) GetTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTransfer(c, transferId)
}

// AcceptTransfer operation middleware
func (siw *ServerInterfaceWrapper) AcceptTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AcceptTransfer(c, transferId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/attachments", wrapper.UploadAttachment)
	router.GET(options.BaseURL+"/v1/attachments/download/:token/:filename", wrapper.DownloadAttachmentByToken)
	router.DELETE(options.BaseURL+"/v1/attachments/:id", wrapper.DeleteAttachment)
	router.GET(options.BaseURL+"/v1/attachments/:id", wrapper.GetAttachment)
	router.GET(options.BaseURL+"/v1/attachments/:id/download-url", wrapper.GetAttachmentDownloadUrl)
	router.GET(options.BaseURL+"/v1/conversations", wrapper.ListConversations)
	router.POST(options.BaseURL+"/v1/conversations", wrapper.CreateConversation)
	router.POST(options.BaseURL+"/v1/conversations/index", wrapper.IndexConversations)
	router.POST(options.BaseURL+"/v1/conversations/search", wrapper.SearchConversations)
	router.GET(options.BaseURL+"/v1/conversations/unindexed", wrapper.ListUnindexedEntries)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId", wrapper.DeleteConversation)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId", wrapper.GetConversation)
	router.PATCH(options.BaseURL+"/v1/conversations/:conversationId", wrapper.UpdateConversation)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/entries", wrapper.ListConversationEntries)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/entries", wrapper.AppendConversationEntry)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/entries/sync", wrapper.SyncConversationMemory)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/forks", wrapper.ListConversationForks)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/memberships", wrapper.ListConversationMemberships)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/memberships", wrapper.ShareConversation)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId/memberships/:userId", wrapper.DeleteConversationMembership)
	router.PATCH(options.BaseURL+"/v1/conversations/:conversationId/memberships/:userId", wrapper.UpdateConversationMembership)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId/response", wrapper.DeleteConversationResponse)
	router.GET(options.BaseURL+"/v1/ownership-transfers", wrapper.ListPendingTransfers)
	router.POST(options.BaseURL+"/v1/ownership-transfers", wrapper.CreateOwnershipTransfer)
	router.DELETE(options.BaseURL+"/v1/ownership-transfers/:transferId", wrapper.DeleteTransfer)
	router.GET(options.BaseURL+"/v1/ownership-transfers/:transferId", wrapper.GetTransfer)
	router.POST(options.BaseURL+"/v1/ownership-transfers/:transferId/accept", wrapper.AcceptTransfer)
}

type ErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type SearchTypeUnavailableJSONResponse SearchTypeUnavailableError

type UploadAttachmentRequestObject struct {
	Params        UploadAttachmentParams
	JSONBody      *UploadAttachmentJSONRequestBody
	MultipartBody *multipart.Reader
}

type UploadAttachmentResponseObject interface {
	VisitUploadAttachmentResponse(w http.ResponseWriter) error
}

type UploadAttachment201JSONResponse AttachmentUploadResponse

func (response UploadAttachment201JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachment400JSONResponse struct{ ErrorJSONResponse }

func (response UploadAttachment400JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachment413JSONResponse ErrorResponse

func (response UploadAttachment413JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UploadAttachmentdefaultJSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DownloadAttachmentByTokenRequestObject struct {
	Token    string `json:"token"`
	Filename string `json:"filename"`
}

type DownloadAttachmentByTokenResponseObject interface {
	VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error
}

type DownloadAttachmentByToken200ResponseHeaders struct {
	CacheControl string
}

type DownloadAttachmentByToken200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       DownloadAttachmentByToken200ResponseHeaders
	ContentLength int64
}

func (response DownloadAttachmentByToken200ApplicationoctetStreamResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DownloadAttachmentByToken403Response struct {
}

func (response DownloadAttachmentByToken403Response) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DownloadAttachmentByToken404JSONResponse struct{ NotFoundJSONResponse }

func (response DownloadAttachmentByToken404JSONResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DownloadAttachmentByTokendefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DownloadAttachmentByTokendefaultJSONResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAttachmentRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type DeleteAttachmentResponseObject interface {
	VisitDeleteAttachmentResponse(w http.ResponseWriter) error
}

type DeleteAttachment204Response struct {
}

func (response DeleteAttachment204Response) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteAttachment403JSONResponse struct{ ErrorJSONResponse }

func (response DeleteAttachment403JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachment404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteAttachment404JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachment409JSONResponse ErrorResponse

func (response DeleteAttachment409JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteAttachmentdefaultJSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAttachmentRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type GetAttachmentResponseObject interface {
	VisitGetAttachmentResponse(w http.ResponseWriter) error
}

type GetAttachment200ResponseHeaders struct {
	CacheControl string
}

type GetAttachment200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetAttachment200ResponseHeaders
	ContentLength int64
}

func (response GetAttachment200ApplicationoctetStreamResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetAttachment302ResponseHeaders struct {
	CacheControl string
}

type GetAttachment302Response struct {
	Headers GetAttachment302ResponseHeaders
}

func (response GetAttachment302Response) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(302)
	return nil
}

type GetAttachment403JSONResponse struct{ ErrorJSONResponse }

func (response GetAttachment403JSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachment404JSONResponse struct{ NotFoundJSONResponse }

func (response GetAttachment404JSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetAttachmentdefaultJSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAttachmentDownloadUrlRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type GetAttachmentDownloadUrlResponseObject interface {
	VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error
}

type GetAttachmentDownloadUrl200JSONResponse AttachmentDownloadUrlResponse

func (response GetAttachmentDownloadUrl200JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrl403JSONResponse struct{ ErrorJSONResponse }

func (response GetAttachmentDownloadUrl403JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrl404JSONResponse struct{ NotFoundJSONResponse }

func (response GetAttachmentDownloadUrl404JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrldefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetAttachmentDownloadUrldefaultJSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationsRequestObject struct {
	Params ListConversationsParams
}

type ListConversationsResponseObject interface {
	VisitListConversationsResponse(w http.ResponseWriter) error
}

type ListConversations200JSONResponse struct {
	AfterCursor *string                `json:"afterCursor"`
	Data        *[]ConversationSummary `json:"data,omitempty"`
}

func (response ListConversations200JSONResponse) VisitListConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationsdefaultJSONResponse) VisitListConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateConversationRequestObject struct {
	Body *CreateConversationJSONRequestBody
}

type CreateConversationResponseObject interface {
	VisitCreateConversationResponse(w http.ResponseWriter) error
}

type CreateConversation201JSONResponse Conversation

func (response CreateConversation201JSONResponse) VisitCreateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response CreateConversationdefaultJSONResponse) VisitCreateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type IndexConversationsRequestObject struct {
	Body *IndexConversationsJSONRequestBody
}

type IndexConversationsResponseObject interface {
	VisitIndexConversationsResponse(w http.ResponseWriter) error
}

type IndexConversations200JSONResponse IndexConversationsResponse

func (response IndexConversations200JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversations403JSONResponse struct{ ErrorJSONResponse }

func (response IndexConversations403JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversations404JSONResponse struct{ NotFoundJSONResponse }

func (response IndexConversations404JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response IndexConversationsdefaultJSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchConversationsRequestObject struct {
	Body *SearchConversationsJSONRequestBody
}

type SearchConversationsResponseObject interface {
	VisitSearchConversationsResponse(w http.ResponseWriter) error
}

type SearchConversations200JSONResponse struct {
	AfterCursor *string         `json:"afterCursor"`
	Data        *[]SearchResult `json:"data,omitempty"`
}

func (response SearchConversations200JSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SearchConversations501JSONResponse struct {
	SearchTypeUnavailableJSONResponse
}

func (response SearchConversations501JSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type SearchConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response SearchConversationsdefaultJSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListUnindexedEntriesRequestObject struct {
	Params ListUnindexedEntriesParams
}

type ListUnindexedEntriesResponseObject interface {
	VisitListUnindexedEntriesResponse(w http.ResponseWriter) error
}

type ListUnindexedEntries200JSONResponse UnindexedEntriesResponse

func (response ListUnindexedEntries200JSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUnindexedEntries403JSONResponse struct{ ErrorJSONResponse }

func (response ListUnindexedEntries403JSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUnindexedEntriesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListUnindexedEntriesdefaultJSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type DeleteConversationResponseObject interface {
	VisitDeleteConversationResponse(w http.ResponseWriter) error
}

type DeleteConversation204Response struct {
}

func (response DeleteConversation204Response) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversation404JSONResponse) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationdefaultJSONResponse) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type GetConversationResponseObject interface {
	VisitGetConversationResponse(w http.ResponseWriter) error
}

type GetConversation200JSONResponse Conversation

func (response GetConversation200JSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConversation404JSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConversationdefaultJSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *UpdateConversationJSONRequestBody
}

type UpdateConversationResponseObject interface {
	VisitUpdateConversationResponse(w http.ResponseWriter) error
}

type UpdateConversation200JSONResponse Conversation

func (response UpdateConversation200JSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateConversation404JSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UpdateConversationdefaultJSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationEntriesRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationEntriesParams
}

type ListConversationEntriesResponseObject interface {
	VisitListConversationEntriesResponse(w http.ResponseWriter) error
}

type ListConversationEntries200JSONResponse struct {
	AfterCursor *string  `json:"afterCursor"`
	Data        *[]Entry `json:"data,omitempty"`
}

func (response ListConversationEntries200JSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationEntries404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationEntries404JSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationEntriesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationEntriesdefaultJSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AppendConversationEntryRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *AppendConversationEntryJSONRequestBody
}

type AppendConversationEntryResponseObject interface {
	VisitAppendConversationEntryResponse(w http.ResponseWriter) error
}

type AppendConversationEntry201JSONResponse Entry

func (response AppendConversationEntry201JSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AppendConversationEntry404JSONResponse struct{ NotFoundJSONResponse }

func (response AppendConversationEntry404JSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AppendConversationEntrydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response AppendConversationEntrydefaultJSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SyncConversationMemoryRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *SyncConversationMemoryJSONRequestBody
}

type SyncConversationMemoryResponseObject interface {
	VisitSyncConversationMemoryResponse(w http.ResponseWriter) error
}

type SyncConversationMemory200JSONResponse SyncEntryResponse

func (response SyncConversationMemory200JSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SyncConversationMemory404JSONResponse struct{ NotFoundJSONResponse }

func (response SyncConversationMemory404JSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type SyncConversationMemorydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response SyncConversationMemorydefaultJSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationForksRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationForksParams
}

type ListConversationForksResponseObject interface {
	VisitListConversationForksResponse(w http.ResponseWriter) error
}

type ListConversationForks200JSONResponse struct {
	AfterCursor *string                    `json:"afterCursor"`
	Data        *[]ConversationForkSummary `json:"data,omitempty"`
}

func (response ListConversationForks200JSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationForks404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationForks404JSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationForksdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationForksdefaultJSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationMembershipsRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationMembershipsParams
}

type ListConversationMembershipsResponseObject interface {
	VisitListConversationMembershipsResponse(w http.ResponseWriter) error
}

type ListConversationMemberships200JSONResponse struct {
	AfterCursor *string                   `json:"afterCursor"`
	Data        *[]ConversationMembership `json:"data,omitempty"`
}

func (response ListConversationMemberships200JSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationMemberships404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationMemberships404JSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationMembershipsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationMembershipsdefaultJSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ShareConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *ShareConversationJSONRequestBody
}

type ShareConversationResponseObject interface {
	VisitShareConversationResponse(w http.ResponseWriter) error
}

type ShareConversation201JSONResponse ConversationMembership

func (response ShareConversation201JSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type ShareConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response ShareConversation404JSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShareConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ShareConversationdefaultJSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationMembershipRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	UserId         string             `json:"userId"`
}

type DeleteConversationMembershipResponseObject interface {
	VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error
}

type DeleteConversationMembership204Response struct {
}

func (response DeleteConversationMembership204Response) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConversationMembership404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversationMembership404JSONResponse) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationMembershipdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationMembershipdefaultJSONResponse) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateConversationMembershipRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	UserId         string             `json:"userId"`
	Body           *UpdateConversationMembershipJSONRequestBody
}

type UpdateConversationMembershipResponseObject interface {
	VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error
}

type UpdateConversationMembership200JSONResponse ConversationMembership

func (response UpdateConversationMembership200JSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationMembership404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateConversationMembership404JSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationMembershipdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UpdateConversationMembershipdefaultJSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationResponseRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type DeleteConversationResponseResponseObject interface {
	VisitDeleteConversationResponseResponse(w http.ResponseWriter) error
}

type DeleteConversationResponse200Response struct {
}

func (response DeleteConversationResponse200Response) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteConversationResponse404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversationResponse404JSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationResponse409JSONResponse struct{ ErrorJSONResponse }

func (response DeleteConversationResponse409JSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationResponsedefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationResponsedefaultJSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListPendingTransfersRequestObject struct {
	Params ListPendingTransfersParams
}

type ListPendingTransfersResponseObject interface {
	VisitListPendingTransfersResponse(w http.ResponseWriter) error
}

type ListPendingTransfers200JSONResponse struct {
	AfterCursor *string              `json:"afterCursor"`
	Data        *[]OwnershipTransfer `json:"data,omitempty"`
}

func (response ListPendingTransfers200JSONResponse) VisitListPendingTransfersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPendingTransfersdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListPendingTransfersdefaultJSONResponse) VisitListPendingTransfersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateOwnershipTransferRequestObject struct {
	Body *CreateOwnershipTransferJSONRequestBody
}

type CreateOwnershipTransferResponseObject interface {
	VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error
}

type CreateOwnershipTransfer201JSONResponse OwnershipTransfer

func (response CreateOwnershipTransfer201JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer400JSONResponse struct{ ErrorJSONResponse }

func (response CreateOwnershipTransfer400JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer403JSONResponse ErrorResponse

func (response CreateOwnershipTransfer403JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateOwnershipTransfer404JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer409JSONResponse struct {
	Code  *string `json:"code,omitempty"`
	Error *string `json:"error,omitempty"`

	// ExistingTransferId ID of the existing pending transfer
	ExistingTransferId *openapi_types.UUID `json:"existingTransferId,omitempty"`
}

func (response CreateOwnershipTransfer409JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response CreateOwnershipTransferdefaultJSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type DeleteTransferResponseObject interface {
	VisitDeleteTransferResponse(w http.ResponseWriter) error
}

type DeleteTransfer204Response struct {
}

func (response DeleteTransfer204Response) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteTransfer403JSONResponse struct{ ErrorJSONResponse }

func (response DeleteTransfer403JSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteTransfer404JSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteTransferdefaultJSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type GetTransferResponseObject interface {
	VisitGetTransferResponse(w http.ResponseWriter) error
}

type GetTransfer200JSONResponse OwnershipTransfer

func (response GetTransfer200JSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response GetTransfer404JSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetTransferdefaultJSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AcceptTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type AcceptTransferResponseObject interface {
	VisitAcceptTransferResponse(w http.ResponseWriter) error
}

type AcceptTransfer204Response struct {
}

func (response AcceptTransfer204Response) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AcceptTransfer403JSONResponse struct{ ErrorJSONResponse }

func (response AcceptTransfer403JSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AcceptTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response AcceptTransfer404JSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AcceptTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response AcceptTransferdefaultJSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload or create an attachment
	// (POST /v1/attachments)
	UploadAttachment(ctx context.Context, request UploadAttachmentRequestObject) (UploadAttachmentResponseObject, error)
	// Download an attachment via signed token
	// (GET /v1/attachments/download/{token}/{filename})
	DownloadAttachmentByToken(ctx context.Context, request DownloadAttachmentByTokenRequestObject) (DownloadAttachmentByTokenResponseObject, error)
	// Delete an unlinked attachment
	// (DELETE /v1/attachments/{id})
	DeleteAttachment(ctx context.Context, request DeleteAttachmentRequestObject) (DeleteAttachmentResponseObject, error)
	// Retrieve an attachment
	// (GET /v1/attachments/{id})
	GetAttachment(ctx context.Context, request GetAttachmentRequestObject) (GetAttachmentResponseObject, error)
	// Get a signed download URL for an attachment
	// (GET /v1/attachments/{id}/download-url)
	GetAttachmentDownloadUrl(ctx context.Context, request GetAttachmentDownloadUrlRequestObject) (GetAttachmentDownloadUrlResponseObject, error)
	// List conversations visible to current user
	// (GET /v1/conversations)
	ListConversations(ctx context.Context, request ListConversationsRequestObject) (ListConversationsResponseObject, error)
	// Create a conversation
	// (POST /v1/conversations)
	CreateConversation(ctx context.Context, request CreateConversationRequestObject) (CreateConversationResponseObject, error)
	// Index conversation entries
	// (POST /v1/conversations/index)
	IndexConversations(ctx context.Context, request IndexConversationsRequestObject) (IndexConversationsResponseObject, error)
	// Semantic search across conversations
	// (POST /v1/conversations/search)
	SearchConversations(ctx context.Context, request SearchConversationsRequestObject) (SearchConversationsResponseObject, error)
	// List entries needing indexing
	// (GET /v1/conversations/unindexed)
	ListUnindexedEntries(ctx context.Context, request ListUnindexedEntriesRequestObject) (ListUnindexedEntriesResponseObject, error)
	// Delete a conversation
	// (DELETE /v1/conversations/{conversationId})
	DeleteConversation(ctx context.Context, request DeleteConversationRequestObject) (DeleteConversationResponseObject, error)
	// Get a conversation
	// (GET /v1/conversations/{conversationId})
	GetConversation(ctx context.Context, request GetConversationRequestObject) (GetConversationResponseObject, error)
	// Update a conversation
	// (PATCH /v1/conversations/{conversationId})
	UpdateConversation(ctx context.Context, request UpdateConversationRequestObject) (UpdateConversationResponseObject, error)
	// List conversation entries
	// (GET /v1/conversations/{conversationId}/entries)
	ListConversationEntries(ctx context.Context, request ListConversationEntriesRequestObject) (ListConversationEntriesResponseObject, error)
	// Append an entry
	// (POST /v1/conversations/{conversationId}/entries)
	AppendConversationEntry(ctx context.Context, request AppendConversationEntryRequestObject) (AppendConversationEntryResponseObject, error)
	// Synchronize the agent memory epoch
	// (POST /v1/conversations/{conversationId}/entries/sync)
	SyncConversationMemory(ctx context.Context, request SyncConversationMemoryRequestObject) (SyncConversationMemoryResponseObject, error)
	// List forks for a conversation
	// (GET /v1/conversations/{conversationId}/forks)
	ListConversationForks(ctx context.Context, request ListConversationForksRequestObject) (ListConversationForksResponseObject, error)
	// List conversation memberships
	// (GET /v1/conversations/{conversationId}/memberships)
	ListConversationMemberships(ctx context.Context, request ListConversationMembershipsRequestObject) (ListConversationMembershipsResponseObject, error)
	// Share conversation with another user
	// (POST /v1/conversations/{conversationId}/memberships)
	ShareConversation(ctx context.Context, request ShareConversationRequestObject) (ShareConversationResponseObject, error)
	// Remove a member from the conversation
	// (DELETE /v1/conversations/{conversationId}/memberships/{userId})
	DeleteConversationMembership(ctx context.Context, request DeleteConversationMembershipRequestObject) (DeleteConversationMembershipResponseObject, error)
	// Update a member's access level
	// (PATCH /v1/conversations/{conversationId}/memberships/{userId})
	UpdateConversationMembership(ctx context.Context, request UpdateConversationMembershipRequestObject) (UpdateConversationMembershipResponseObject, error)
	// Cancel an in-progress response
	// (DELETE /v1/conversations/{conversationId}/response)
	DeleteConversationResponse(ctx context.Context, request DeleteConversationResponseRequestObject) (DeleteConversationResponseResponseObject, error)
	// List pending ownership transfers
	// (GET /v1/ownership-transfers)
	ListPendingTransfers(ctx context.Context, request ListPendingTransfersRequestObject) (ListPendingTransfersResponseObject, error)
	// Request ownership transfer
	// (POST /v1/ownership-transfers)
	CreateOwnershipTransfer(ctx context.Context, request CreateOwnershipTransferRequestObject) (CreateOwnershipTransferResponseObject, error)
	// Cancel or reject ownership transfer
	// (DELETE /v1/ownership-transfers/{transferId})
	DeleteTransfer(ctx context.Context, request DeleteTransferRequestObject) (DeleteTransferResponseObject, error)
	// Get transfer details
	// (GET /v1/ownership-transfers/{transferId})
	GetTransfer(ctx context.Context, request GetTransferRequestObject) (GetTransferResponseObject, error)
	// Accept ownership transfer
	// (POST /v1/ownership-transfers/{transferId}/accept)
	AcceptTransfer(ctx context.Context, request AcceptTransferRequestObject) (AcceptTransferResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadAttachment operation middleware
func (sh *strictHandler) UploadAttachment(ctx *gin.Context, params UploadAttachmentParams) {
	var request UploadAttachmentRequestObject

	request.Params = params
	if strings.HasPrefix(ctx.GetHeader("Content-Type"), "application/json") {

		var body UploadAttachmentJSONRequestBody
		if err := ctx.ShouldBindJSON(&body); err != nil {
			ctx.Status(http.StatusBadRequest)
			ctx.Error(err)
			return
		}
		request.JSONBody = &body
	}
	if strings.HasPrefix(ctx.GetHeader("Content-Type"), "multipart/form-data") {
		if reader, err := ctx.Request.MultipartReader(); err == nil {
			request.MultipartBody = reader
		} else {
			ctx.Error(err)
			return
		}
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadAttachment(ctx, request.(UploadAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadAttachmentResponseObject); ok {
		if err := validResponse.VisitUploadAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadAttachmentByToken operation middleware
func (sh *strictHandler) DownloadAttachmentByToken(ctx *gin.Context, token string, filename string) {
	var request DownloadAttachmentByTokenRequestObject

	request.Token = token
	request.Filename = filename

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadAttachmentByToken(ctx, request.(DownloadAttachmentByTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadAttachmentByToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DownloadAttachmentByTokenResponseObject); ok {
		if err := validResponse.VisitDownloadAttachmentByTokenResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteAttachment operation middleware
func (sh *strictHandler) DeleteAttachment(ctx *gin.Context, id openapi_types.UUID) {
	var request DeleteAttachmentRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteAttachment(ctx, request.(DeleteAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteAttachmentResponseObject); ok {
		if err := validResponse.VisitDeleteAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAttachment operation middleware
func (sh *strictHandler) GetAttachment(ctx *gin.Context, id openapi_types.UUID) {
	var request GetAttachmentRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAttachment(ctx, request.(GetAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetAttachmentResponseObject); ok {
		if err := validResponse.VisitGetAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAttachmentDownloadUrl operation middleware
func (sh *strictHandler) GetAttachmentDownloadUrl(ctx *gin.Context, id openapi_types.UUID) {
	var request GetAttachmentDownloadUrlRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAttachmentDownloadUrl(ctx, request.(GetAttachmentDownloadUrlRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAttachmentDownloadUrl")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetAttachmentDownloadUrlResponseObject); ok {
		if err := validResponse.VisitGetAttachmentDownloadUrlResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversations operation middleware
func (sh *strictHandler) ListConversations(ctx *gin.Context, params ListConversationsParams) {
	var request ListConversationsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversations(ctx, request.(ListConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationsResponseObject); ok {
		if err := validResponse.VisitListConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateConversation operation middleware
func (sh *strictHandler) CreateConversation(ctx *gin.Context) {
	var request CreateConversationRequestObject

	var body CreateConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConversation(ctx, request.(CreateConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateConversationResponseObject); ok {
		if err := validResponse.VisitCreateConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// IndexConversations operation middleware
func (sh *strictHandler) IndexConversations(ctx *gin.Context) {
	var request IndexConversationsRequestObject

	var body IndexConversationsJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.IndexConversations(ctx, request.(IndexConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "IndexConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(IndexConversationsResponseObject); ok {
		if err := validResponse.VisitIndexConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// SearchConversations operation middleware
func (sh *strictHandler) SearchConversations(ctx *gin.Context) {
	var request SearchConversationsRequestObject

	var body SearchConversationsJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchConversations(ctx, request.(SearchConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SearchConversationsResponseObject); ok {
		if err := validResponse.VisitSearchConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUnindexedEntries operation middleware
func (sh *strictHandler) ListUnindexedEntries(ctx *gin.Context, params ListUnindexedEntriesParams) {
	var request ListUnindexedEntriesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListUnindexedEntries(ctx, request.(ListUnindexedEntriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUnindexedEntries")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListUnindexedEntriesResponseObject); ok {
		if err := validResponse.VisitListUnindexedEntriesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversation operation middleware
func (sh *strictHandler) DeleteConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request DeleteConversationRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversation(ctx, request.(DeleteConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationResponseObject); ok {
		if err := validResponse.VisitDeleteConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConversation operation middleware
func (sh *strictHandler) GetConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request GetConversationRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConversation(ctx, request.(GetConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConversationResponseObject); ok {
		if err := validResponse.VisitGetConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateConversation operation middleware
func (sh *strictHandler) UpdateConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request UpdateConversationRequestObject

	request.ConversationId = conversationId

	var body UpdateConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConversation(ctx, request.(UpdateConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateConversationResponseObject); ok {
		if err := validResponse.VisitUpdateConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationEntries operation middleware
func (sh *strictHandler) ListConversationEntries(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationEntriesParams) {
	var request ListConversationEntriesRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationEntries(ctx, request.(ListConversationEntriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationEntries")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationEntriesResponseObject); ok {
		if err := validResponse.VisitListConversationEntriesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AppendConversationEntry operation middleware
func (sh *strictHandler) AppendConversationEntry(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request AppendConversationEntryRequestObject

	request.ConversationId = conversationId

	var body AppendConversationEntryJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AppendConversationEntry(ctx, request.(AppendConversationEntryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AppendConversationEntry")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AppendConversationEntryResponseObject); ok {
		if err := validResponse.VisitAppendConversationEntryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// SyncConversationMemory operation middleware
func (sh *strictHandler) SyncConversationMemory(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request SyncConversationMemoryRequestObject

	request.ConversationId = conversationId

	var body SyncConversationMemoryJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SyncConversationMemory(ctx, request.(SyncConversationMemoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SyncConversationMemory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SyncConversationMemoryResponseObject); ok {
		if err := validResponse.VisitSyncConversationMemoryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationForks operation middleware
func (sh *strictHandler) ListConversationForks(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationForksParams) {
	var request ListConversationForksRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationForks(ctx, request.(ListConversationForksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationForks")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationForksResponseObject); ok {
		if err := validResponse.VisitListConversationForksResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationMemberships operation middleware
func (sh *strictHandler) ListConversationMemberships(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationMembershipsParams) {
	var request ListConversationMembershipsRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationMemberships(ctx, request.(ListConversationMembershipsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationMemberships")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationMembershipsResponseObject); ok {
		if err := validResponse.VisitListConversationMembershipsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShareConversation operation middleware
func (sh *strictHandler) ShareConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request ShareConversationRequestObject

	request.ConversationId = conversationId

	var body ShareConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ShareConversation(ctx, request.(ShareConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShareConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ShareConversationResponseObject); ok {
		if err := validResponse.VisitShareConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversationMembership operation middleware
func (sh *strictHandler) DeleteConversationMembership(ctx *gin.Context, conversationId openapi_types.UUID, userId string) {
	var request DeleteConversationMembershipRequestObject

	request.ConversationId = conversationId
	request.UserId = userId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversationMembership(ctx, request.(DeleteConversationMembershipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversationMembership")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationMembershipResponseObject); ok {
		if err := validResponse.VisitDeleteConversationMembershipResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateConversationMembership operation middleware
func (sh *strictHandler) UpdateConversationMembership(ctx *gin.Context, conversationId openapi_types.UUID, userId string) {
	var request UpdateConversationMembershipRequestObject

	request.ConversationId = conversationId
	request.UserId = userId

	var body UpdateConversationMembershipJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConversationMembership(ctx, request.(UpdateConversationMembershipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConversationMembership")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateConversationMembershipResponseObject); ok {
		if err := validResponse.VisitUpdateConversationMembershipResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversationResponse operation middleware
func (sh *strictHandler) DeleteConversationResponse(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request DeleteConversationResponseRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversationResponse(ctx, request.(DeleteConversationResponseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversationResponse")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationResponseResponseObject); ok {
		if err := validResponse.VisitDeleteConversationResponseResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPendingTransfers operation middleware
func (sh *strictHandler) ListPendingTransfers(ctx *gin.Context, params ListPendingTransfersParams) {
	var request ListPendingTransfersRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListPendingTransfers(ctx, request.(ListPendingTransfersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPendingTransfers")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListPendingTransfersResponseObject); ok {
		if err := validResponse.VisitListPendingTransfersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateOwnershipTransfer operation middleware
func (sh *strictHandler) CreateOwnershipTransfer(ctx *gin.Context) {
	var request CreateOwnershipTransferRequestObject

	var body CreateOwnershipTransferJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateOwnershipTransfer(ctx, request.(CreateOwnershipTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateOwnershipTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateOwnershipTransferResponseObject); ok {
		if err := validResponse.VisitCreateOwnershipTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteTransfer operation middleware
func (sh *strictHandler) DeleteTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request DeleteTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteTransfer(ctx, request.(DeleteTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteTransferResponseObject); ok {
		if err := validResponse.VisitDeleteTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTransfer operation middleware
func (sh *strictHandler) GetTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request GetTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetTransfer(ctx, request.(GetTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetTransferResponseObject); ok {
		if err := validResponse.VisitGetTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AcceptTransfer operation middleware
func (sh *strictHandler) AcceptTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request AcceptTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AcceptTransfer(ctx, request.(AcceptTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AcceptTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AcceptTransferResponseObject); ok {
		if err := validResponse.VisitAcceptTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

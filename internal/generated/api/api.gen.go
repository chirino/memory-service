// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AccessLevel.
const (
	Manager AccessLevel = "manager"
	Owner   AccessLevel = "owner"
	Reader  AccessLevel = "reader"
	Writer  AccessLevel = "writer"
)

// Defines values for AttachmentUploadResponseStatus.
const (
	Downloading AttachmentUploadResponseStatus = "downloading"
	Failed      AttachmentUploadResponseStatus = "failed"
	Ready       AttachmentUploadResponseStatus = "ready"
	Uploading   AttachmentUploadResponseStatus = "uploading"
)

// Defines values for Channel.
const (
	History Channel = "history"
	Memory  Channel = "memory"
)

// Defines values for MemoryEventItemKind.
const (
	MemoryEventItemKindAdd     MemoryEventItemKind = "add"
	MemoryEventItemKindDelete  MemoryEventItemKind = "delete"
	MemoryEventItemKindExpired MemoryEventItemKind = "expired"
	MemoryEventItemKindUpdate  MemoryEventItemKind = "update"
)

// Defines values for SearchConversationsRequestSearchType.
const (
	Auto     SearchConversationsRequestSearchType = "auto"
	Fulltext SearchConversationsRequestSearchType = "fulltext"
	Semantic SearchConversationsRequestSearchType = "semantic"
)

// Defines values for SearchResultKind.
const (
	Mongo    SearchResultKind = "mongo"
	Pgvector SearchResultKind = "pgvector"
	Postgres SearchResultKind = "postgres"
	Qdrant   SearchResultKind = "qdrant"
)

// Defines values for ListConversationsParamsMode.
const (
	ListConversationsParamsModeAll        ListConversationsParamsMode = "all"
	ListConversationsParamsModeLatestFork ListConversationsParamsMode = "latest-fork"
	ListConversationsParamsModeRoots      ListConversationsParamsMode = "roots"
)

// Defines values for ListConversationEntriesParamsForks.
const (
	ListConversationEntriesParamsForksAll  ListConversationEntriesParamsForks = "all"
	ListConversationEntriesParamsForksNone ListConversationEntriesParamsForks = "none"
)

// Defines values for ListMemoryEventsParamsKinds.
const (
	ListMemoryEventsParamsKindsAdd     ListMemoryEventsParamsKinds = "add"
	ListMemoryEventsParamsKindsDelete  ListMemoryEventsParamsKinds = "delete"
	ListMemoryEventsParamsKindsExpired ListMemoryEventsParamsKinds = "expired"
	ListMemoryEventsParamsKindsUpdate  ListMemoryEventsParamsKinds = "update"
)

// Defines values for ListPendingTransfersParamsRole.
const (
	All       ListPendingTransfersParamsRole = "all"
	Recipient ListPendingTransfersParamsRole = "recipient"
	Sender    ListPendingTransfersParamsRole = "sender"
)

// AccessLevel Access level of a user for a conversation.
type AccessLevel string

// Attachment A reference to an attachment on a history entry. Supports two modes:
//
// **External URL (Phase 1)**: Provide `href` and `contentType` to reference
// an externally-hosted resource.
//
// **Server-stored (Phase 2)**: Provide `attachmentId` to reference a file
// previously uploaded via `POST /v1/attachments`. When the entry is created,
// the server replaces `attachmentId` with an `href` pointing to
// `/v1/attachments/{id}`.
//
// At least one of `href` or `attachmentId` must be present.
type Attachment struct {
	// AttachmentId ID of a previously uploaded attachment (from POST /v1/attachments).
	// When the entry is created, this is replaced with an href.
	AttachmentId *string `json:"attachmentId,omitempty"`

	// ContentType MIME type of the attachment (e.g., "image/jpeg", "audio/mp3"). Required when href is provided directly.
	ContentType *string `json:"contentType,omitempty"`

	// Description Optional alt text or description.
	Description *string `json:"description,omitempty"`

	// Href URL to the attachment resource (external or server-relative).
	Href *string `json:"href,omitempty"`

	// Name Optional display name for the attachment.
	Name *string `json:"name,omitempty"`

	// Sha256 SHA-256 hash of the file content (set by server for uploaded attachments).
	Sha256 *string `json:"sha256,omitempty"`

	// Size File size in bytes (set by server for uploaded attachments).
	Size *int64 `json:"size,omitempty"`
}

// AttachmentDownloadUrlResponse Response containing a signed download URL for an attachment.
type AttachmentDownloadUrlResponse struct {
	// ExpiresIn Number of seconds until the URL expires.
	ExpiresIn *int `json:"expiresIn,omitempty"`

	// Url The signed download URL. May be an absolute S3 URL or a server-relative path.
	Url *string `json:"url,omitempty"`
}

// AttachmentUploadResponse Response from uploading or creating an attachment.
type AttachmentUploadResponse struct {
	// ContentType MIME type of the uploaded file.
	ContentType *string `json:"contentType,omitempty"`

	// ExpiresAt When this unlinked attachment will expire and be deleted.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Filename Original filename of the uploaded file.
	Filename *string `json:"filename"`

	// Href Server-relative URL to retrieve the attachment.
	Href *string `json:"href,omitempty"`

	// Id Unique identifier for the uploaded attachment.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Sha256 SHA-256 hash of the file content (null for URL-created attachments until download completes).
	Sha256 *string `json:"sha256,omitempty"`

	// Size File size in bytes (null for URL-created attachments until download completes).
	Size *int64 `json:"size,omitempty"`

	// SourceUrl Original source URL (only present for URL-created attachments).
	SourceUrl *string `json:"sourceUrl,omitempty"`

	// Status Current status of the attachment:
	// - `uploading` - Multipart upload created but not yet completed
	// - `downloading` - Server is downloading content from sourceUrl
	// - `ready` - Content is available for retrieval
	// - `failed` - Download from sourceUrl failed
	Status *AttachmentUploadResponseStatus `json:"status,omitempty"`
}

// AttachmentUploadResponseStatus Current status of the attachment:
// - `uploading` - Multipart upload created but not yet completed
// - `downloading` - Server is downloading content from sourceUrl
// - `ready` - Content is available for retrieval
// - `failed` - Download from sourceUrl failed
type AttachmentUploadResponseStatus string

// Channel Logical channel of the entry within the conversation.
type Channel string

// Conversation defines model for Conversation.
type Conversation struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`

	// ForkedAtConversationId Conversation ID from which this conversation was forked.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId"`

	// ForkedAtEntryId Entry ID where this conversation forked from its parent.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId"`

	// Id Unique identifier for the conversation.
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	LastMessagePreview *string             `json:"lastMessagePreview"`
	OwnerUserId        *string             `json:"ownerUserId,omitempty"`
	Title              *string             `json:"title"`
	UpdatedAt          *time.Time          `json:"updatedAt,omitempty"`
}

// ConversationForkSummary Summary of a forked conversation originating at a given entry.
type ConversationForkSummary struct {
	// ConversationId Unique identifier for the forked conversation.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	CreatedAt      *time.Time          `json:"createdAt,omitempty"`

	// ForkedAtConversationId Conversation ID where the fork occurred.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId"`

	// ForkedAtEntryId Entry ID at which this forked conversation diverged.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId,omitempty"`
	Title           *string             `json:"title"`
}

// ConversationMembership defines model for ConversationMembership.
type ConversationMembership struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`

	// ConversationId Unique identifier for the conversation.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	CreatedAt      *time.Time          `json:"createdAt,omitempty"`
	UserId         *string             `json:"userId,omitempty"`
}

// ConversationSummary defines model for ConversationSummary.
type ConversationSummary struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`

	// Id Unique identifier for the conversation.
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	LastMessagePreview *string             `json:"lastMessagePreview"`
	OwnerUserId        *string             `json:"ownerUserId,omitempty"`
	Title              *string             `json:"title"`
	UpdatedAt          *time.Time          `json:"updatedAt,omitempty"`
}

// CreateConversationRequest defines model for CreateConversationRequest.
type CreateConversationRequest struct {
	// Id Optional client-supplied UUID for the conversation. When provided, the server creates the conversation with exactly this ID instead of generating one. Useful for agents that need a deterministic conversation ID derived from an external thread identifier.
	Id       *openapi_types.UUID     `json:"id"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Title    *string                 `json:"title"`
}

// CreateEntryRequest defines model for CreateEntryRequest.
type CreateEntryRequest struct {
	// Channel Logical channel of the entry within the conversation.
	Channel *Channel `json:"channel,omitempty"`

	// Content For history channel entries (contentType: `"history"` or `"history/<subtype>"`), each block
	// contains `role` and at least one of `text`, `events`, or `attachments`.
	Content []interface{} `json:"content"`

	// ContentType Describes the schema/format of the content array.
	//
	// **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
	//
	// Supported content types:
	// - `history` - Simple text-only history entries
	// - `history/lc4j` - LangChain4j rich event format (Quarkus)
	//
	// The content array for history entries must contain exactly 1 object with:
	// - `role` (string, required): Either `"USER"` or `"AI"`.
	// - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
	// - `events` (array, optional): Rich event objects for streaming details.
	//   Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
	//   - `PartialResponse`: Text chunk (`{eventType, chunk}`)
	//   - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
	//   - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
	//   - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
	// - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
	//
	// Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
	// agent memory entries.
	ContentType string `json:"contentType"`

	// ForkedAtConversationId If the target conversation doesn't exist yet, auto-create it as a fork of this conversation. Ignored when the conversation already exists.
	ForkedAtConversationId *openapi_types.UUID `json:"forkedAtConversationId,omitempty"`

	// ForkedAtEntryId Entry ID marking the fork point. Entries before this point are inherited; entries at and after this point are excluded. Required when forkedAtConversationId is set.
	ForkedAtEntryId *openapi_types.UUID `json:"forkedAtEntryId,omitempty"`

	// IndexedContent Optional text to index for search. Only valid for entries in the history
	// channel. If provided, the entry will be indexed for search immediately
	// after creation. Returns 400 Bad Request if specified for non-history channels.
	IndexedContent *string `json:"indexedContent"`

	// UserId Human user this entry is associated with.
	// For history entries authored by a user, this is the sender.
	// For agent entries, this is the user the agent is responding to.
	UserId *string `json:"userId"`
}

// CreateFromUrlRequest Request to create an attachment from a source URL.
type CreateFromUrlRequest struct {
	// ContentType MIME type of the content. Defaults to application/octet-stream.
	ContentType *string `json:"contentType,omitempty"`

	// Name Display name for the attachment.
	Name *string `json:"name,omitempty"`

	// SourceUrl URL of the content to download and store as an attachment.
	SourceUrl string `json:"sourceUrl"`
}

// CreateOwnershipTransferRequest defines model for CreateOwnershipTransferRequest.
type CreateOwnershipTransferRequest struct {
	// ConversationId The conversation to transfer ownership of.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// NewOwnerUserId User ID of the proposed new owner. Must be an existing member.
	NewOwnerUserId string `json:"newOwnerUserId"`
}

// Entry defines model for Entry.
type Entry struct {
	// Channel Logical channel of the entry within the conversation.
	Channel Channel `json:"channel"`

	// Content Opaque, agent-defined content blocks.
	// Different agents may use different schemas; the memory-service
	// stores and returns them without interpretation.
	//
	// For history channel entries (contentType: `"history"`), each block
	// contains `role` and at least one of `text`, `events`, or `attachments`.
	Content []interface{} `json:"content"`

	// ContentType Describes the schema/format of the content array.
	//
	// **History channel entries must use `"history"` or `"history/<subtype>"` as the contentType.**
	//
	// Supported content types:
	// - `history` - Simple text-only history entries
	// - `history/lc4j` - LangChain4j rich event format (Quarkus)
	//
	// The content array for history entries contains objects with:
	// - `role` (string, required): Either `"USER"` or `"AI"`.
	// - `text` (string, optional): The message text. At least one of `text`, `events`, or `attachments` must be present.
	// - `events` (array, optional): Rich event objects for streaming details.
	//   Event structure is not validated by the server. For `history/lc4j`, events use an `eventType` field:
	//   - `PartialResponse`: Text chunk (`{eventType, chunk}`)
	//   - `PartialThinking`: Reasoning chunk (`{eventType, chunk}`)
	//   - `BeforeToolExecution`: Before tool call (`{eventType, toolName, input}`)
	//   - `ToolExecuted`: Tool result (`{eventType, toolName, output}`)
	// - `attachments` (array, optional): Array of `Attachment` objects referencing external resources (images, audio, video, documents).
	//
	// Other contentTypes (e.g., `"LC4J"`, `"SpringAI"`) may be used for
	// agent memory entries.
	ContentType string `json:"contentType"`

	// ConversationId Unique identifier for the conversation this entry belongs to.
	ConversationId openapi_types.UUID `json:"conversationId"`
	CreatedAt      time.Time          `json:"createdAt"`

	// Epoch Logical memory epoch this entry belongs to.
	// For history entries this is typically null. For memory entries,
	// the agent increments the epoch when starting a new memory version.
	Epoch *int64 `json:"epoch"`

	// Id Unique identifier for the entry.
	Id openapi_types.UUID `json:"id"`

	// UserId Human user this entry is associated with.
	// For history entries authored by a user, this is the sender.
	// For agent entries, this is the user the agent is responding to.
	UserId *string `json:"userId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
}

// IndexConversationsResponse defines model for IndexConversationsResponse.
type IndexConversationsResponse struct {
	// Indexed Number of entries processed. These entries have their indexed content
	// stored and will be searchable. If vector store indexing failed for some
	// entries, they will become searchable asynchronously via background retry.
	Indexed *int `json:"indexed,omitempty"`
}

// IndexEntryRequest defines model for IndexEntryRequest.
type IndexEntryRequest struct {
	// ConversationId The conversation containing the entry.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// EntryId The entry ID to index.
	EntryId openapi_types.UUID `json:"entryId"`

	// IndexedContent The searchable text for this entry.
	IndexedContent string `json:"indexedContent"`
}

// ListMemoryEventsResponse defines model for ListMemoryEventsResponse.
type ListMemoryEventsResponse struct {
	AfterCursor *string            `json:"after_cursor"`
	Events      *[]MemoryEventItem `json:"events,omitempty"`
}

// ListMemoryNamespacesResponse defines model for ListMemoryNamespacesResponse.
type ListMemoryNamespacesResponse struct {
	Namespaces *[][]string `json:"namespaces,omitempty"`
}

// MemoryEventItem defines model for MemoryEventItem.
type MemoryEventItem struct {
	Attributes *map[string]interface{} `json:"attributes"`
	ExpiresAt  *time.Time              `json:"expires_at"`
	Id         *openapi_types.UUID     `json:"id,omitempty"`
	Key        *string                 `json:"key,omitempty"`
	Kind       *MemoryEventItemKind    `json:"kind,omitempty"`
	Namespace  *[]string               `json:"namespace,omitempty"`
	OccurredAt *time.Time              `json:"occurred_at,omitempty"`
	Value      *map[string]interface{} `json:"value"`
}

// MemoryEventItemKind defines model for MemoryEventItem.Kind.
type MemoryEventItemKind string

// MemoryItem defines model for MemoryItem.
type MemoryItem struct {
	Attributes *map[string]interface{} `json:"attributes,omitempty"`
	CreatedAt  *time.Time              `json:"createdAt,omitempty"`
	ExpiresAt  *time.Time              `json:"expiresAt"`
	Id         *openapi_types.UUID     `json:"id,omitempty"`
	Key        *string                 `json:"key,omitempty"`
	Namespace  *[]string               `json:"namespace,omitempty"`
	Score      *float64                `json:"score"`
	Value      *map[string]interface{} `json:"value,omitempty"`
}

// MemoryWriteResult defines model for MemoryWriteResult.
type MemoryWriteResult struct {
	Attributes *map[string]interface{} `json:"attributes,omitempty"`
	CreatedAt  *time.Time              `json:"createdAt,omitempty"`
	ExpiresAt  *time.Time              `json:"expiresAt"`
	Id         *openapi_types.UUID     `json:"id,omitempty"`
	Key        *string                 `json:"key,omitempty"`
	Namespace  *[]string               `json:"namespace,omitempty"`
}

// OwnershipTransfer Represents a pending ownership transfer request.
// Transfers are always "pending" while they exist; accepted/rejected transfers
// are hard deleted from the database.
type OwnershipTransfer struct {
	// ConversationId The conversation being transferred.
	ConversationId openapi_types.UUID `json:"conversationId"`

	// ConversationTitle Title of the conversation (for display purposes).
	ConversationTitle *string `json:"conversationTitle"`

	// CreatedAt When the transfer was initiated.
	CreatedAt time.Time `json:"createdAt"`

	// FromUserId Current owner initiating the transfer.
	FromUserId string `json:"fromUserId"`

	// Id Unique identifier for the transfer.
	Id openapi_types.UUID `json:"id"`

	// ToUserId Proposed new owner (recipient).
	ToUserId string `json:"toUserId"`
}

// PutMemoryRequest defines model for PutMemoryRequest.
type PutMemoryRequest struct {
	Attributes    *map[string]interface{} `json:"attributes,omitempty"`
	IndexDisabled *bool                   `json:"index_disabled,omitempty"`
	IndexFields   *[]string               `json:"index_fields,omitempty"`
	Key           string                  `json:"key"`
	Namespace     []string                `json:"namespace"`
	TtlSeconds    *int                    `json:"ttl_seconds,omitempty"`
	Value         map[string]interface{}  `json:"value"`
}

// SearchConversationsRequest defines model for SearchConversationsRequest.
type SearchConversationsRequest struct {
	// AfterCursor Cursor for pagination; returns items after this result.
	AfterCursor *string `json:"afterCursor"`

	// GroupByConversation When true (default), groups results by conversation and returns only
	// the highest-scoring entry per conversation. When false, returns all
	// matching entries ordered by score.
	GroupByConversation *bool `json:"groupByConversation,omitempty"`

	// IncludeEntry Whether to include the full entry in results. Set to false to reduce response size when only metadata is needed.
	IncludeEntry *bool `json:"includeEntry,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `json:"limit,omitempty"`

	// Query Natural language query.
	Query string `json:"query"`

	// SearchType The search method to use:
	// - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
	// - `semantic`: Use only vector/embedding-based semantic search
	// - `fulltext`: Use only PostgreSQL full-text search with GIN index
	//
	// If the requested search type is not available on the server, a 501 (Not Implemented)
	// error is returned with details about which search types are available.
	SearchType *SearchConversationsRequestSearchType `json:"searchType,omitempty"`
}

// SearchConversationsRequestSearchType The search method to use:
// - `auto` (default): Try semantic (vector) search first, fall back to full-text if no results or unavailable
// - `semantic`: Use only vector/embedding-based semantic search
// - `fulltext`: Use only PostgreSQL full-text search with GIN index
//
// If the requested search type is not available on the server, a 501 (Not Implemented)
// error is returned with details about which search types are available.
type SearchConversationsRequestSearchType string

// SearchMemoriesRequest defines model for SearchMemoriesRequest.
type SearchMemoriesRequest struct {
	Filter          *map[string]interface{} `json:"filter,omitempty"`
	Limit           *int                    `json:"limit,omitempty"`
	NamespacePrefix []string                `json:"namespace_prefix"`
	Offset          *int                    `json:"offset,omitempty"`
	Query           *string                 `json:"query,omitempty"`
}

// SearchMemoriesResponse defines model for SearchMemoriesResponse.
type SearchMemoriesResponse struct {
	Items *[]MemoryItem `json:"items,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// ConversationId Unique identifier of the conversation containing this entry.
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`

	// ConversationTitle Title of the conversation containing this entry.
	ConversationTitle *string `json:"conversationTitle,omitempty"`

	// Entry The matched entry. Only included when includeEntry is true in the request.
	Entry *Entry `json:"entry,omitempty"`

	// EntryId ID of the matched entry. Always present for deep-linking.
	EntryId    *openapi_types.UUID `json:"entryId,omitempty"`
	Highlights *string             `json:"highlights"`

	// Kind Identifies which search backend produced the score (e.g. `postgres`, `mongo`, `qdrant`, `pgvector`).
	Kind *SearchResultKind `json:"kind,omitempty"`

	// Score Relevance score. Higher is more relevant.
	Score *float32 `json:"score,omitempty"`
}

// SearchResultKind Identifies which search backend produced the score (e.g. `postgres`, `mongo`, `qdrant`, `pgvector`).
type SearchResultKind string

// SearchTypeUnavailableError Error response when the requested search type is not available on the server.
type SearchTypeUnavailableError struct {
	// AvailableTypes List of search types that are available on this server.
	AvailableTypes *[]string `json:"availableTypes,omitempty"`

	// Error Error code.
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message.
	Message *string `json:"message,omitempty"`
}

// ShareConversationRequest defines model for ShareConversationRequest.
type ShareConversationRequest struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel AccessLevel `json:"accessLevel"`
	CreatedAt   *time.Time  `json:"createdAt,omitempty"`
	UserId      string      `json:"userId"`
}

// SyncEntryResponse defines model for SyncEntryResponse.
type SyncEntryResponse struct {
	Entry *Entry `json:"entry,omitempty"`

	// Epoch The epoch number that now reflects the stored memory state.
	Epoch *int64 `json:"epoch"`

	// EpochIncremented True when the provided list diverged and a new epoch was started.
	EpochIncremented *bool `json:"epochIncremented,omitempty"`

	// NoOp True when the request resulted in no stored changes.
	NoOp *bool `json:"noOp,omitempty"`
}

// UnindexedEntriesResponse defines model for UnindexedEntriesResponse.
type UnindexedEntriesResponse struct {
	// AfterCursor Cursor for fetching next page. Null when no more results.
	AfterCursor *string           `json:"afterCursor"`
	Data        *[]UnindexedEntry `json:"data,omitempty"`
}

// UnindexedEntry defines model for UnindexedEntry.
type UnindexedEntry struct {
	ConversationId *openapi_types.UUID `json:"conversationId,omitempty"`
	Entry          *Entry              `json:"entry,omitempty"`
}

// UpdateConversationRequest defines model for UpdateConversationRequest.
type UpdateConversationRequest struct {
	Title *string `json:"title"`
}

// Error defines model for Error.
type Error = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// SearchTypeUnavailable Error response when the requested search type is not available on the server.
type SearchTypeUnavailable = SearchTypeUnavailableError

// UploadAttachmentMultipartBody defines parameters for UploadAttachment.
type UploadAttachmentMultipartBody struct {
	// File The file to upload.
	File openapi_types.File `json:"file"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// ExpiresIn ISO 8601 duration for how long the unlinked attachment should persist.
	// Defaults to 1 hour. Maximum 24 hours. Only used for multipart uploads.
	ExpiresIn *string `form:"expiresIn,omitempty" json:"expiresIn,omitempty"`
}

// ListConversationsParams defines parameters for ListConversations.
type ListConversationsParams struct {
	// Mode Listing mode for conversations. Controls which conversations are returned
	// from each fork tree (conversation group).
	// - `all`: include all conversations the user can access (roots and forks).
	// - `roots`: only include root conversations (conversations that are not forks).
	// - `latest-fork`: include only the most recently updated conversation per fork tree.
	//   This is useful for showing a single representative conversation from each tree.
	Mode *ListConversationsParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// AfterCursor Cursor for pagination; returns items after this conversation id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of conversations to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Query Optional text query for basic title/metadata search.
	Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// ListConversationsParamsMode defines parameters for ListConversations.
type ListConversationsParamsMode string

// IndexConversationsJSONBody defines parameters for IndexConversations.
type IndexConversationsJSONBody = []IndexEntryRequest

// ListUnindexedEntriesParams defines parameters for ListUnindexedEntries.
type ListUnindexedEntriesParams struct {
	// Limit Maximum number of entries to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AfterCursor Pagination cursor from previous response.
	AfterCursor *string `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`
}

// ListConversationEntriesParams defines parameters for ListConversationEntries.
type ListConversationEntriesParams struct {
	// AfterCursor Cursor for pagination; returns entries after this entry id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`
	Limit       *int                `form:"limit,omitempty" json:"limit,omitempty"`

	// Channel Channel of entries to return. Defaults to `history` for the
	// user-visible conversation; `memory` returns agent memory entries
	// scoped to the calling client id.
	Channel *Channel `form:"channel,omitempty" json:"channel,omitempty"`

	// Epoch Optional epoch filter when listing the `memory` channel. Valid values
	// are `latest`, `all`, or a numeric epoch identifier. Defaults to
	// `latest` when not provided. The epoch selection is scoped to the
	// calling client id.
	Epoch *string `form:"epoch,omitempty" json:"epoch,omitempty"`

	// Forks Controls which fork entries to include. `none` (default) follows the
	// fork ancestry path, returning entries from the target conversation
	// and its ancestors up to fork points. `all` returns entries from all
	// forks in the conversation group, useful for debugging or getting a
	// complete picture of all activity across forks.
	Forks *ListConversationEntriesParamsForks `form:"forks,omitempty" json:"forks,omitempty"`
}

// ListConversationEntriesParamsForks defines parameters for ListConversationEntries.
type ListConversationEntriesParamsForks string

// ListConversationForksParams defines parameters for ListConversationForks.
type ListConversationForksParams struct {
	// AfterCursor Cursor for pagination; returns items after this conversation id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of forks to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListConversationMembershipsParams defines parameters for ListConversationMemberships.
type ListConversationMembershipsParams struct {
	// AfterCursor Cursor for pagination; returns items after this user id.
	AfterCursor *string `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of memberships to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateConversationMembershipJSONBody defines parameters for UpdateConversationMembership.
type UpdateConversationMembershipJSONBody struct {
	// AccessLevel Access level of a user for a conversation.
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`
}

// DeleteMemoryParams defines parameters for DeleteMemory.
type DeleteMemoryParams struct {
	// Ns Namespace segments. Repeat once per segment.
	Ns  []string `form:"ns" json:"ns"`
	Key string   `form:"key" json:"key"`
}

// GetMemoryParams defines parameters for GetMemory.
type GetMemoryParams struct {
	// Ns Namespace segments. Repeat once per segment.
	Ns  []string `form:"ns" json:"ns"`
	Key string   `form:"key" json:"key"`
}

// ListMemoryEventsParams defines parameters for ListMemoryEvents.
type ListMemoryEventsParams struct {
	// Ns Namespace prefix segments. Repeat once per segment.
	Ns *[]string `form:"ns,omitempty" json:"ns,omitempty"`

	// Kinds Filter by event kind. Repeat to include multiple. Values: add, update, delete, expired.
	Kinds *[]ListMemoryEventsParamsKinds `form:"kinds,omitempty" json:"kinds,omitempty"`

	// After Return events with occurred_at strictly after this ISO 8601 timestamp.
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before Return events with occurred_at strictly before this ISO 8601 timestamp.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// AfterCursor Opaque cursor from a previous response for pagination.
	AfterCursor *string `form:"after_cursor,omitempty" json:"after_cursor,omitempty"`
	Limit       *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListMemoryEventsParamsKinds defines parameters for ListMemoryEvents.
type ListMemoryEventsParamsKinds string

// ListMemoryNamespacesParams defines parameters for ListMemoryNamespaces.
type ListMemoryNamespacesParams struct {
	// Prefix Namespace prefix segments. Repeat once per segment.
	Prefix *[]string `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Suffix Namespace suffix segments. Repeat once per segment.
	Suffix   *[]string `form:"suffix,omitempty" json:"suffix,omitempty"`
	MaxDepth *int      `form:"max_depth,omitempty" json:"max_depth,omitempty"`
}

// ListPendingTransfersParams defines parameters for ListPendingTransfers.
type ListPendingTransfersParams struct {
	// Role Filter by user's role in the transfer.
	Role *ListPendingTransfersParamsRole `form:"role,omitempty" json:"role,omitempty"`

	// AfterCursor Cursor for pagination; returns items after this transfer id (UUID format).
	AfterCursor *openapi_types.UUID `form:"afterCursor,omitempty" json:"afterCursor,omitempty"`

	// Limit Maximum number of transfers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListPendingTransfersParamsRole defines parameters for ListPendingTransfers.
type ListPendingTransfersParamsRole string

// UploadAttachmentJSONRequestBody defines body for UploadAttachment for application/json ContentType.
type UploadAttachmentJSONRequestBody = CreateFromUrlRequest

// UploadAttachmentMultipartRequestBody defines body for UploadAttachment for multipart/form-data ContentType.
type UploadAttachmentMultipartRequestBody UploadAttachmentMultipartBody

// CreateConversationJSONRequestBody defines body for CreateConversation for application/json ContentType.
type CreateConversationJSONRequestBody = CreateConversationRequest

// IndexConversationsJSONRequestBody defines body for IndexConversations for application/json ContentType.
type IndexConversationsJSONRequestBody = IndexConversationsJSONBody

// SearchConversationsJSONRequestBody defines body for SearchConversations for application/json ContentType.
type SearchConversationsJSONRequestBody = SearchConversationsRequest

// UpdateConversationJSONRequestBody defines body for UpdateConversation for application/json ContentType.
type UpdateConversationJSONRequestBody = UpdateConversationRequest

// AppendConversationEntryJSONRequestBody defines body for AppendConversationEntry for application/json ContentType.
type AppendConversationEntryJSONRequestBody = CreateEntryRequest

// SyncConversationMemoryJSONRequestBody defines body for SyncConversationMemory for application/json ContentType.
type SyncConversationMemoryJSONRequestBody = CreateEntryRequest

// ShareConversationJSONRequestBody defines body for ShareConversation for application/json ContentType.
type ShareConversationJSONRequestBody = ShareConversationRequest

// UpdateConversationMembershipJSONRequestBody defines body for UpdateConversationMembership for application/json ContentType.
type UpdateConversationMembershipJSONRequestBody UpdateConversationMembershipJSONBody

// PutMemoryJSONRequestBody defines body for PutMemory for application/json ContentType.
type PutMemoryJSONRequestBody = PutMemoryRequest

// SearchMemoriesJSONRequestBody defines body for SearchMemories for application/json ContentType.
type SearchMemoriesJSONRequestBody = SearchMemoriesRequest

// CreateOwnershipTransferJSONRequestBody defines body for CreateOwnershipTransfer for application/json ContentType.
type CreateOwnershipTransferJSONRequestBody = CreateOwnershipTransferRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload or create an attachment
	// (POST /v1/attachments)
	UploadAttachment(c *gin.Context, params UploadAttachmentParams)
	// Download an attachment via signed token
	// (GET /v1/attachments/download/{token}/{filename})
	DownloadAttachmentByToken(c *gin.Context, token string, filename string)
	// Delete an unlinked attachment
	// (DELETE /v1/attachments/{id})
	DeleteAttachment(c *gin.Context, id openapi_types.UUID)
	// Retrieve an attachment
	// (GET /v1/attachments/{id})
	GetAttachment(c *gin.Context, id openapi_types.UUID)
	// Get a signed download URL for an attachment
	// (GET /v1/attachments/{id}/download-url)
	GetAttachmentDownloadUrl(c *gin.Context, id openapi_types.UUID)
	// List conversations visible to current user
	// (GET /v1/conversations)
	ListConversations(c *gin.Context, params ListConversationsParams)
	// Create a conversation
	// (POST /v1/conversations)
	CreateConversation(c *gin.Context)
	// Index conversation entries
	// (POST /v1/conversations/index)
	IndexConversations(c *gin.Context)
	// Semantic search across conversations
	// (POST /v1/conversations/search)
	SearchConversations(c *gin.Context)
	// List entries needing indexing
	// (GET /v1/conversations/unindexed)
	ListUnindexedEntries(c *gin.Context, params ListUnindexedEntriesParams)
	// Delete a conversation
	// (DELETE /v1/conversations/{conversationId})
	DeleteConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Get a conversation
	// (GET /v1/conversations/{conversationId})
	GetConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Update a conversation
	// (PATCH /v1/conversations/{conversationId})
	UpdateConversation(c *gin.Context, conversationId openapi_types.UUID)
	// List conversation entries
	// (GET /v1/conversations/{conversationId}/entries)
	ListConversationEntries(c *gin.Context, conversationId openapi_types.UUID, params ListConversationEntriesParams)
	// Append an entry
	// (POST /v1/conversations/{conversationId}/entries)
	AppendConversationEntry(c *gin.Context, conversationId openapi_types.UUID)
	// Synchronize the agent memory epoch
	// (POST /v1/conversations/{conversationId}/entries/sync)
	SyncConversationMemory(c *gin.Context, conversationId openapi_types.UUID)
	// List forks for a conversation
	// (GET /v1/conversations/{conversationId}/forks)
	ListConversationForks(c *gin.Context, conversationId openapi_types.UUID, params ListConversationForksParams)
	// List conversation memberships
	// (GET /v1/conversations/{conversationId}/memberships)
	ListConversationMemberships(c *gin.Context, conversationId openapi_types.UUID, params ListConversationMembershipsParams)
	// Share conversation with another user
	// (POST /v1/conversations/{conversationId}/memberships)
	ShareConversation(c *gin.Context, conversationId openapi_types.UUID)
	// Remove a member from the conversation
	// (DELETE /v1/conversations/{conversationId}/memberships/{userId})
	DeleteConversationMembership(c *gin.Context, conversationId openapi_types.UUID, userId string)
	// Update a member's access level
	// (PATCH /v1/conversations/{conversationId}/memberships/{userId})
	UpdateConversationMembership(c *gin.Context, conversationId openapi_types.UUID, userId string)
	// Cancel an in-progress response
	// (DELETE /v1/conversations/{conversationId}/response)
	DeleteConversationResponse(c *gin.Context, conversationId openapi_types.UUID)
	// Delete a memory item
	// (DELETE /v1/memories)
	DeleteMemory(c *gin.Context, params DeleteMemoryParams)
	// Get a memory item
	// (GET /v1/memories)
	GetMemory(c *gin.Context, params GetMemoryParams)
	// Upsert a memory item
	// (PUT /v1/memories)
	PutMemory(c *gin.Context)
	// List memory lifecycle events
	// (GET /v1/memories/events)
	ListMemoryEvents(c *gin.Context, params ListMemoryEventsParams)
	// List memory namespaces
	// (GET /v1/memories/namespaces)
	ListMemoryNamespaces(c *gin.Context, params ListMemoryNamespacesParams)
	// Search memory items
	// (POST /v1/memories/search)
	SearchMemories(c *gin.Context)
	// List pending ownership transfers
	// (GET /v1/ownership-transfers)
	ListPendingTransfers(c *gin.Context, params ListPendingTransfersParams)
	// Request ownership transfer
	// (POST /v1/ownership-transfers)
	CreateOwnershipTransfer(c *gin.Context)
	// Cancel or reject ownership transfer
	// (DELETE /v1/ownership-transfers/{transferId})
	DeleteTransfer(c *gin.Context, transferId openapi_types.UUID)
	// Get transfer details
	// (GET /v1/ownership-transfers/{transferId})
	GetTransfer(c *gin.Context, transferId openapi_types.UUID)
	// Accept ownership transfer
	// (POST /v1/ownership-transfers/{transferId}/accept)
	AcceptTransfer(c *gin.Context, transferId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadAttachment operation middleware
func (siw *ServerInterfaceWrapper) UploadAttachment(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadAttachmentParams

	// ------------- Optional query parameter "expiresIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "expiresIn", c.Request.URL.Query(), &params.ExpiresIn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter expiresIn: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadAttachment(c, params)
}

// DownloadAttachmentByToken operation middleware
func (siw *ServerInterfaceWrapper) DownloadAttachmentByToken(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", c.Param("filename"), &filename, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter filename: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DownloadAttachmentByToken(c, token, filename)
}

// DeleteAttachment operation middleware
func (siw *ServerInterfaceWrapper) DeleteAttachment(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAttachment(c, id)
}

// GetAttachment operation middleware
func (siw *ServerInterfaceWrapper) GetAttachment(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAttachment(c, id)
}

// GetAttachmentDownloadUrl operation middleware
func (siw *ServerInterfaceWrapper) GetAttachmentDownloadUrl(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAttachmentDownloadUrl(c, id)
}

// ListConversations operation middleware
func (siw *ServerInterfaceWrapper) ListConversations(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationsParams

	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", c.Request.URL.Query(), &params.Mode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", c.Request.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter query: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversations(c, params)
}

// CreateConversation operation middleware
func (siw *ServerInterfaceWrapper) CreateConversation(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateConversation(c)
}

// IndexConversations operation middleware
func (siw *ServerInterfaceWrapper) IndexConversations(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.IndexConversations(c)
}

// SearchConversations operation middleware
func (siw *ServerInterfaceWrapper) SearchConversations(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchConversations(c)
}

// ListUnindexedEntries operation middleware
func (siw *ServerInterfaceWrapper) ListUnindexedEntries(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUnindexedEntriesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListUnindexedEntries(c, params)
}

// DeleteConversation operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversation(c, conversationId)
}

// GetConversation operation middleware
func (siw *ServerInterfaceWrapper) GetConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConversation(c, conversationId)
}

// UpdateConversation operation middleware
func (siw *ServerInterfaceWrapper) UpdateConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateConversation(c, conversationId)
}

// ListConversationEntries operation middleware
func (siw *ServerInterfaceWrapper) ListConversationEntries(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationEntriesParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "channel" -------------

	err = runtime.BindQueryParameter("form", true, false, "channel", c.Request.URL.Query(), &params.Channel)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter channel: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "epoch" -------------

	err = runtime.BindQueryParameter("form", true, false, "epoch", c.Request.URL.Query(), &params.Epoch)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter epoch: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "forks" -------------

	err = runtime.BindQueryParameter("form", true, false, "forks", c.Request.URL.Query(), &params.Forks)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter forks: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationEntries(c, conversationId, params)
}

// AppendConversationEntry operation middleware
func (siw *ServerInterfaceWrapper) AppendConversationEntry(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AppendConversationEntry(c, conversationId)
}

// SyncConversationMemory operation middleware
func (siw *ServerInterfaceWrapper) SyncConversationMemory(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SyncConversationMemory(c, conversationId)
}

// ListConversationForks operation middleware
func (siw *ServerInterfaceWrapper) ListConversationForks(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationForksParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationForks(c, conversationId, params)
}

// ListConversationMemberships operation middleware
func (siw *ServerInterfaceWrapper) ListConversationMemberships(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConversationMembershipsParams

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListConversationMemberships(c, conversationId, params)
}

// ShareConversation operation middleware
func (siw *ServerInterfaceWrapper) ShareConversation(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ShareConversation(c, conversationId)
}

// DeleteConversationMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversationMembership(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversationMembership(c, conversationId, userId)
}

// UpdateConversationMembership operation middleware
func (siw *ServerInterfaceWrapper) UpdateConversationMembership(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateConversationMembership(c, conversationId, userId)
}

// DeleteConversationResponse operation middleware
func (siw *ServerInterfaceWrapper) DeleteConversationResponse(c *gin.Context) {

	var err error

	// ------------- Path parameter "conversationId" -------------
	var conversationId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "conversationId", c.Param("conversationId"), &conversationId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter conversationId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteConversationResponse(c, conversationId)
}

// DeleteMemory operation middleware
func (siw *ServerInterfaceWrapper) DeleteMemory(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteMemoryParams

	// ------------- Required query parameter "ns" -------------

	if paramValue := c.Query("ns"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument ns is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ns", c.Request.URL.Query(), &params.Ns)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ns: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "key" -------------

	if paramValue := c.Query("key"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument key is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", c.Request.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter key: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteMemory(c, params)
}

// GetMemory operation middleware
func (siw *ServerInterfaceWrapper) GetMemory(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMemoryParams

	// ------------- Required query parameter "ns" -------------

	if paramValue := c.Query("ns"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument ns is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ns", c.Request.URL.Query(), &params.Ns)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ns: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "key" -------------

	if paramValue := c.Query("key"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument key is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", c.Request.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter key: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMemory(c, params)
}

// PutMemory operation middleware
func (siw *ServerInterfaceWrapper) PutMemory(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutMemory(c)
}

// ListMemoryEvents operation middleware
func (siw *ServerInterfaceWrapper) ListMemoryEvents(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMemoryEventsParams

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", c.Request.URL.Query(), &params.Ns)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ns: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "kinds" -------------

	err = runtime.BindQueryParameter("form", true, false, "kinds", c.Request.URL.Query(), &params.Kinds)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter kinds: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", c.Request.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter after: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", c.Request.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter before: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after_cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_cursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter after_cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListMemoryEvents(c, params)
}

// ListMemoryNamespaces operation middleware
func (siw *ServerInterfaceWrapper) ListMemoryNamespaces(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMemoryNamespacesParams

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", c.Request.URL.Query(), &params.Prefix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter prefix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "suffix" -------------

	err = runtime.BindQueryParameter("form", true, false, "suffix", c.Request.URL.Query(), &params.Suffix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter suffix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "max_depth" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_depth", c.Request.URL.Query(), &params.MaxDepth)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter max_depth: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListMemoryNamespaces(c, params)
}

// SearchMemories operation middleware
func (siw *ServerInterfaceWrapper) SearchMemories(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchMemories(c)
}

// ListPendingTransfers operation middleware
func (siw *ServerInterfaceWrapper) ListPendingTransfers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPendingTransfersParams

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", c.Request.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter role: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "afterCursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "afterCursor", c.Request.URL.Query(), &params.AfterCursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterCursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPendingTransfers(c, params)
}

// CreateOwnershipTransfer operation middleware
func (siw *ServerInterfaceWrapper) CreateOwnershipTransfer(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateOwnershipTransfer(c)
}

// DeleteTransfer operation middleware
func (siw *ServerInterfaceWrapper) DeleteTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTransfer(c, transferId)
}

// GetTransfer operation middleware
func (siw *ServerInterfaceWrapper) GetTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTransfer(c, transferId)
}

// AcceptTransfer operation middleware
func (siw *ServerInterfaceWrapper) AcceptTransfer(c *gin.Context) {

	var err error

	// ------------- Path parameter "transferId" -------------
	var transferId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "transferId", c.Param("transferId"), &transferId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter transferId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AcceptTransfer(c, transferId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/attachments", wrapper.UploadAttachment)
	router.GET(options.BaseURL+"/v1/attachments/download/:token/:filename", wrapper.DownloadAttachmentByToken)
	router.DELETE(options.BaseURL+"/v1/attachments/:id", wrapper.DeleteAttachment)
	router.GET(options.BaseURL+"/v1/attachments/:id", wrapper.GetAttachment)
	router.GET(options.BaseURL+"/v1/attachments/:id/download-url", wrapper.GetAttachmentDownloadUrl)
	router.GET(options.BaseURL+"/v1/conversations", wrapper.ListConversations)
	router.POST(options.BaseURL+"/v1/conversations", wrapper.CreateConversation)
	router.POST(options.BaseURL+"/v1/conversations/index", wrapper.IndexConversations)
	router.POST(options.BaseURL+"/v1/conversations/search", wrapper.SearchConversations)
	router.GET(options.BaseURL+"/v1/conversations/unindexed", wrapper.ListUnindexedEntries)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId", wrapper.DeleteConversation)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId", wrapper.GetConversation)
	router.PATCH(options.BaseURL+"/v1/conversations/:conversationId", wrapper.UpdateConversation)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/entries", wrapper.ListConversationEntries)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/entries", wrapper.AppendConversationEntry)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/entries/sync", wrapper.SyncConversationMemory)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/forks", wrapper.ListConversationForks)
	router.GET(options.BaseURL+"/v1/conversations/:conversationId/memberships", wrapper.ListConversationMemberships)
	router.POST(options.BaseURL+"/v1/conversations/:conversationId/memberships", wrapper.ShareConversation)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId/memberships/:userId", wrapper.DeleteConversationMembership)
	router.PATCH(options.BaseURL+"/v1/conversations/:conversationId/memberships/:userId", wrapper.UpdateConversationMembership)
	router.DELETE(options.BaseURL+"/v1/conversations/:conversationId/response", wrapper.DeleteConversationResponse)
	router.DELETE(options.BaseURL+"/v1/memories", wrapper.DeleteMemory)
	router.GET(options.BaseURL+"/v1/memories", wrapper.GetMemory)
	router.PUT(options.BaseURL+"/v1/memories", wrapper.PutMemory)
	router.GET(options.BaseURL+"/v1/memories/events", wrapper.ListMemoryEvents)
	router.GET(options.BaseURL+"/v1/memories/namespaces", wrapper.ListMemoryNamespaces)
	router.POST(options.BaseURL+"/v1/memories/search", wrapper.SearchMemories)
	router.GET(options.BaseURL+"/v1/ownership-transfers", wrapper.ListPendingTransfers)
	router.POST(options.BaseURL+"/v1/ownership-transfers", wrapper.CreateOwnershipTransfer)
	router.DELETE(options.BaseURL+"/v1/ownership-transfers/:transferId", wrapper.DeleteTransfer)
	router.GET(options.BaseURL+"/v1/ownership-transfers/:transferId", wrapper.GetTransfer)
	router.POST(options.BaseURL+"/v1/ownership-transfers/:transferId/accept", wrapper.AcceptTransfer)
}

type ErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type SearchTypeUnavailableJSONResponse SearchTypeUnavailableError

type UploadAttachmentRequestObject struct {
	Params        UploadAttachmentParams
	JSONBody      *UploadAttachmentJSONRequestBody
	MultipartBody *multipart.Reader
}

type UploadAttachmentResponseObject interface {
	VisitUploadAttachmentResponse(w http.ResponseWriter) error
}

type UploadAttachment201JSONResponse AttachmentUploadResponse

func (response UploadAttachment201JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachment400JSONResponse struct{ ErrorJSONResponse }

func (response UploadAttachment400JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachment413JSONResponse ErrorResponse

func (response UploadAttachment413JSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type UploadAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UploadAttachmentdefaultJSONResponse) VisitUploadAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DownloadAttachmentByTokenRequestObject struct {
	Token    string `json:"token"`
	Filename string `json:"filename"`
}

type DownloadAttachmentByTokenResponseObject interface {
	VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error
}

type DownloadAttachmentByToken200ResponseHeaders struct {
	CacheControl string
}

type DownloadAttachmentByToken200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       DownloadAttachmentByToken200ResponseHeaders
	ContentLength int64
}

func (response DownloadAttachmentByToken200ApplicationoctetStreamResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DownloadAttachmentByToken403Response struct {
}

func (response DownloadAttachmentByToken403Response) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DownloadAttachmentByToken404JSONResponse struct{ NotFoundJSONResponse }

func (response DownloadAttachmentByToken404JSONResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DownloadAttachmentByTokendefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DownloadAttachmentByTokendefaultJSONResponse) VisitDownloadAttachmentByTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAttachmentRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type DeleteAttachmentResponseObject interface {
	VisitDeleteAttachmentResponse(w http.ResponseWriter) error
}

type DeleteAttachment204Response struct {
}

func (response DeleteAttachment204Response) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteAttachment403JSONResponse struct{ ErrorJSONResponse }

func (response DeleteAttachment403JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachment404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteAttachment404JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachment409JSONResponse ErrorResponse

func (response DeleteAttachment409JSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteAttachmentdefaultJSONResponse) VisitDeleteAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAttachmentRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type GetAttachmentResponseObject interface {
	VisitGetAttachmentResponse(w http.ResponseWriter) error
}

type GetAttachment200ResponseHeaders struct {
	CacheControl string
}

type GetAttachment200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetAttachment200ResponseHeaders
	ContentLength int64
}

func (response GetAttachment200ApplicationoctetStreamResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetAttachment302ResponseHeaders struct {
	CacheControl string
}

type GetAttachment302Response struct {
	Headers GetAttachment302ResponseHeaders
}

func (response GetAttachment302Response) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.WriteHeader(302)
	return nil
}

type GetAttachment403JSONResponse struct{ ErrorJSONResponse }

func (response GetAttachment403JSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachment404JSONResponse struct{ NotFoundJSONResponse }

func (response GetAttachment404JSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetAttachmentdefaultJSONResponse) VisitGetAttachmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAttachmentDownloadUrlRequestObject struct {
	Id openapi_types.UUID `json:"id"`
}

type GetAttachmentDownloadUrlResponseObject interface {
	VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error
}

type GetAttachmentDownloadUrl200JSONResponse AttachmentDownloadUrlResponse

func (response GetAttachmentDownloadUrl200JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrl403JSONResponse struct{ ErrorJSONResponse }

func (response GetAttachmentDownloadUrl403JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrl404JSONResponse struct{ NotFoundJSONResponse }

func (response GetAttachmentDownloadUrl404JSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetAttachmentDownloadUrldefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetAttachmentDownloadUrldefaultJSONResponse) VisitGetAttachmentDownloadUrlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationsRequestObject struct {
	Params ListConversationsParams
}

type ListConversationsResponseObject interface {
	VisitListConversationsResponse(w http.ResponseWriter) error
}

type ListConversations200JSONResponse struct {
	AfterCursor *string                `json:"afterCursor"`
	Data        *[]ConversationSummary `json:"data,omitempty"`
}

func (response ListConversations200JSONResponse) VisitListConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationsdefaultJSONResponse) VisitListConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateConversationRequestObject struct {
	Body *CreateConversationJSONRequestBody
}

type CreateConversationResponseObject interface {
	VisitCreateConversationResponse(w http.ResponseWriter) error
}

type CreateConversation201JSONResponse Conversation

func (response CreateConversation201JSONResponse) VisitCreateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response CreateConversationdefaultJSONResponse) VisitCreateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type IndexConversationsRequestObject struct {
	Body *IndexConversationsJSONRequestBody
}

type IndexConversationsResponseObject interface {
	VisitIndexConversationsResponse(w http.ResponseWriter) error
}

type IndexConversations200JSONResponse IndexConversationsResponse

func (response IndexConversations200JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversations403JSONResponse struct{ ErrorJSONResponse }

func (response IndexConversations403JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversations404JSONResponse struct{ NotFoundJSONResponse }

func (response IndexConversations404JSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type IndexConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response IndexConversationsdefaultJSONResponse) VisitIndexConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchConversationsRequestObject struct {
	Body *SearchConversationsJSONRequestBody
}

type SearchConversationsResponseObject interface {
	VisitSearchConversationsResponse(w http.ResponseWriter) error
}

type SearchConversations200JSONResponse struct {
	AfterCursor *string         `json:"afterCursor"`
	Data        *[]SearchResult `json:"data,omitempty"`
}

func (response SearchConversations200JSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SearchConversations501JSONResponse struct {
	SearchTypeUnavailableJSONResponse
}

func (response SearchConversations501JSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type SearchConversationsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response SearchConversationsdefaultJSONResponse) VisitSearchConversationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListUnindexedEntriesRequestObject struct {
	Params ListUnindexedEntriesParams
}

type ListUnindexedEntriesResponseObject interface {
	VisitListUnindexedEntriesResponse(w http.ResponseWriter) error
}

type ListUnindexedEntries200JSONResponse UnindexedEntriesResponse

func (response ListUnindexedEntries200JSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUnindexedEntries403JSONResponse struct{ ErrorJSONResponse }

func (response ListUnindexedEntries403JSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUnindexedEntriesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListUnindexedEntriesdefaultJSONResponse) VisitListUnindexedEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type DeleteConversationResponseObject interface {
	VisitDeleteConversationResponse(w http.ResponseWriter) error
}

type DeleteConversation204Response struct {
}

func (response DeleteConversation204Response) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversation404JSONResponse) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationdefaultJSONResponse) VisitDeleteConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type GetConversationResponseObject interface {
	VisitGetConversationResponse(w http.ResponseWriter) error
}

type GetConversation200JSONResponse Conversation

func (response GetConversation200JSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConversation404JSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConversationdefaultJSONResponse) VisitGetConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *UpdateConversationJSONRequestBody
}

type UpdateConversationResponseObject interface {
	VisitUpdateConversationResponse(w http.ResponseWriter) error
}

type UpdateConversation200JSONResponse Conversation

func (response UpdateConversation200JSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateConversation404JSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UpdateConversationdefaultJSONResponse) VisitUpdateConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationEntriesRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationEntriesParams
}

type ListConversationEntriesResponseObject interface {
	VisitListConversationEntriesResponse(w http.ResponseWriter) error
}

type ListConversationEntries200JSONResponse struct {
	AfterCursor *string  `json:"afterCursor"`
	Data        *[]Entry `json:"data,omitempty"`
}

func (response ListConversationEntries200JSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationEntries404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationEntries404JSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationEntriesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationEntriesdefaultJSONResponse) VisitListConversationEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AppendConversationEntryRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *AppendConversationEntryJSONRequestBody
}

type AppendConversationEntryResponseObject interface {
	VisitAppendConversationEntryResponse(w http.ResponseWriter) error
}

type AppendConversationEntry201JSONResponse Entry

func (response AppendConversationEntry201JSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AppendConversationEntry404JSONResponse struct{ NotFoundJSONResponse }

func (response AppendConversationEntry404JSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AppendConversationEntrydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response AppendConversationEntrydefaultJSONResponse) VisitAppendConversationEntryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SyncConversationMemoryRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *SyncConversationMemoryJSONRequestBody
}

type SyncConversationMemoryResponseObject interface {
	VisitSyncConversationMemoryResponse(w http.ResponseWriter) error
}

type SyncConversationMemory200JSONResponse SyncEntryResponse

func (response SyncConversationMemory200JSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SyncConversationMemory404JSONResponse struct{ NotFoundJSONResponse }

func (response SyncConversationMemory404JSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type SyncConversationMemorydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response SyncConversationMemorydefaultJSONResponse) VisitSyncConversationMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationForksRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationForksParams
}

type ListConversationForksResponseObject interface {
	VisitListConversationForksResponse(w http.ResponseWriter) error
}

type ListConversationForks200JSONResponse struct {
	AfterCursor *string                    `json:"afterCursor"`
	Data        *[]ConversationForkSummary `json:"data,omitempty"`
}

func (response ListConversationForks200JSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationForks404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationForks404JSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationForksdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationForksdefaultJSONResponse) VisitListConversationForksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListConversationMembershipsRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Params         ListConversationMembershipsParams
}

type ListConversationMembershipsResponseObject interface {
	VisitListConversationMembershipsResponse(w http.ResponseWriter) error
}

type ListConversationMemberships200JSONResponse struct {
	AfterCursor *string                   `json:"afterCursor"`
	Data        *[]ConversationMembership `json:"data,omitempty"`
}

func (response ListConversationMemberships200JSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationMemberships404JSONResponse struct{ NotFoundJSONResponse }

func (response ListConversationMemberships404JSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListConversationMembershipsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListConversationMembershipsdefaultJSONResponse) VisitListConversationMembershipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ShareConversationRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	Body           *ShareConversationJSONRequestBody
}

type ShareConversationResponseObject interface {
	VisitShareConversationResponse(w http.ResponseWriter) error
}

type ShareConversation201JSONResponse ConversationMembership

func (response ShareConversation201JSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type ShareConversation404JSONResponse struct{ NotFoundJSONResponse }

func (response ShareConversation404JSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShareConversationdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ShareConversationdefaultJSONResponse) VisitShareConversationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationMembershipRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	UserId         string             `json:"userId"`
}

type DeleteConversationMembershipResponseObject interface {
	VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error
}

type DeleteConversationMembership204Response struct {
}

func (response DeleteConversationMembership204Response) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConversationMembership404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversationMembership404JSONResponse) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationMembershipdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationMembershipdefaultJSONResponse) VisitDeleteConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateConversationMembershipRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
	UserId         string             `json:"userId"`
	Body           *UpdateConversationMembershipJSONRequestBody
}

type UpdateConversationMembershipResponseObject interface {
	VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error
}

type UpdateConversationMembership200JSONResponse ConversationMembership

func (response UpdateConversationMembership200JSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationMembership404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateConversationMembership404JSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConversationMembershipdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response UpdateConversationMembershipdefaultJSONResponse) VisitUpdateConversationMembershipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConversationResponseRequestObject struct {
	ConversationId openapi_types.UUID `json:"conversationId"`
}

type DeleteConversationResponseResponseObject interface {
	VisitDeleteConversationResponseResponse(w http.ResponseWriter) error
}

type DeleteConversationResponse200Response struct {
}

func (response DeleteConversationResponse200Response) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteConversationResponse404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteConversationResponse404JSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationResponse409JSONResponse struct{ ErrorJSONResponse }

func (response DeleteConversationResponse409JSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConversationResponsedefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConversationResponsedefaultJSONResponse) VisitDeleteConversationResponseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteMemoryRequestObject struct {
	Params DeleteMemoryParams
}

type DeleteMemoryResponseObject interface {
	VisitDeleteMemoryResponse(w http.ResponseWriter) error
}

type DeleteMemory204Response struct {
}

func (response DeleteMemory204Response) VisitDeleteMemoryResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteMemorydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteMemorydefaultJSONResponse) VisitDeleteMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetMemoryRequestObject struct {
	Params GetMemoryParams
}

type GetMemoryResponseObject interface {
	VisitGetMemoryResponse(w http.ResponseWriter) error
}

type GetMemory200JSONResponse MemoryItem

func (response GetMemory200JSONResponse) VisitGetMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetMemory404JSONResponse struct{ NotFoundJSONResponse }

func (response GetMemory404JSONResponse) VisitGetMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetMemorydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetMemorydefaultJSONResponse) VisitGetMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutMemoryRequestObject struct {
	Body *PutMemoryJSONRequestBody
}

type PutMemoryResponseObject interface {
	VisitPutMemoryResponse(w http.ResponseWriter) error
}

type PutMemory200JSONResponse MemoryWriteResult

func (response PutMemory200JSONResponse) VisitPutMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PutMemorydefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutMemorydefaultJSONResponse) VisitPutMemoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListMemoryEventsRequestObject struct {
	Params ListMemoryEventsParams
}

type ListMemoryEventsResponseObject interface {
	VisitListMemoryEventsResponse(w http.ResponseWriter) error
}

type ListMemoryEvents200JSONResponse ListMemoryEventsResponse

func (response ListMemoryEvents200JSONResponse) VisitListMemoryEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMemoryEventsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListMemoryEventsdefaultJSONResponse) VisitListMemoryEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListMemoryNamespacesRequestObject struct {
	Params ListMemoryNamespacesParams
}

type ListMemoryNamespacesResponseObject interface {
	VisitListMemoryNamespacesResponse(w http.ResponseWriter) error
}

type ListMemoryNamespaces200JSONResponse ListMemoryNamespacesResponse

func (response ListMemoryNamespaces200JSONResponse) VisitListMemoryNamespacesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMemoryNamespacesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListMemoryNamespacesdefaultJSONResponse) VisitListMemoryNamespacesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchMemoriesRequestObject struct {
	Body *SearchMemoriesJSONRequestBody
}

type SearchMemoriesResponseObject interface {
	VisitSearchMemoriesResponse(w http.ResponseWriter) error
}

type SearchMemories200JSONResponse SearchMemoriesResponse

func (response SearchMemories200JSONResponse) VisitSearchMemoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SearchMemoriesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response SearchMemoriesdefaultJSONResponse) VisitSearchMemoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListPendingTransfersRequestObject struct {
	Params ListPendingTransfersParams
}

type ListPendingTransfersResponseObject interface {
	VisitListPendingTransfersResponse(w http.ResponseWriter) error
}

type ListPendingTransfers200JSONResponse struct {
	AfterCursor *string              `json:"afterCursor"`
	Data        *[]OwnershipTransfer `json:"data,omitempty"`
}

func (response ListPendingTransfers200JSONResponse) VisitListPendingTransfersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPendingTransfersdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListPendingTransfersdefaultJSONResponse) VisitListPendingTransfersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateOwnershipTransferRequestObject struct {
	Body *CreateOwnershipTransferJSONRequestBody
}

type CreateOwnershipTransferResponseObject interface {
	VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error
}

type CreateOwnershipTransfer201JSONResponse OwnershipTransfer

func (response CreateOwnershipTransfer201JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer400JSONResponse struct{ ErrorJSONResponse }

func (response CreateOwnershipTransfer400JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer403JSONResponse ErrorResponse

func (response CreateOwnershipTransfer403JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateOwnershipTransfer404JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransfer409JSONResponse struct {
	Code  *string `json:"code,omitempty"`
	Error *string `json:"error,omitempty"`

	// ExistingTransferId ID of the existing pending transfer
	ExistingTransferId *openapi_types.UUID `json:"existingTransferId,omitempty"`
}

func (response CreateOwnershipTransfer409JSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateOwnershipTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response CreateOwnershipTransferdefaultJSONResponse) VisitCreateOwnershipTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type DeleteTransferResponseObject interface {
	VisitDeleteTransferResponse(w http.ResponseWriter) error
}

type DeleteTransfer204Response struct {
}

func (response DeleteTransfer204Response) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteTransfer403JSONResponse struct{ ErrorJSONResponse }

func (response DeleteTransfer403JSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteTransfer404JSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteTransferdefaultJSONResponse) VisitDeleteTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type GetTransferResponseObject interface {
	VisitGetTransferResponse(w http.ResponseWriter) error
}

type GetTransfer200JSONResponse OwnershipTransfer

func (response GetTransfer200JSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response GetTransfer404JSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetTransferdefaultJSONResponse) VisitGetTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AcceptTransferRequestObject struct {
	TransferId openapi_types.UUID `json:"transferId"`
}

type AcceptTransferResponseObject interface {
	VisitAcceptTransferResponse(w http.ResponseWriter) error
}

type AcceptTransfer204Response struct {
}

func (response AcceptTransfer204Response) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AcceptTransfer403JSONResponse struct{ ErrorJSONResponse }

func (response AcceptTransfer403JSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AcceptTransfer404JSONResponse struct{ NotFoundJSONResponse }

func (response AcceptTransfer404JSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AcceptTransferdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response AcceptTransferdefaultJSONResponse) VisitAcceptTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload or create an attachment
	// (POST /v1/attachments)
	UploadAttachment(ctx context.Context, request UploadAttachmentRequestObject) (UploadAttachmentResponseObject, error)
	// Download an attachment via signed token
	// (GET /v1/attachments/download/{token}/{filename})
	DownloadAttachmentByToken(ctx context.Context, request DownloadAttachmentByTokenRequestObject) (DownloadAttachmentByTokenResponseObject, error)
	// Delete an unlinked attachment
	// (DELETE /v1/attachments/{id})
	DeleteAttachment(ctx context.Context, request DeleteAttachmentRequestObject) (DeleteAttachmentResponseObject, error)
	// Retrieve an attachment
	// (GET /v1/attachments/{id})
	GetAttachment(ctx context.Context, request GetAttachmentRequestObject) (GetAttachmentResponseObject, error)
	// Get a signed download URL for an attachment
	// (GET /v1/attachments/{id}/download-url)
	GetAttachmentDownloadUrl(ctx context.Context, request GetAttachmentDownloadUrlRequestObject) (GetAttachmentDownloadUrlResponseObject, error)
	// List conversations visible to current user
	// (GET /v1/conversations)
	ListConversations(ctx context.Context, request ListConversationsRequestObject) (ListConversationsResponseObject, error)
	// Create a conversation
	// (POST /v1/conversations)
	CreateConversation(ctx context.Context, request CreateConversationRequestObject) (CreateConversationResponseObject, error)
	// Index conversation entries
	// (POST /v1/conversations/index)
	IndexConversations(ctx context.Context, request IndexConversationsRequestObject) (IndexConversationsResponseObject, error)
	// Semantic search across conversations
	// (POST /v1/conversations/search)
	SearchConversations(ctx context.Context, request SearchConversationsRequestObject) (SearchConversationsResponseObject, error)
	// List entries needing indexing
	// (GET /v1/conversations/unindexed)
	ListUnindexedEntries(ctx context.Context, request ListUnindexedEntriesRequestObject) (ListUnindexedEntriesResponseObject, error)
	// Delete a conversation
	// (DELETE /v1/conversations/{conversationId})
	DeleteConversation(ctx context.Context, request DeleteConversationRequestObject) (DeleteConversationResponseObject, error)
	// Get a conversation
	// (GET /v1/conversations/{conversationId})
	GetConversation(ctx context.Context, request GetConversationRequestObject) (GetConversationResponseObject, error)
	// Update a conversation
	// (PATCH /v1/conversations/{conversationId})
	UpdateConversation(ctx context.Context, request UpdateConversationRequestObject) (UpdateConversationResponseObject, error)
	// List conversation entries
	// (GET /v1/conversations/{conversationId}/entries)
	ListConversationEntries(ctx context.Context, request ListConversationEntriesRequestObject) (ListConversationEntriesResponseObject, error)
	// Append an entry
	// (POST /v1/conversations/{conversationId}/entries)
	AppendConversationEntry(ctx context.Context, request AppendConversationEntryRequestObject) (AppendConversationEntryResponseObject, error)
	// Synchronize the agent memory epoch
	// (POST /v1/conversations/{conversationId}/entries/sync)
	SyncConversationMemory(ctx context.Context, request SyncConversationMemoryRequestObject) (SyncConversationMemoryResponseObject, error)
	// List forks for a conversation
	// (GET /v1/conversations/{conversationId}/forks)
	ListConversationForks(ctx context.Context, request ListConversationForksRequestObject) (ListConversationForksResponseObject, error)
	// List conversation memberships
	// (GET /v1/conversations/{conversationId}/memberships)
	ListConversationMemberships(ctx context.Context, request ListConversationMembershipsRequestObject) (ListConversationMembershipsResponseObject, error)
	// Share conversation with another user
	// (POST /v1/conversations/{conversationId}/memberships)
	ShareConversation(ctx context.Context, request ShareConversationRequestObject) (ShareConversationResponseObject, error)
	// Remove a member from the conversation
	// (DELETE /v1/conversations/{conversationId}/memberships/{userId})
	DeleteConversationMembership(ctx context.Context, request DeleteConversationMembershipRequestObject) (DeleteConversationMembershipResponseObject, error)
	// Update a member's access level
	// (PATCH /v1/conversations/{conversationId}/memberships/{userId})
	UpdateConversationMembership(ctx context.Context, request UpdateConversationMembershipRequestObject) (UpdateConversationMembershipResponseObject, error)
	// Cancel an in-progress response
	// (DELETE /v1/conversations/{conversationId}/response)
	DeleteConversationResponse(ctx context.Context, request DeleteConversationResponseRequestObject) (DeleteConversationResponseResponseObject, error)
	// Delete a memory item
	// (DELETE /v1/memories)
	DeleteMemory(ctx context.Context, request DeleteMemoryRequestObject) (DeleteMemoryResponseObject, error)
	// Get a memory item
	// (GET /v1/memories)
	GetMemory(ctx context.Context, request GetMemoryRequestObject) (GetMemoryResponseObject, error)
	// Upsert a memory item
	// (PUT /v1/memories)
	PutMemory(ctx context.Context, request PutMemoryRequestObject) (PutMemoryResponseObject, error)
	// List memory lifecycle events
	// (GET /v1/memories/events)
	ListMemoryEvents(ctx context.Context, request ListMemoryEventsRequestObject) (ListMemoryEventsResponseObject, error)
	// List memory namespaces
	// (GET /v1/memories/namespaces)
	ListMemoryNamespaces(ctx context.Context, request ListMemoryNamespacesRequestObject) (ListMemoryNamespacesResponseObject, error)
	// Search memory items
	// (POST /v1/memories/search)
	SearchMemories(ctx context.Context, request SearchMemoriesRequestObject) (SearchMemoriesResponseObject, error)
	// List pending ownership transfers
	// (GET /v1/ownership-transfers)
	ListPendingTransfers(ctx context.Context, request ListPendingTransfersRequestObject) (ListPendingTransfersResponseObject, error)
	// Request ownership transfer
	// (POST /v1/ownership-transfers)
	CreateOwnershipTransfer(ctx context.Context, request CreateOwnershipTransferRequestObject) (CreateOwnershipTransferResponseObject, error)
	// Cancel or reject ownership transfer
	// (DELETE /v1/ownership-transfers/{transferId})
	DeleteTransfer(ctx context.Context, request DeleteTransferRequestObject) (DeleteTransferResponseObject, error)
	// Get transfer details
	// (GET /v1/ownership-transfers/{transferId})
	GetTransfer(ctx context.Context, request GetTransferRequestObject) (GetTransferResponseObject, error)
	// Accept ownership transfer
	// (POST /v1/ownership-transfers/{transferId}/accept)
	AcceptTransfer(ctx context.Context, request AcceptTransferRequestObject) (AcceptTransferResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadAttachment operation middleware
func (sh *strictHandler) UploadAttachment(ctx *gin.Context, params UploadAttachmentParams) {
	var request UploadAttachmentRequestObject

	request.Params = params
	if strings.HasPrefix(ctx.GetHeader("Content-Type"), "application/json") {

		var body UploadAttachmentJSONRequestBody
		if err := ctx.ShouldBindJSON(&body); err != nil {
			ctx.Status(http.StatusBadRequest)
			ctx.Error(err)
			return
		}
		request.JSONBody = &body
	}
	if strings.HasPrefix(ctx.GetHeader("Content-Type"), "multipart/form-data") {
		if reader, err := ctx.Request.MultipartReader(); err == nil {
			request.MultipartBody = reader
		} else {
			ctx.Error(err)
			return
		}
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadAttachment(ctx, request.(UploadAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadAttachmentResponseObject); ok {
		if err := validResponse.VisitUploadAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadAttachmentByToken operation middleware
func (sh *strictHandler) DownloadAttachmentByToken(ctx *gin.Context, token string, filename string) {
	var request DownloadAttachmentByTokenRequestObject

	request.Token = token
	request.Filename = filename

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadAttachmentByToken(ctx, request.(DownloadAttachmentByTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadAttachmentByToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DownloadAttachmentByTokenResponseObject); ok {
		if err := validResponse.VisitDownloadAttachmentByTokenResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteAttachment operation middleware
func (sh *strictHandler) DeleteAttachment(ctx *gin.Context, id openapi_types.UUID) {
	var request DeleteAttachmentRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteAttachment(ctx, request.(DeleteAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteAttachmentResponseObject); ok {
		if err := validResponse.VisitDeleteAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAttachment operation middleware
func (sh *strictHandler) GetAttachment(ctx *gin.Context, id openapi_types.UUID) {
	var request GetAttachmentRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAttachment(ctx, request.(GetAttachmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAttachment")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetAttachmentResponseObject); ok {
		if err := validResponse.VisitGetAttachmentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAttachmentDownloadUrl operation middleware
func (sh *strictHandler) GetAttachmentDownloadUrl(ctx *gin.Context, id openapi_types.UUID) {
	var request GetAttachmentDownloadUrlRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAttachmentDownloadUrl(ctx, request.(GetAttachmentDownloadUrlRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAttachmentDownloadUrl")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetAttachmentDownloadUrlResponseObject); ok {
		if err := validResponse.VisitGetAttachmentDownloadUrlResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversations operation middleware
func (sh *strictHandler) ListConversations(ctx *gin.Context, params ListConversationsParams) {
	var request ListConversationsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversations(ctx, request.(ListConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationsResponseObject); ok {
		if err := validResponse.VisitListConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateConversation operation middleware
func (sh *strictHandler) CreateConversation(ctx *gin.Context) {
	var request CreateConversationRequestObject

	var body CreateConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConversation(ctx, request.(CreateConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateConversationResponseObject); ok {
		if err := validResponse.VisitCreateConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// IndexConversations operation middleware
func (sh *strictHandler) IndexConversations(ctx *gin.Context) {
	var request IndexConversationsRequestObject

	var body IndexConversationsJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.IndexConversations(ctx, request.(IndexConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "IndexConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(IndexConversationsResponseObject); ok {
		if err := validResponse.VisitIndexConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// SearchConversations operation middleware
func (sh *strictHandler) SearchConversations(ctx *gin.Context) {
	var request SearchConversationsRequestObject

	var body SearchConversationsJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchConversations(ctx, request.(SearchConversationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchConversations")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SearchConversationsResponseObject); ok {
		if err := validResponse.VisitSearchConversationsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUnindexedEntries operation middleware
func (sh *strictHandler) ListUnindexedEntries(ctx *gin.Context, params ListUnindexedEntriesParams) {
	var request ListUnindexedEntriesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListUnindexedEntries(ctx, request.(ListUnindexedEntriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUnindexedEntries")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListUnindexedEntriesResponseObject); ok {
		if err := validResponse.VisitListUnindexedEntriesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversation operation middleware
func (sh *strictHandler) DeleteConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request DeleteConversationRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversation(ctx, request.(DeleteConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationResponseObject); ok {
		if err := validResponse.VisitDeleteConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConversation operation middleware
func (sh *strictHandler) GetConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request GetConversationRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConversation(ctx, request.(GetConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConversationResponseObject); ok {
		if err := validResponse.VisitGetConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateConversation operation middleware
func (sh *strictHandler) UpdateConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request UpdateConversationRequestObject

	request.ConversationId = conversationId

	var body UpdateConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConversation(ctx, request.(UpdateConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateConversationResponseObject); ok {
		if err := validResponse.VisitUpdateConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationEntries operation middleware
func (sh *strictHandler) ListConversationEntries(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationEntriesParams) {
	var request ListConversationEntriesRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationEntries(ctx, request.(ListConversationEntriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationEntries")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationEntriesResponseObject); ok {
		if err := validResponse.VisitListConversationEntriesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AppendConversationEntry operation middleware
func (sh *strictHandler) AppendConversationEntry(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request AppendConversationEntryRequestObject

	request.ConversationId = conversationId

	var body AppendConversationEntryJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AppendConversationEntry(ctx, request.(AppendConversationEntryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AppendConversationEntry")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AppendConversationEntryResponseObject); ok {
		if err := validResponse.VisitAppendConversationEntryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// SyncConversationMemory operation middleware
func (sh *strictHandler) SyncConversationMemory(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request SyncConversationMemoryRequestObject

	request.ConversationId = conversationId

	var body SyncConversationMemoryJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SyncConversationMemory(ctx, request.(SyncConversationMemoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SyncConversationMemory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SyncConversationMemoryResponseObject); ok {
		if err := validResponse.VisitSyncConversationMemoryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationForks operation middleware
func (sh *strictHandler) ListConversationForks(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationForksParams) {
	var request ListConversationForksRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationForks(ctx, request.(ListConversationForksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationForks")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationForksResponseObject); ok {
		if err := validResponse.VisitListConversationForksResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConversationMemberships operation middleware
func (sh *strictHandler) ListConversationMemberships(ctx *gin.Context, conversationId openapi_types.UUID, params ListConversationMembershipsParams) {
	var request ListConversationMembershipsRequestObject

	request.ConversationId = conversationId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListConversationMemberships(ctx, request.(ListConversationMembershipsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConversationMemberships")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListConversationMembershipsResponseObject); ok {
		if err := validResponse.VisitListConversationMembershipsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShareConversation operation middleware
func (sh *strictHandler) ShareConversation(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request ShareConversationRequestObject

	request.ConversationId = conversationId

	var body ShareConversationJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ShareConversation(ctx, request.(ShareConversationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShareConversation")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ShareConversationResponseObject); ok {
		if err := validResponse.VisitShareConversationResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversationMembership operation middleware
func (sh *strictHandler) DeleteConversationMembership(ctx *gin.Context, conversationId openapi_types.UUID, userId string) {
	var request DeleteConversationMembershipRequestObject

	request.ConversationId = conversationId
	request.UserId = userId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversationMembership(ctx, request.(DeleteConversationMembershipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversationMembership")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationMembershipResponseObject); ok {
		if err := validResponse.VisitDeleteConversationMembershipResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateConversationMembership operation middleware
func (sh *strictHandler) UpdateConversationMembership(ctx *gin.Context, conversationId openapi_types.UUID, userId string) {
	var request UpdateConversationMembershipRequestObject

	request.ConversationId = conversationId
	request.UserId = userId

	var body UpdateConversationMembershipJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConversationMembership(ctx, request.(UpdateConversationMembershipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConversationMembership")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateConversationMembershipResponseObject); ok {
		if err := validResponse.VisitUpdateConversationMembershipResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConversationResponse operation middleware
func (sh *strictHandler) DeleteConversationResponse(ctx *gin.Context, conversationId openapi_types.UUID) {
	var request DeleteConversationResponseRequestObject

	request.ConversationId = conversationId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConversationResponse(ctx, request.(DeleteConversationResponseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConversationResponse")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteConversationResponseResponseObject); ok {
		if err := validResponse.VisitDeleteConversationResponseResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteMemory operation middleware
func (sh *strictHandler) DeleteMemory(ctx *gin.Context, params DeleteMemoryParams) {
	var request DeleteMemoryRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteMemory(ctx, request.(DeleteMemoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteMemory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteMemoryResponseObject); ok {
		if err := validResponse.VisitDeleteMemoryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetMemory operation middleware
func (sh *strictHandler) GetMemory(ctx *gin.Context, params GetMemoryParams) {
	var request GetMemoryRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetMemory(ctx, request.(GetMemoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMemory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetMemoryResponseObject); ok {
		if err := validResponse.VisitGetMemoryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutMemory operation middleware
func (sh *strictHandler) PutMemory(ctx *gin.Context) {
	var request PutMemoryRequestObject

	var body PutMemoryJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PutMemory(ctx, request.(PutMemoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutMemory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(PutMemoryResponseObject); ok {
		if err := validResponse.VisitPutMemoryResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListMemoryEvents operation middleware
func (sh *strictHandler) ListMemoryEvents(ctx *gin.Context, params ListMemoryEventsParams) {
	var request ListMemoryEventsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListMemoryEvents(ctx, request.(ListMemoryEventsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListMemoryEvents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListMemoryEventsResponseObject); ok {
		if err := validResponse.VisitListMemoryEventsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListMemoryNamespaces operation middleware
func (sh *strictHandler) ListMemoryNamespaces(ctx *gin.Context, params ListMemoryNamespacesParams) {
	var request ListMemoryNamespacesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListMemoryNamespaces(ctx, request.(ListMemoryNamespacesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListMemoryNamespaces")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListMemoryNamespacesResponseObject); ok {
		if err := validResponse.VisitListMemoryNamespacesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// SearchMemories operation middleware
func (sh *strictHandler) SearchMemories(ctx *gin.Context) {
	var request SearchMemoriesRequestObject

	var body SearchMemoriesJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchMemories(ctx, request.(SearchMemoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchMemories")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SearchMemoriesResponseObject); ok {
		if err := validResponse.VisitSearchMemoriesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPendingTransfers operation middleware
func (sh *strictHandler) ListPendingTransfers(ctx *gin.Context, params ListPendingTransfersParams) {
	var request ListPendingTransfersRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListPendingTransfers(ctx, request.(ListPendingTransfersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPendingTransfers")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListPendingTransfersResponseObject); ok {
		if err := validResponse.VisitListPendingTransfersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateOwnershipTransfer operation middleware
func (sh *strictHandler) CreateOwnershipTransfer(ctx *gin.Context) {
	var request CreateOwnershipTransferRequestObject

	var body CreateOwnershipTransferJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateOwnershipTransfer(ctx, request.(CreateOwnershipTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateOwnershipTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateOwnershipTransferResponseObject); ok {
		if err := validResponse.VisitCreateOwnershipTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteTransfer operation middleware
func (sh *strictHandler) DeleteTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request DeleteTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteTransfer(ctx, request.(DeleteTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteTransferResponseObject); ok {
		if err := validResponse.VisitDeleteTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTransfer operation middleware
func (sh *strictHandler) GetTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request GetTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetTransfer(ctx, request.(GetTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetTransferResponseObject); ok {
		if err := validResponse.VisitGetTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AcceptTransfer operation middleware
func (sh *strictHandler) AcceptTransfer(ctx *gin.Context, transferId openapi_types.UUID) {
	var request AcceptTransferRequestObject

	request.TransferId = transferId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AcceptTransfer(ctx, request.(AcceptTransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AcceptTransfer")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AcceptTransferResponseObject); ok {
		if err := validResponse.VisitAcceptTransferResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

---
layout: ../../../layouts/DocsLayout.astro
title: Spring Getting Started
description: Step-by-step guide to integrating Memory Service with your Spring Boot AI agent.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import CodeFromFile from '../../../components/CodeFromFile.astro';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide walks you through integrating Memory Service with a Spring Boot AI agent. You'll start with basic chat memory and can progressively add features in the follow-up guides.

Make sure you've completed the [prerequisites](/docs/spring/) before starting this guide.

## Step 1: Create a Simple Spring AI App

**Starting checkpoint**: View the complete code at [spring/examples/doc-checkpoints/01-basic-agent](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/01-basic-agent)

First, let's create a new Spring Boot application. Use [Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.10&packaging=jar&configurationFileFormat=properties&jvmVersion=21&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=spring-ai-openai,web) to setup the project.
Make sure to use Spring Boot 3.5 as that the latest version supported by Spring AI and add the OpenAI and Spring Web dependencies.

Once you download the starter project extract it and open it in your favorite IDE.

```bash
unzip demo.zip
cd demo
```


Create a simple REST controller:

<CodeFromFile
  file="spring/examples/doc-checkpoints/01-basic-agent/src/main/java/com/example/demo/ChatController.java"
  lang="java"
/>

**Why**: This is the minimal wiring needed to call an LLM from a Spring Boot app. `ChatClient` is Spring AI's fluent facade over the underlying model; injecting `ChatClient.Builder` lets Spring Boot auto-configure the OpenAI connection from properties, so the controller stays free of credential logic.

Configure the server port and OpenAI credentials in `application.properties`:

<CodeFromFile
  file="spring/examples/doc-checkpoints/01-basic-agent/src/main/resources/application.properties"
  lang="properties"
/>

**Why**: Keeping credentials in environment variables rather than hardcoded values prevents secrets from being committed to source control and makes it straightforward to point the app at a different model or a local proxy without code changes.

<TestScenario checkpoint="spring/examples/doc-checkpoints/01-basic-agent">

Run your agent:

```bash
export OPENAI_API_KEY=your-api-key
```
```bash
./mvnw spring-boot:run
```

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response body should be text:
"""
Hello Hiram! I'm an AI language model created by OpenAI, here to help answer questions and provide information on a wide range of topics. How can I assist you today?
"""
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat \
  -H "Content-Type: application/json" \
  -d '"Hi, I'\''m Hiram, who are you?"'
```

</CurlTest>

**Expected**: The agent responds but has no memory of your name.

<CurlTest steps={`
Then the response status should be 200
And the response should not contain "Hiram"
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat \
  -H "Content-Type: application/json" \
  -d '"Who am I?"'
```

</CurlTest>

</TestScenario>

Let's add conversation memory.

## Step 2: Add Memory Service Starter

**Starting checkpoint**: View the complete code at [spring/examples/doc-checkpoints/02-with-memory](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/02-with-memory)

Add the Memory Service Spring Boot starter and OAuth2 resource server dependencies to your `pom.xml`:

<Code lang="xml" code={`<dependency>
    <groupId>io.github.chirino.memory-service</groupId>
    <artifactId>memory-service-spring-boot-starter</artifactId>
    <version>${PROJECT_VERSION}</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
`} />

Start the Memory Service in Docker Compose following the [Getting Started](/docs/getting-started/) guide.

Configure the connection to the Memory Service in `application.properties`:

```properties
memory-service.client.base-url=http://localhost:8082
memory-service.client.api-key=agent-api-key-1
memory-service.client.log-requests=true
```

Configure OAuth2 in `application.properties`. The client configuration supports browser-based login, while the resource server configuration enables Bearer token authentication for API clients:

```properties
# OAuth2 client configuration (for browser-based login)
spring.security.oauth2.client.provider.memory-service-client.issuer-uri=http://localhost:8081/realms/memory-service
spring.security.oauth2.client.registration.memory-service-client.client-id=memory-service-client
spring.security.oauth2.client.registration.memory-service-client.client-secret=change-me
spring.security.oauth2.client.registration.memory-service-client.scope=openid,profile,email
spring.security.oauth2.client.registration.memory-service-client.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.memory-service-client.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}

# OAuth2 resource server configuration (for Bearer token authentication)
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8081/realms/memory-service
```

Configure security:

<CodeFromFile
  file="spring/examples/doc-checkpoints/02-with-memory/src/main/java/com/example/demo/SecurityConfig.java"
  lang="java"
/>

**What changed**: A `SecurityConfig` bean enables both `oauth2Login` (browser session-based) and `oauth2ResourceServer` JWT validation (Bearer token) in a single filter chain, with CSRF disabled and every request requiring authentication.

**Why**: Agent apps typically need to serve two audiences at once — browser users who log in interactively via Keycloak, and API clients (curl, frontends, other services) that present a Bearer token. Enabling both modes in one chain means you don't need separate endpoints or ports; Spring Security picks the right authentication mechanism based on the `Authorization` header present in each request.

Update the controller to use chat memory:

<CodeFromFile
  file="spring/examples/doc-checkpoints/02-with-memory/src/main/java/com/example/demo/ChatController.java"
  lang="java"
/>

**What changed**: The endpoint now accepts a `{conversationId}` path variable, retrieves the authenticated user's Bearer token via `SecurityHelper.bearerToken()`, builds a `MessageWindowChatMemory` backed by the Memory Service using `MemoryServiceChatMemoryRepositoryBuilder`, wraps it in a `MessageChatMemoryAdvisor`, and passes the conversation ID as an advisor parameter.

**Why**: `MemoryServiceChatMemoryRepositoryBuilder.build(bearerToken)` creates a repository that reads and writes the agent's context window to and from the Memory Service under the current user's identity, so every user's conversation history is stored separately and securely. `MessageWindowChatMemory` keeps only the most recent N messages in the prompt, preventing the context window from growing unbounded across many turns.

<TestScenario checkpoint="spring/examples/doc-checkpoints/02-with-memory">

Run your agent again:

```bash
export OPENAI_API_KEY=your-api-key
./mvnw spring-boot:run
```

Make sure you define a shell function that can get the bearer token for the bob user:

```bash
function get-token() {
  curl -sSfX POST http://localhost:8081/realms/memory-service/protocol/openid-connect/token \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=memory-service-client" \
    -d "client_secret=change-me" \
    -d "grant_type=password" \
    -d "username=bob" \
    -d "password=bob" \
    | jq -r '.access_token'
}
```

Test it with curl—now with conversation memory:

<CurlTest steps={`
Then the response status should be 200
And the response body should be text:
"""
Hello Hiram! I'm an AI assistant here to help you with any questions or information you might need. How can I assist you today?
"""
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/2cdbd4b0-b48d-4f75-8f7a-9616301e5143 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $(get-token)" \
  -d '"Hi, I'\''m Hiram, who are you?"'
```

</CurlTest>

<CurlTest steps={`
Then the response status should be 200
And the response should contain "Hiram"
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/2cdbd4b0-b48d-4f75-8f7a-9616301e5143 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $(get-token)" \
  -d '"Who am I?"'
```

</CurlTest>

</TestScenario>

If you browse to the demo agent app at [http://localhost:8080/](http://localhost:8080/), you will see that a conversation has been created with the ID `2cdbd4b0-b48d-4f75-8f7a-9616301e5143`.
But it won't show any messages.  That's because we are not yet storing what we call the history of the conversation.  The only thing being stored is the agent memory, and
that's not typically what you want to display to a user in a UI.

## Next Steps

Continue to [Conversation History](/docs/spring/conversation-history/) to learn how to:
- Record conversation history for frontend display
- Expose conversation APIs (messages, listing)
- Build a complete chat UI experience

Or jump ahead to:
- [Conversation Forking](/docs/spring/conversation-forking/) - Branch conversations to explore alternative paths
- [Response Resumption](/docs/spring/response-resumption/) - Streaming responses with resume and cancel support


---
layout: ../../../layouts/DocsLayout.astro
title: Response Resumption
description: Streaming responses, response resumption, and cancellation.
---
import CodeFromFile from '../../../components/CodeFromFile.astro';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide covers streaming responses, response resumption, and cancellation â€” so users can reconnect after a disconnect and pick up where they left off. For a conceptual overview of how response resumption works, including the gRPC service contract and multi-instance redirect behavior, see [Response Resumption Concepts](/docs/concepts/response-resumption/).

## Prerequisites

**Starting checkpoint**: This guide starts from [spring/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/03-with-history)

Make sure you've completed the previous guides:
- [Getting Started](/docs/spring/getting-started/) - Basic memory service integration
- [Conversation History](/docs/spring/conversation-history/) - History recording and APIs

## Streaming Responses

When users disconnect during a streaming response (page reload, network issues), you can resume the streaming response from where they left off. This requires that the agent uses streaming responses. Let's update the agent to use streaming responses with `Flux<String>` and Server-Sent Events (SSE).

Update `ChatController.java` to use streaming:

<CodeFromFile
  file="spring/examples/doc-checkpoints/05-response-resumption/src/main/java/com/example/demo/ChatController.java"
  lang="java"
/>

**What changed**: The return type changes from `String` to `SseEmitter`. The chat client's `.call().content()` is replaced with `.stream().content()`, which returns a `Flux<String>`. Tokens from that flux are forwarded to the `SseEmitter` chunk by chunk, and the subscription is disposed when the emitter completes or times out.

**Why**: Server-Sent Events (SSE) allow the browser to receive tokens as they are generated rather than waiting for the full response. This makes the app feel significantly more responsive for longer answers. The `SseEmitter` with a `0L` timeout means the connection stays open indefinitely until the stream finishes, the client disconnects, or a cancel request arrives.

<TestScenario checkpoint="spring/examples/doc-checkpoints/05-response-resumption">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response should match pattern "\\w+"
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/8337ca02-62de-43e1-b69b-c663cb50acc4 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Write a 4 paragraph story about a cat."
```

</CurlTest>

</TestScenario>

You should see the response streaming to your command line.

Now browse to the demo agent app at [http://localhost:8080/?conversationId=8337ca02-62de-43e1-b69b-c663cb50acc4](http://localhost:8080/?conversationId=8337ca02-62de-43e1-b69b-c663cb50acc4)
and you should see the response streaming to the browser.

## Response Resumption

<CodeFromFile
  file="spring/examples/doc-checkpoints/05-response-resumption/src/main/java/com/example/demo/ResumeController.java"
  lang="java"
/>

**What changed**: A new `ResumeController` is introduced at `/v1/conversations` with three endpoints: `POST /resume-check` (batch check for in-progress responses), `GET /{conversationId}/resume` (SSE stream that replays the buffered response), and `POST /{conversationId}/cancel` (stops an in-progress response). It depends on the auto-configured `ResponseResumer` and `MemoryServiceProxy` beans.

**Why**: When a user's browser disconnects mid-stream (page reload, network drop), the LLM response continues generating on the server but is lost to the client. `ResponseResumer` buffers the in-flight tokens in the Memory Service so a reconnecting client can call `/resume` and receive the complete response from the beginning, giving a seamless experience. The cancel endpoint lets users or the frontend interrupt a long-running generation without leaving the server in an orphaned state.

Test it with curl:

```bash
curl -NsSfX POST http://localhost:9090/chat/8337ca02-62de-43e1-b69b-c663cb50acc4 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Write a 4 paragraph story about a cat."
```

And while the response is streaming, you can check use the following to check to see if the conversation has responses in progress:

```bash
curl -sSfX POST http://localhost:9090/v1/conversations/resume-check \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $(get-token)" \
  -d '["8337ca02-62de-43e1-b69b-c663cb50acc4"]' | jq
```

And to resume a conversation, you can run the following command in a new terminal:

```bash
curl -NsSfX GET http://localhost:9090/v1/conversations/8337ca02-62de-43e1-b69b-c663cb50acc4/resume \
  -H "Authorization: Bearer $(get-token)"
```

You should see the response streaming to your command line.

## Canceling a Response

To cancel a response, you can run the following command:

```bash
curl -sSfX POST http://localhost:9090/v1/conversations/8337ca02-62de-43e1-b69b-c663cb50acc4/cancel \
  -H "Authorization: Bearer $(get-token)"
```

You should see the response get canceled.

## Next Steps

- [Conversation Sharing](/docs/spring/sharing/) - Share conversations with other users.
- [Docker Compose Integration](/docs/spring/docker-compose/) - Automatic memory-service container startup for development and testing.

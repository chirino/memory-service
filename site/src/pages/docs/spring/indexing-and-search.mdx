---
layout: ../../../layouts/DocsLayout.astro
title: Indexing and Search
description: Add search indexing and semantic search to your conversations.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import CodeFromFile from '../../../components/CodeFromFile.astro';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide continues from [Conversation History](/docs/spring/conversation-history/) and shows how to add search indexing to your conversation history entries and expose a search API for frontend applications.

> **ðŸ’¡ New to indexing and search concepts?**
> Read [Indexing & Search](/docs/concepts/indexing-and-search/) first to understand how search indexing, content redaction, and search types work. This guide focuses on the Spring Boot implementation.

## Prerequisites

**Starting checkpoint**: View the code from the previous section at [spring/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/03-with-history)

Make sure you've completed the [Conversation History](/docs/spring/conversation-history/) guide first. You should have:
- Conversation history recording with `ConversationHistoryStreamAdvisor`
- Conversation APIs exposed via `MemoryServiceProxyController`
- Memory Service running via Docker Compose

## How Search Indexing Works

When you record conversation history, message content is stored encrypted on disk. This is great for security, but it means the content can't be searched directly.

To enable search, the Memory Service uses a separate `indexedContent` field on each history entry. This field stores a searchable (unencrypted) version of the message text. When an `IndexedContentProvider` bean is available, the history recorder automatically calls it to transform each message into indexed content before storing the entry.

This design gives your application a chance to **redact sensitive information** before it's written to the search index in cleartext. For example, you might strip credit card numbers, social security numbers, or other PII from the indexed text while keeping the full content in the encrypted message.

## Add an IndexedContentProvider

To enable search indexing, create a bean that implements the `IndexedContentProvider` interface. The simplest implementation passes text through unchanged:

<CodeFromFile
  file="spring/examples/doc-checkpoints/07-with-search/src/main/java/com/example/demo/PassThroughIndexedContentProvider.java"
  lang="java"
/>

The `IndexedContentProvider` interface has a single method:
- **`getIndexedContent(String text, String role)`** â€” Transforms message text into content for the search index. The `role` parameter is either `"USER"` or `"AI"`. Return `null` to skip indexing for that message.

Spring Boot auto-configuration automatically discovers your `IndexedContentProvider` bean. When present, every message recorded by the `ConversationHistoryStreamAdvisor` will have its `indexedContent` field populated.

### Custom Redaction

For production applications, you'll likely want to redact sensitive information. Start from the same provider method and replace the return line with:
`text.replaceAll("\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b", "[REDACTED]")`

<CodeFromFile
  file="spring/examples/doc-checkpoints/07-with-search/src/main/java/com/example/demo/PassThroughIndexedContentProvider.java"
  lang="java"
  before={1}
  after={2}
>public String getIndexedContent(String text, String role)</CodeFromFile>

You can also return `null` to skip indexing entirely for certain messages â€” for example, you might choose not to index AI responses:

`if ("AI".equals(role)) { return null; }`

## Expose the Search API

To let the frontend search across conversations, add a search endpoint to your `MemoryServiceProxyController`:

<CodeFromFile
  file="spring/examples/doc-checkpoints/07-with-search/src/main/java/com/example/demo/MemoryServiceProxyController.java"
  lang="java"
  before={1}
  after={2}
>searchConversations(@RequestBody</CodeFromFile>

This endpoint accepts a JSON request body with the following fields:
- **`query`** (required) â€” The search query text
- **`searchType`** â€” `"auto"` (default), `"semantic"`, or `"fulltext"`
- **`limit`** â€” Maximum number of results (default 20)
- **`groupByConversation`** â€” Group results by conversation (default true)
- **`includeEntry`** â€” Include the full entry in results (default true)

<TestScenario checkpoint="spring/examples/doc-checkpoints/07-with-search">

First, send a message so there's something to search for:

<CurlTest steps={`
Then the response status should be 200
And the response body should be text:
"""
Sure! Here's a random number between 1 and 100: **42**.
"""
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/9f95b53b-4e99-4fab-b929-35a3c5e91f1b \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Give me a random number between 1 and 100."
```

</CurlTest>

</TestScenario>

Now search for it:

```bash
curl -sSfX POST http://localhost:9090/v1/conversations/search \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $(get-token)" \
  -d '{"query": "random number"}' | jq
```

Example response:

```json
{
  "data": [
    {
      "conversationId": "9f95b53b-4e99-4fab-b929-35a3c5e91f1b",
      "conversationTitle": "Give me a random number between 1 and 100",
      "entryId": "d15ab065-ab94-4856-8def-a040d6d2d9db",
      "score": 0.95,
      "highlights": ["Give me a ==random number== between 1 and 100"],
      "entry": {
        "id": "d15ab065-ab94-4856-8def-a040d6d2d9db",
        "conversationId": "9f95b53b-4e99-4fab-b929-35a3c5e91f1b",
        "userId": "bob",
        "channel": "history",
        "contentType": "history",
        "content": [{"role": "USER", "text": "Give me a random number between 1 and 100."}],
        "createdAt": "2025-01-10T14:32:05Z"
      }
    }
  ],
  "nextCursor": null
}
```

Search results include:
- **`conversationId`** and **`conversationTitle`** â€” For linking to the conversation
- **`entryId`** â€” For deep-linking to a specific message
- **`score`** â€” Relevance score
- **`highlights`** â€” Matched text with `==highlight==` markers
- **`entry`** â€” The full entry content (when `includeEntry` is true)

## Completed Checkpoint

**Completed code**: View the full implementation at [spring/examples/doc-checkpoints/07-with-search](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/07-with-search)

## Next Steps

Continue to:
- [Conversation Forking](/docs/spring/conversation-forking/) â€” Branch conversations to explore alternative paths
- [Response Resumption](/docs/spring/response-resumption/) â€” Streaming responses with resume and cancel support

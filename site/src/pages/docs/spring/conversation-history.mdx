---
layout: ../../../layouts/DocsLayout.astro
title: Conversation History
description: Record conversation history and expose APIs for frontend applications.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import CodeFromFile from '../../../components/CodeFromFile.astro';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide continues from [Getting Started](/docs/spring/getting-started/) and shows how to record conversation history and expose APIs for frontend applications.

## Prerequisites

**Starting checkpoint**: View the code from the previous section at [spring/examples/doc-checkpoints/02-with-memory](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/02-with-memory)

Make sure you've completed the [Getting Started](/docs/spring/getting-started/) guide first. You should have:
- A working Spring Boot agent with the Memory Service starter
- Memory Service running via Docker Compose
- OAuth2 authentication configured

## Understanding Memory vs History

There are two types of message storage in Memory Service:

- **Agent Memory** - Internal context window for the LLM, stored in the `memory` channel. This is what the agent uses to maintain context across messages.
- **Conversation History** - What users see in the UI, stored in the `history` channel. This records the actual messages exchanged between users and the agent.

In the previous guide, we only added agent memory. To display conversation history in a frontend UI, we need to also record history.

## Enable History Recording

The Memory Service starter provides `ConversationHistoryStreamAdvisorBuilder` which creates an advisor that automatically records user messages and agent responses to the `history` channel.

Update your controller to include the history advisor:

<CodeFromFile
  file="spring/examples/doc-checkpoints/03-with-history/src/main/java/com/example/demo/ChatController.java"
  lang="java"
/>

**What changed**: A `ConversationHistoryStreamAdvisorBuilder` is injected and used to create a `historyAdvisor` that is registered alongside the existing memory advisor. The history advisor is listed first so it intercepts both the outgoing user message and the incoming AI response.

**Why**: The memory advisor only writes messages to the internal `memory` channel that the LLM uses for context; it does not produce entries visible in a frontend UI. The history advisor writes to the `history` channel, which is what the demo app (and any chat frontend) reads to display the conversation thread to the user.

Run your agent again:

```bash
./mvnw spring-boot:run
```

<TestScenario checkpoint="spring/examples/doc-checkpoints/03-with-history">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response body should be text:
"""
Sure! Here's a random number between 1 and 100: **42**.
"""
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/564f4b5f-789c-473b-adbf-44ed85de5550 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Give me a random number between 1 and 100."
```

</CurlTest>

</TestScenario>

This time when you browse to to the demo agent app at
[http://localhost:8080/?conversationId=564f4b5f-789c-473b-adbf-44ed85de5550](http://localhost:8080/?conversationId=564f4b5f-789c-473b-adbf-44ed85de5550)
you should see the messages that were exchanged between you and the agent.

## Expose Conversation APIs

The Memory Service starter auto-configures a `MemoryServiceProxy` bean that makes it easy to expose conversation APIs to your frontend.

Create a REST controller that proxies requests to Memory Service:

<CodeFromFile
  file="spring/examples/doc-checkpoints/03-with-history/src/main/java/com/example/demo/MemoryServiceProxyController.java"
  lang="java"
/>

**What changed**: A new `MemoryServiceProxyController` is introduced, mapping to `/v1/conversations`. It injects the auto-configured `MemoryServiceProxy` bean and exposes three endpoints: `GET /{conversationId}` to fetch a single conversation, `GET /{conversationId}/entries` to list its messages (filtered by channel, cursor, and epoch), and `GET /` to list all conversations with pagination and query filtering.

**Why**: Frontend SPAs and mobile clients need to query conversation data directly without going through the agent's chat endpoint. By proxying these calls through your Spring Boot app, the Memory Service never needs to be exposed to the public internet, and the `MemoryServiceProxy` handles auth forwarding — it injects the service-account API key for the backend leg while propagating the user's Bearer token for access control.

The `MemoryServiceProxy` also handles proper error handling and response mapping.

<TestScenario checkpoint="spring/examples/doc-checkpoints/03-with-history">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response body should be json:
"""
{
  "id": "564f4b5f-789c-473b-adbf-44ed85de5550",
  "title": "%{response.body.title}",
  "ownerUserId": "bob",
  "createdAt": "%{response.body.createdAt}",
  "updatedAt": "%{response.body.updatedAt}",
  "lastMessagePreview": null,
  "accessLevel": "owner",
  "forkedAtEntryId": null,
  "forkedAtConversationId": null
}
"""
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations/564f4b5f-789c-473b-adbf-44ed85de5550 \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

<CurlTest steps={`
Then the response status should be 200
And the response should contain "Give me a random number"
And the response should contain "history"
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations/564f4b5f-789c-473b-adbf-44ed85de5550/entries \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

Example response:

```json
{
  "data": [
    {
      "id": "ca29a4e1-f112-44d2-8a5b-425f3b3bccce",
      "conversationId": "564f4b5f-789c-473b-adbf-44ed85de5550",
      "userId": "bob",
      "channel": "history",
      "epoch": null,
      "contentType": "history",
      "content": [{"role": "USER", "text": "Give me a random number between 1 and 100."}],
      "createdAt": "2025-01-10T14:32:05Z"
    },
    {
      "id": "c13fbe60-1162-4c7b-b48c-e759a490c089",
      "conversationId": "564f4b5f-789c-473b-adbf-44ed85de5550",
      "userId": "bob",
      "channel": "history",
      "epoch": null,
      "contentType": "history",
      "content": [{"role": "AI", "text": "Sure! Here's a random number between 1 and 100: **42**."}],
      "createdAt": "2025-01-10T14:32:06Z"
    }
  ],
  "nextCursor": null
}
```

</TestScenario>

## Expose Conversation Listing API

The `MemoryServiceProxyController` already includes the `listConversations` method (shown in the full code above). This endpoint supports:
- **Pagination** via `after` (cursor) and `limit` parameters
- **Search** via the `query` parameter for filtering conversations
- **Mode** for different listing modes (e.g., `owned`, `shared`)

<TestScenario checkpoint="spring/examples/doc-checkpoints/03-with-history">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response should contain "564f4b5f-789c-473b-adbf-44ed85de5550"
And the response should contain "owner"
And the response should contain "bob"
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

Example response:

```json
{
  "data": [
    {
      "id": "564f4b5f-789c-473b-adbf-44ed85de5550",
      "title": "Give me a random number between 1 and 10",
      "ownerUserId": "bob",
      "createdAt": "2025-01-10T14:32:05Z",
      "updatedAt": "2025-01-10T14:32:06Z",
      "lastMessagePreview": null,
      "accessLevel": "owner"
    }
  ],
  "nextCursor": null
}
```

</TestScenario>

## Completed Checkpoint

**Completed code**: View the full implementation at [spring/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/spring/examples/doc-checkpoints/03-with-history)

## Next Steps

Continue to:
- [Indexing and Search](/docs/spring/indexing-and-search/) — Add search indexing and semantic search to your conversations
- [Conversation Forking](/docs/spring/conversation-forking/) — Branch conversations to explore alternative paths
- [Response Resumption](/docs/spring/response-resumption/) — Streaming responses with resume and cancel support

---
layout: ../../../layouts/DocsLayout.astro
title: Response Resumption
description: Streaming responses, response resumption, and cancellation.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide covers streaming responses, response resumption, and cancellation â€” so users can reconnect after a disconnect and pick up where they left off. For a conceptual overview of how response resumption works, including the gRPC service contract and multi-instance redirect behavior, see [Response Resumption Concepts](/docs/concepts/response-resumption/).

## Prerequisites

**Starting checkpoint**: This guide starts from [quarkus/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/03-with-history)

Make sure you've completed the previous guides:
- [Getting Started](/docs/quarkus/getting-started/) - Basic memory service integration
- [Conversation History](/docs/quarkus/conversation-history/) - History recording and APIs

## Streaming Responses

When users disconnect during a streaming response (page reload, network issues), you can resume the streaming response from where they left off. This requires that the agent uses streaming responses. Let's update the agent to use streaming responses with `Multi<String>` return types instead of `String`.

Update the `Agent.java` to use streaming responses:

```java
package org.acme;

import dev.langchain4j.service.MemoryId;
import io.quarkiverse.langchain4j.RegisterAiService;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
@RegisterAiService
public interface Agent {
    Multi<String> chat(@MemoryId String conversationId, String userMessage);
}
```

Update the `HistoryRecordingAgent.java` to use streaming responses:

```java
package org.acme;

import io.github.chirino.memory.history.annotations.ConversationId;
import io.github.chirino.memory.history.annotations.RecordConversation;
import io.github.chirino.memory.history.annotations.UserMessage;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class HistoryRecordingAgent {

    private final Agent agent;

    @Inject
    public HistoryRecordingAgent(Agent agent) {
        this.agent = agent;
    }

    @RecordConversation
    public Multi<String> chat(@ConversationId String conversationId, @UserMessage String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}
```

Update `ChatResource.java` to use Server Sent Events (SSE) to stream the responses to the client:

```java
package org.acme;

import io.smallrye.mutiny.Multi;
import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/chat")
public class ChatResource {

    @Inject HistoryRecordingAgent agent;

    @POST
    @Path("/{conversationId}")
    @Consumes(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    public Multi<String> chat(
            @PathParam("conversationId") String conversationId, String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}

```

<TestScenario checkpoint="quarkus/examples/doc-checkpoints/05-response-resumption">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response should match pattern "\\w+"
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Write a 4 paragraph story about a cat."
```

</CurlTest>

</TestScenario>

You should see the response streaming to your command line.

Now browse to the demo agent app at [http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942](http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942)
and you should see the response streaming to the browser.


## Response Resumption

The following creates a REST endpoint that will allow us to:
* Check if a conversation has a response that is in progress
* Resume a response that is in progress
* Cancel a response that is in progress

```java
package org.acme;

import io.github.chirino.memory.history.runtime.ResponseResumer;
import io.github.chirino.memory.runtime.MemoryServiceProxy;
import io.quarkus.security.identity.SecurityIdentity;
import io.smallrye.common.annotation.Blocking;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import java.util.List;

import static io.github.chirino.memory.security.SecurityHelper.bearerToken;

@Path("/v1/conversations")
@ApplicationScoped
public class ResumeResource {

    @Inject ResponseResumer resumer;
    @Inject SecurityIdentity securityIdentity;
    @Inject MemoryServiceProxy proxy;

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Path("/resume-check")
    public List<String> check(List<String> conversationIds) {
        return resumer.check(conversationIds, bearerToken(securityIdentity));
    }

    @GET
    @Path("/{conversationId}/resume")
    @Blocking
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public Multi<String> resume(
            @PathParam("conversationId") String conversationId) {
        String bearerToken = bearerToken(securityIdentity);
        return resumer.replay(conversationId, bearerToken);
    }

    @POST
    @Path("/{conversationId}/cancel")
    public Response cancelResponse(@PathParam("conversationId") String conversationId) {
        return proxy.cancelResponse(conversationId);
    }
}
```

Test it with curl:

```bash
curl -NsSfX POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Write a 4 paragraph story about a cat."
```

And while the response is streaming, you can check use the following to check to see if the conversation has responses in progress:

```bash
curl -sSfX POST http://localhost:9090/v1/conversations/resume-check \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $(get-token)" \
  -d '["3579aac5-c86e-4b67-bbea-6ec1a3644942"]' | jq
```

And to resume a conversation, you can run the following command in a new terminal:

```bash
curl -NsSfX GET http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/resume \
  -H "Authorization: Bearer $(get-token)"
```

You should see the response streaming to your command line.

## Canceling a Response

To cancel a response, you can run the following command:

```bash
curl -sSfX POST http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/cancel \
  -H "Authorization: Bearer $(get-token)"
```

You should see the response get canceled.

## Complete Example

**Completed code**: View the full implementation at [quarkus/examples/doc-checkpoints/05-response-resumption](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/05-response-resumption)

For a complete working example with frontend, see the [quarkus/examples/chat-quarkus](https://github.com/chirino/memory-service/tree/main/quarkus/examples/chat-quarkus) directory in the repository.

This example is the demo agent application that gets started by the [Getting Started](/docs/getting-started/) guide.

## Next Steps

- [Conversation Sharing](/docs/quarkus/sharing/) - Share conversations with other users.
- [Dev Services](/docs/quarkus/dev-services/) - Automatic memory-service container startup for development and testing.

---
layout: ../../../layouts/DocsLayout.astro
title: Conversation Forking
description: Branch conversations to explore alternative paths.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide covers conversation forking â€” letting users branch off from any point in a conversation to explore alternative paths.

> **New to forking concepts?**
> Read [Forking](/docs/concepts/forking/) first to understand how conversation forking works. This guide focuses on the Quarkus implementation.

## Prerequisites

**Starting checkpoint**: This guide starts from [quarkus/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/03-with-history)

Make sure you've completed the previous guides:
- [Getting Started](/docs/quarkus/getting-started/) - Basic memory service integration
- [Conversation History](/docs/quarkus/conversation-history/) - History recording and APIs

## Conversation Forking

Conversation forking lets users branch off from any point in a conversation to explore alternative paths.

### Listing Forks

Add this method to `ConversationsResource.java` to list forks for a conversation:

```java
@GET
@Path("/{conversationId}/forks")
@Produces(MediaType.APPLICATION_JSON)
public Response listConversationForks(@PathParam("conversationId") String conversationId) {
    return proxy.listConversationForks(conversationId);
}
```

### How Forking Works

Forks are created implicitly when the first entry is appended to a new conversation with fork metadata. The Quarkus extension provides `@ForkedAtConversationId` and `@ForkedAtEntryId` annotations to thread fork metadata through your agent method. Add them to your `HistoryRecordingAgent`:

```java
@ApplicationScoped
public class HistoryRecordingAgent {

    private final Agent agent;

    @Inject
    public HistoryRecordingAgent(Agent agent) {
        this.agent = agent;
    }

    @RecordConversation
    public Multi<ChatEvent> chat(
            @ConversationId String conversationId,
            @UserMessage String userMessage,
            @ForkedAtConversationId String forkedAtConversationId,
            @ForkedAtEntryId String forkedAtEntryId) {
        return agent.chat(conversationId, userMessage, List.of());
    }
}
```

When the frontend sends a chat request with fork metadata (e.g., `forkedAtConversationId` and `forkedAtEntryId` in the SSE request), the `@RecordConversation` interceptor includes these fields in the `CreateEntryRequest`. If the target conversation doesn't exist yet, the memory service auto-creates it as a fork of the original conversation at the specified entry.

## Complete Example

**Completed code**: View the full implementation at [quarkus/examples/doc-checkpoints/04-conversation-forking](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/04-conversation-forking)

For a complete working example with frontend, see the [quarkus/examples/chat-quarkus](https://github.com/chirino/memory-service/tree/main/quarkus/examples/chat-quarkus) directory in the repository.

## Next Steps

- [Response Resumption](/docs/quarkus/response-resumption/) - Streaming responses with resume and cancel support.
- [Conversation Sharing](/docs/quarkus/sharing/) - Share conversations with other users.
- [Dev Services](/docs/quarkus/dev-services/) - Automatic memory-service container startup for development and testing.

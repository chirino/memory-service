---
layout: ../../../layouts/DocsLayout.astro
title: Quarkus Getting Started
description: Step-by-step guide to integrating Memory Service with your Quarkus AI agent.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';


This guide walks you through integrating Memory Service with a Quarkus AI agent. You'll start with basic chat memory and progressively add features like conversation history, listing conversations, forking, and response resumption.

## Prerequisites

- **Java 21** or later
- **Maven** (or use the included `./mvnw` wrapper)
- **Docker** (for Dev Services)

## Build from Source

> **Note:** This project is currently in the proof-of-concept (POC) phase and has not yet published any releases. You'll need to build it from source before using it in your project.

Clone the repository and build all modules:

```bash
git clone https://github.com/chirino/memory-service.git
cd memory-service
./mvnw -DskipTests clean install
```

This installs all project artifacts to your local Maven repository.

## Step 1: Create a Simple LangChain4j App

First, let's create a new [Quarkus](https://quarkus.io/get-started/) application with: 

```plain
quarkus create example
cd example
```

Add the LangChain4j OpenAI dependency to your `pom.xml`:

```xml
<dependency>
  <groupId>io.quarkiverse.langchain4j</groupId>
  <artifactId>quarkus-langchain4j-openai</artifactId>
  <version>1.5.0.CR2</version>
</dependency>
```

Create a simple AI service interface:

```java
package org.acme;

import io.quarkiverse.langchain4j.RegisterAiService;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
@RegisterAiService
public interface Agent {
    String chat(String userMessage);
}
```

Create a REST resource to expose the agent:

```java
package org.acme;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/chat")
public class ChatResource {

    @Inject
    Agent agent;

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    public String chat(String userMessage) {
        return agent.chat(userMessage);
    }
}
```

Configure your LLM in `application.properties` so it gets OpenAI credentials from the environment variables:

```properties
quarkus.langchain4j.openai.api-key=${OPENAI_API_KEY}
quarkus.langchain4j.openai.base-url=${OPENAI_BASE_URL:https://api.openai.com}/v1
```

Change the HTTP port to 9090 to avoid conflict with services that will be started later by updating `application.properties`:

```properties
quarkus.http.port=9090
```


Run your agent:

```bash
export OPENAI_API_KEY=your-api-key
./mvnw quarkus:dev
```

Test it with curl:

```bash
curl -i -s -X POST http://localhost:9090/chat \
  -H "Content-Type: text/plain" \
  -d "Hi, I'm Hiram, who are you?"

curl -i -s -X POST http://localhost:9090/chat \
  -H "Content-Type: text/plain" \
  -d "Who am I?"
```

This works, but you may have noticed that the agent has no memory.  Each request is independent.  Let's add conversation memory.

## Step 2: Add Memory Service Extension

Add the Memory Service extension to your `pom.xml`:

<Code lang="xml" code={`<dependency>
    <groupId>io.github.chirino.memory-service</groupId>
    <artifactId>memory-service-extension</artifactId>
    <version>${PROJECT_VERSION}</version>
</dependency>
`} />

Update the Agent interface to accept a conversation ID using the `@MemoryId` annotation:

```java
package org.acme;

import dev.langchain4j.service.MemoryId;
import io.quarkiverse.langchain4j.RegisterAiService;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
@RegisterAiService
public interface Agent {
    String chat(@MemoryId String conversationId, String userMessage);
}
```

Update the REST resource to accept a conversation ID:

```java
package org.acme;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/chat")
public class ChatResource {

    @Inject
    Agent agent;

    @POST
    @Path("/{conversationId}")
    @Consumes(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    public String chat(
            @PathParam("conversationId") String conversationId,
            String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}
```

Start the Memory Service in Docker Compose following the [Getting Started](/docs/getting-started/) guide.

Configure the agent to connect to the Memory Service by setting the `memory-service-client.url` and `memory-service-client.api-key` in `application.properties`:

```properties
memory-service-client.url=http://localhost:8082
memory-service-client.api-key=agent-api-key-1
```

The ChatMemory provider for the Memory Service extension requires that the user request is authenticated.  Configure the OIDC configuration in `application.properties`:
```properties
quarkus.oidc.auth-server-url=http://localhost:8081/realms/memory-service
quarkus.oidc.token-issuer=http://localhost:8081/realms/memory-service
quarkus.oidc.client-id=memory-service-client
quarkus.oidc.credentials.secret=change-me

quarkus.http.auth.permission.authenticated.paths=/chat/*
quarkus.http.auth.permission.authenticated.policy=authenticated
```

Run your agent again:

```bash
export OPENAI_API_KEY=your-api-key
./mvnw quarkus:dev
```

Login to Keycloak and get a bearer token using a username/password grant.

```bash
TOKEN=$(curl -s -X POST http://localhost:8081/realms/memory-service/protocol/openid-connect/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "client_id=memory-service-client" \
  -d "client_secret=change-me" \
  -d "grant_type=password" \
  -d "username=bob" \
  -d "password=bob" \
  | jq -r '.access_token')
```

Test it with curlâ€”now with conversation memory:

```bash
curl -i -s -X POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $TOKEN" \
  -d "Hi, I'm Hiram, who are you?"

curl -i -s -X POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $TOKEN" \
  -d "Who am I?"
```

The agent now remembers context within the same conversation ID!

If you browse to the demo agent app at `http://localhost:8080/`, you will see that a conversation has been created with the ID `3579aac5-c86e-4b67-bbea-6ec1a3644942`.
But it won't show any messages.  That's because we are not yet storing what we call the history of the conversation.  The only thing being stored is the agent memory, and 
that's not typically what you want to display to a user in a UI.  

## Step 3: Enable Conversation History Recording

To display conversation history in a frontend UI, wrap your agent with the `@RecordConversation` interceptor. This records both user messages and agent 
responses to the `history` channel (separate from the `memory` channel used by agents).

Create a wrapper class:

```java
package org.acme;

import io.github.chirino.memory.history.annotations.ConversationId;
import io.github.chirino.memory.history.annotations.RecordConversation;
import io.github.chirino.memory.history.annotations.UserMessage;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class HistoryRecordingAgent {

    private final Agent agent;

    @Inject
    public HistoryRecordingAgent(Agent agent) {
        this.agent = agent;
    }

    @RecordConversation
    public String chat(
            @ConversationId String conversationId, 
            @UserMessage String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}
```

The `@RecordConversation` interceptor automatically:
- Stores the user message before calling your method
- Stores the complete agent response after streaming completes

Use `HistoryRecordingAgent` in your endpoints instead of calling `Agent` directly.

Update the `ChatResource.java`:

```java
@Path("/chat")
public class ChatResource {

    @Inject
    HistoryRecordingAgent agent;

... existing code ...
```

Now test it again.

```bash
curl -i -s -X POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $TOKEN" \
  -d "Givem a random number between 1 and 100."
```

This time when you browse to to the demo agent app at 
[http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942](http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942) 
you should see the messages that were exchanged between you and the agent.

## Step 4: Expose Conversation Messages API

To let the frontend load a conversation's message history,
add a jackson dependencyto enable JSON serialization/deserialization to the `pom.xml`:

```xml
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-rest-jackson</artifactId>
</dependency>
```

Then create a REST resource that proxies requests to Memory Service:

```java
package org.acme;

import io.github.chirino.memory.client.model.MessageChannel;
import io.github.chirino.memory.runtime.MemoryServiceProxy;
import io.smallrye.common.annotation.Blocking;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Path("/v1/conversations")
@ApplicationScoped
@Blocking
public class ConversationsResource {

    @Inject 
    MemoryServiceProxy proxy;

    @GET
    @Path("/{conversationId}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getConversation(@PathParam("conversationId") String conversationId) {
        return proxy.getConversation(conversationId);
    }

    @GET
    @Path("/{conversationId}/messages")
    @Produces(MediaType.APPLICATION_JSON)
    public Response listConversationMessages(
            @PathParam("conversationId") String conversationId,
            @QueryParam("after") String after,
            @QueryParam("limit") Integer limit) {
        return proxy.listConversationMessages(
                conversationId, after, limit, MessageChannel.HISTORY, null);
    }
}
```

The `MemoryServiceProxy` is helper class that makes it easier to implement a JAXRS proxy to the memory service apis.  It handles:
- Authentication with the memory service
- Passing through the user's bearer token for authorization

The `MessageChannel.HISTORY` parameter ensures you get messages from the history channel (recorded by `@RecordConversation`) rather than the memory channel (used by agents internally).

Test it with curl:

```bash
curl -i -s -X GET http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/ \
  -H "Authorization: Bearer $TOKEN"

curl -i -s -X GET http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/messages \
  -H "Authorization: Bearer $TOKEN"
```

You should see the conversation and messages that were exchanged between you and the agent.

## Step 5: Expose Conversation Listing API

A more advanced frontend might want to list all conversations a user has had and display them in a list.
To let users see all their conversations, add these methods to the `ConversationsResource.java`:

```java
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response listConversations(
        @QueryParam("mode") String mode,
        @QueryParam("after") String after,
        @QueryParam("limit") Integer limit,
        @QueryParam("query") String query) {
    return proxy.listConversations(mode, after, limit, query);
}
```

Test it with curl:

```bash
curl -i -s -X GET http://localhost:9090/v1/conversations \
  -H "Authorization: Bearer $TOKEN"
```

The `listConversations` endpoint supports:
- **Pagination** via `after` (cursor) and `limit` parameters
- **Search** via the `query` parameter for filtering conversations
- **Mode** for different listing modes (e.g., `owned`, `shared`)

## Step 6: Expose Forking and Fork Listing APIs

Conversation forking lets users branch off from any point in a conversation to explore alternative paths. 
Add these methods to the `ConversationsResource.java` to enable forking and listing forks:

```java
@POST
@Path("/{conversationId}/messages/{messageId}/fork")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response forkConversationAtMessage(
        @PathParam("conversationId") String conversationId,
        @PathParam("messageId") String messageId,
        String body) {
    return proxy.forkConversationAtMessage(conversationId, messageId, body);
}

@GET
@Path("/{conversationId}/forks")
@Produces(MediaType.APPLICATION_JSON)
public Response listConversationForks(@PathParam("conversationId") String conversationId) {
    return proxy.listConversationForks(conversationId);
}
```

The fork endpoint creates a new conversation that:
- Copies all messages up to and exluding the specified message
- Creates a new conversation ID for the fork
- Links the fork back to the original conversation

Test it with curl:

```bash
FIRST_MESSAGE_ID=$(curl  -s -X GET http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/messages \
  -H "Authorization: Bearer $TOKEN" | jq -r '.data[0].id')

curl -i -s -X POST http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/messages/$FIRST_MESSAGE_ID/fork \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"title": "Alternative approach"}'
```

This will create a new conversation with the forkedAtConversationId `3579aac5-c86e-4b67-bbea-6ec1a3644942` and the title "Alternative approach", but you will will have a new ID.

If you browse to the to [http://localhost:8080/?conversationId=da597b28-5ccd-4900-92e9-0aec57394523](http://localhost:8080/?conversationId=da597b28-5ccd-4900-92e9-0aec57394523)
you will see that the first message now has fork.  If you pick that fork you will see that the conversation history of the new fork is empty, because the selected message is
not part of the fork, and we had selected the first message in the original conversation.

## Step 7: Enable Response Resumption

When users disconnect during a streaming response (page reload, network issues), you can resume the streaming response from where they left off.  This requires that
the agent uses streaming responses.  So before we can enable response resumption, we need to update the agent to use streaming responses.  This is done using 
`Multi<String>` return types instead of `String`.

Update the `Agent.java` to use streaming responses:

```java
package org.acme;

import dev.langchain4j.service.MemoryId;
import io.quarkiverse.langchain4j.RegisterAiService;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
@RegisterAiService
public interface Agent {
    Multi<String> chat(@MemoryId String conversationId, String userMessage);
}
```

Update the `HistoryRecordingAgent.java` to use streaming responses:

```java
package org.acme;

import io.github.chirino.memory.history.annotations.ConversationId;
import io.github.chirino.memory.history.annotations.RecordConversation;
import io.github.chirino.memory.history.annotations.UserMessage;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class HistoryRecordingAgent {

    private final Agent agent;

    @Inject
    public HistoryRecordingAgent(Agent agent) {
        this.agent = agent;
    }

    @RecordConversation
    public Multi<String> chat(@ConversationId String conversationId, @UserMessage String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}
```

Update `ChatResource.java` to use Server Sent Events (SSE) to stream the responses to the client:

```java
package org.acme;

import io.smallrye.mutiny.Multi;
import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/chat")
public class ChatResource {

    @Inject HistoryRecordingAgent agent;

    @POST
    @Path("/{conversationId}")
    @Consumes(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    public Multi<String> chat(
            @PathParam("conversationId") String conversationId, String userMessage) {
        return agent.chat(conversationId, userMessage);
    }
}

```

Test it with curl:

```bash
curl -N -i -s -X POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $TOKEN" \
  -d "Write a 4 paragraph story about a cat."
```

You should see the response streaming to your command line.

Now browse to the demo agent app at [http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942](http://localhost:8080/?conversationId=3579aac5-c86e-4b67-bbea-6ec1a3644942)
and you should see the response streaming to the browser.


### Add the Resume and Resume Check Endpoints

The following creates a REST endpoint that will allow us to:
* Check if a conversation has a response that is in progress
* Resume a response that is in progress
* Cancel a response that is in progress

```java
package org.acme;

import io.github.chirino.memory.history.runtime.ResponseResumer;
import io.github.chirino.memory.runtime.MemoryServiceProxy;
import io.quarkus.security.identity.SecurityIdentity;
import io.smallrye.common.annotation.Blocking;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import java.util.List;

import static io.github.chirino.memory.security.SecurityHelper.bearerToken;

@Path("/v1/conversations")
@ApplicationScoped
public class ResumeResource {

    @Inject ResponseResumer resumer;
    @Inject SecurityIdentity securityIdentity;
    @Inject MemoryServiceProxy proxy;

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Path("/resume-check")
    public List<String> check(List<String> conversationIds) {
        return resumer.check(conversationIds, bearerToken(securityIdentity));
    }

    @GET
    @Path("/{conversationId}/resume")
    @Blocking
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public Multi<String> resume(
            @PathParam("conversationId") String conversationId) {
        String bearerToken = bearerToken(securityIdentity);
        return resumer.replay(conversationId, "0", bearerToken);
    }

    @POST
    @Path("/{conversationId}/cancel")
    public Response cancelResponse(@PathParam("conversationId") String conversationId) {
        return proxy.cancelResponse(conversationId);
    }
}
```

Test it with curl:

```bash
curl -N -i -s -X POST http://localhost:9090/chat/3579aac5-c86e-4b67-bbea-6ec1a3644942 \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $TOKEN" \
  -d "Write a 4 paragraph story about a cat."
```

And while the response is streaming, you can check use the following to check to see if the conversation has responses in progress:

```bash
curl -i -s -X POST http://localhost:9090/v1/conversations/resume-check \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '["3579aac5-c86e-4b67-bbea-6ec1a3644942"]'
```

And to resume a conversation, you can run the following command in a new terminal:

```bash
curl -N -i -s -X GET http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/resume \
  -H "Authorization: Bearer $TOKEN"
```

You should see the response streaming to your command line.

## Canceling a Response

To cancel a response, you can run the following command:

```bash
curl -i -s -X POST http://localhost:9090/v1/conversations/3579aac5-c86e-4b67-bbea-6ec1a3644942/cancel \
  -H "Authorization: Bearer $TOKEN"
```

You should see the response get canceled.

## Complete Example

For a complete working example, see the `examples/agent-quarkus` directory in the repository:

This example is the demo agent application that getst started by the [Getting Started](/docs/getting-started/) guide.

{/* 
## Next Steps

- [REST Client](/docs/quarkus/rest-client/) - Direct API access for custom integrations
- [gRPC Client](/docs/quarkus/grpc-client/) - High-performance streaming
- [LangChain4j Integration](/docs/quarkus/langchain4j/) - Advanced memory patterns
- [Configuration](/docs/configuration/) - All configuration options 
*/}

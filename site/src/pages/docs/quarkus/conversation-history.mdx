---
layout: ../../../layouts/DocsLayout.astro
title: Conversation History
description: Record conversation history and expose APIs for frontend applications.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';
import CodeFromFile from '../../../components/CodeFromFile.astro';
import TestScenario from '../../../components/TestScenario.astro';
import CurlTest from '../../../components/CurlTest.astro';

This guide continues from [Getting Started](/docs/quarkus/getting-started/) and shows how to record conversation history and expose APIs for frontend applications.

## Prerequisites

**Starting checkpoint**: View the code from the previous section at [quarkus/examples/doc-checkpoints/02-with-memory](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/02-with-memory)

Make sure you've completed the [Getting Started](/docs/quarkus/getting-started/) guide first. You should have:
- A working Quarkus agent with the Memory Service extension
- Memory Service running via Docker Compose
- OIDC authentication configured

## Enable Conversation History Recording

In the [previous guide](/docs/quarkus/getting-started/), you added conversation memory, but messages don't appear in the UI yet. That's because we're only storing *agent memory*, not the *conversation history* that users see.

To display conversation history in a frontend UI, wrap your agent with the `@RecordConversation` interceptor. This records both user messages and agent responses to the `history` channel (separate from the `memory` channel used by agents).

Create a wrapper class:

<CodeFromFile
  file="quarkus/examples/doc-checkpoints/03-with-history/src/main/java/org/acme/HistoryRecordingAgent.java"
  lang="java"
/>

**What changed**: Created `HistoryRecordingAgent`, a CDI bean that wraps `Agent` and annotates the `chat` method with `@RecordConversation`, `@ConversationId`, and `@UserMessage`. **Why**: This wrapper separates the concern of history recording from the AI service interface. The `@RecordConversation` interceptor automatically saves the user's message and the agent's response to the Memory Service's `history` channel, making them available for display in a frontend UI without any manual recording code.

Update `ChatResource.java` to inject `HistoryRecordingAgent` instead of `Agent`:

<CodeFromFile
  file="quarkus/examples/doc-checkpoints/03-with-history/src/main/java/org/acme/ChatResource.java"
  lang="java"
  before={2}
>@Inject HistoryRecordingAgent agent</CodeFromFile>

**What changed**: The injected field was changed from `Agent` to `HistoryRecordingAgent`. **Why**: Routing calls through `HistoryRecordingAgent` instead of `Agent` directly activates the `@RecordConversation` interceptor, so every exchange is automatically persisted to the history channel without any additional code in the resource class.

<TestScenario checkpoint="quarkus/examples/doc-checkpoints/03-with-history">

Make sure you define a shell function that can get the bearer token for the bob user:

```bash
function get-token() {
  curl -sSfX POST http://localhost:8081/realms/memory-service/protocol/openid-connect/token \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=memory-service-client" \
    -d "client_secret=change-me" \
    -d "grant_type=password" \
    -d "username=bob" \
    -d "password=bob" \
    | jq -r '.access_token'
}
```

Now test it again.

<CurlTest steps={`
Then the response status should be 200
And the response should match pattern "\\d+"
`}>

```bash
curl -NsSfX POST http://localhost:9090/chat/a2e24090-9de7-411b-8b50-e8b9d709ec9a \
  -H "Content-Type: text/plain" \
  -H "Authorization: Bearer $(get-token)" \
  -d "Give me a random number between 1 and 100."
```

</CurlTest>

This time when you browse to to the demo agent app at
[http://localhost:8080/?conversationId=a2e24090-9de7-411b-8b50-e8b9d709ec9a](http://localhost:8080/?conversationId=a2e24090-9de7-411b-8b50-e8b9d709ec9a)
you should see the messages that were exchanged between you and the agent.

</TestScenario>

## Expose Conversation Entries API

To let the frontend load a conversation's entry history,
add a jackson dependency to enable JSON serialization/deserialization to the `pom.xml`:

<CodeFromFile
  file="quarkus/examples/doc-checkpoints/03-with-history/pom.xml"
  lang="xml"
  before={2}
  after={1}
>quarkus-rest-jackson</CodeFromFile>

**What changed**: Added the `quarkus-rest-jackson` dependency. **Why**: This enables automatic JSON serialization and deserialization for JAX-RS responses, which is needed for the conversation and entry list endpoints that return JSON from the Memory Service.

Then create a REST resource that proxies requests to Memory Service:

<CodeFromFile
  file="quarkus/examples/doc-checkpoints/03-with-history/src/main/java/org/acme/ConversationsResource.java"
  lang="java"/>

**What changed**: Created `ConversationsResource` with `getConversation` and `listConversationEntries` endpoints that delegate to an injected `MemoryServiceProxy`. **Why**: Agent apps should expose a subset of the Memory Service API to their frontends rather than giving clients direct access. The `MemoryServiceProxy` adds the service account API key for Memory Service authentication and passes through the caller's Bearer token so the Memory Service can enforce per-user access control.

The `Channel.HISTORY` parameter ensures you get entries from the history channel (recorded by `@RecordConversation`) rather than the memory channel (used by agents internally).

<TestScenario checkpoint="quarkus/examples/doc-checkpoints/03-with-history">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response body should be json:
"""
{
  "id": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
  "title": "%{response.body.title}",
  "ownerUserId": "bob",
  "createdAt": "%{response.body.createdAt}",
  "updatedAt": "%{response.body.updatedAt}",
  "accessLevel": "owner"
}
"""
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations/a2e24090-9de7-411b-8b50-e8b9d709ec9a/ \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

Example response:

```json
{
  "id": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
  "title": "Give me a random number between 1 and 10",
  "ownerUserId": "bob",
  "createdAt": "2025-01-10T14:32:05Z",
  "updatedAt": "2025-01-10T14:32:06Z",
  "accessLevel": "owner"
}
```

<CurlTest steps={`
Then the response status should be 200
And the response body should be json:
"""
{
  "data": [
    {
      "id": "%{response.body.data[0].id}",
      "conversationId": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
      "userId": "bob",
      "channel": "history",
      "contentType": "history",
      "content": [{"role": "USER", "text": "Give me a random number between 1 and 100."}],
      "createdAt": "%{response.body.data[0].createdAt}"
    },
    {
      "id": "%{response.body.data[1].id}",
      "conversationId": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
      "userId": "bob",
      "channel": "history",
      "contentType": "history",
      "content": [{"role": "AI", "text": "%{response.body.data[1].content[0].text}"}],
      "createdAt": "%{response.body.data[1].createdAt}"
    }
  ]
}
"""
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations/a2e24090-9de7-411b-8b50-e8b9d709ec9a/entries \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

Example response:

```json
{
  "data": [
    {
      "id": "0485af58-42f4-45a0-96f2-fa519ea86bc2",
      "conversationId": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
      "userId": "bob",
      "channel": "history",
      "contentType": "history",
      "content": [{"role": "USER", "text": "Give me a random number between 1 and 100."}],
      "createdAt": "2025-01-10T14:32:05Z"
    },
    {
      "id": "63fad673-d36f-4277-8460-ebe70820ae9f",
      "conversationId": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
      "userId": "bob",
      "channel": "history",
      "contentType": "history",
      "content": [{"role": "AI", "text": "Sure! The random number is 42."}],
      "createdAt": "2025-01-10T14:32:06Z"
    }
  ]
}
```

You should see the conversation and entries that were exchanged between you and the agent.

</TestScenario>

## Expose Conversation Listing API

To let users browse all their conversations, add a listing method to `ConversationsResource.java`:

<CodeFromFile
  file="quarkus/examples/doc-checkpoints/03-with-history/src/main/java/org/acme/ConversationsResource.java"
  lang="java"
  before={2}
  after={6}
>public Response listConversations</CodeFromFile>

**What changed**: Added a `listConversations` endpoint that accepts `mode`, `afterCursor`, `limit`, and `query` query parameters and forwards them to `MemoryServiceProxy`. **Why**: This gives frontends a paginated, filterable view of a user's conversations. The `mode` parameter can restrict results to conversations owned by the user or ones shared with them, while `query` enables keyword filtering without requiring a separate search index.

<TestScenario checkpoint="quarkus/examples/doc-checkpoints/03-with-history">

Test it with curl:

<CurlTest steps={`
Then the response status should be 200
And the response body should be json:
"""
{
  "data": [
    {
      "id": "%{response.body.data[0].id}",
      "title": "%{response.body.data[0].title}",
      "ownerUserId": "bob",
      "createdAt": "%{response.body.data[0].createdAt}",
      "updatedAt": "%{response.body.data[0].updatedAt}",
      "accessLevel": "owner"
    }
  ]
}
"""
`}>

```bash
curl -sSfX GET http://localhost:9090/v1/conversations \
  -H "Authorization: Bearer $(get-token)" | jq
```

</CurlTest>

Example response:

```json
{
  "data": [
    {
      "id": "a2e24090-9de7-411b-8b50-e8b9d709ec9a",
      "title": "Give me a random number between 1 and 10",
      "ownerUserId": "bob",
      "createdAt": "2025-01-10T14:32:05Z",
      "updatedAt": "2025-01-10T14:32:06Z",
      "accessLevel": "owner"
    }
  ]
}
```

</TestScenario>

## Completed Checkpoint

**Completed code**: View the full implementation at [quarkus/examples/doc-checkpoints/03-with-history](https://github.com/chirino/memory-service/tree/main/quarkus/examples/doc-checkpoints/03-with-history)

## Next Steps

Continue to:
- [Indexing and Search](/docs/quarkus/indexing-and-search/) — Add search indexing and semantic search to your conversations
- [Conversation Forking](/docs/quarkus/conversation-forking/) — Branch conversations to explore alternative paths
- [Response Resumption](/docs/quarkus/response-resumption/) — Streaming responses with resume and cancel support

---
layout: ../../../layouts/DocsLayout.astro
title: Quarkus REST Client
description: Using the Memory Service REST client in Quarkus applications.
---
import { Code } from 'astro:components';
import { PROJECT_VERSION } from '../../../config';

export const mavenDep = `<dependency>
  <groupId>io.github.chirino.memory-service</groupId>
  <artifactId>memory-service-extension</artifactId>
  <version>${PROJECT_VERSION}</version>
</dependency>`;

The Quarkus extension provides two ways to interact with Memory Service via REST:

1. **MemoryServiceProxy** - A helper class for building JAX-RS proxy endpoints that forward requests to the memory service
2. **Generated API Clients** - Type-safe REST clients for direct programmatic access

## Setup

The REST client is included in the extension:

<Code code={mavenDep} lang="xml" />

## Configuration

```properties
# Memory Service URL (auto-configured with Dev Services)
memory-service.client.url=http://localhost:8080

# API key for agent authentication
memory-service.client.api-key=your-api-key
```

These properties are aliased to `quarkus.rest-client.memory-service-client.*` automatically.

## Using MemoryServiceProxy

The `MemoryServiceProxy` is a helper class that makes it easier to implement JAX-RS endpoints that proxy requests to the memory service. It handles authentication and bearer token propagation automatically.

### Injecting the Proxy

```java
import io.github.chirino.memory.runtime.MemoryServiceProxy;

@ApplicationScoped
public class ConversationsResource {

    @Inject
    MemoryServiceProxy proxy;
}
```

### Conversations API

```java
import io.github.chirino.memory.client.model.Channel;
import jakarta.ws.rs.core.Response;

// List conversations
Response response = proxy.listConversations(mode, after, limit, query);

// Get a conversation
Response response = proxy.getConversation(conversationId);

// Create a conversation (body is JSON string)
Response response = proxy.createConversation(jsonBody);

// Delete a conversation
Response response = proxy.deleteConversation(conversationId);

// List conversation forks
Response response = proxy.listConversationForks(conversationId);
```

### Entries API

```java
// List conversation entries
// channel: Channel.HISTORY for user-visible messages, Channel.MEMORY for agent memory
// epoch: "latest", "all", or a numeric epoch identifier
// forks: "none" or "all"
Response response = proxy.listConversationEntries(
    conversationId, after, limit, Channel.HISTORY, epoch, forks);

// Append an entry (body is JSON string)
Response response = proxy.appendConversationEntry(conversationId, jsonBody);
```

### Sharing API

```java
// List memberships
Response response = proxy.listConversationMemberships(conversationId);

// Share a conversation (body is JSON string with userId and accessLevel)
Response response = proxy.shareConversation(conversationId, jsonBody);

// Update membership
Response response = proxy.updateConversationMembership(conversationId, userId, jsonBody);

// Remove membership
Response response = proxy.deleteConversationMembership(conversationId, userId);
```

### Ownership Transfers

```java
// List pending transfers
Response response = proxy.listPendingTransfers(role);

// Create ownership transfer
Response response = proxy.createOwnershipTransfer(jsonBody);

// Get transfer details
Response response = proxy.getTransfer(transferId);

// Accept transfer
Response response = proxy.acceptTransfer(transferId);

// Delete/cancel transfer
Response response = proxy.deleteTransfer(transferId);
```

### Search API

```java
// Search conversations (body is JSON SearchConversationsRequest)
Response response = proxy.searchConversations(jsonBody);

// Index entries (body is JSON array of IndexEntryRequest)
Response response = proxy.indexConversations(jsonBody);
```

### Response Cancellation

```java
// Cancel an in-progress response
Response response = proxy.cancelResponse(conversationId);
```

## Using Generated API Clients

For direct programmatic access without JAX-RS proxying, you can use the generated API clients with `MemoryServiceApiBuilder`:

```java
import io.github.chirino.memory.runtime.MemoryServiceApiBuilder;
import io.github.chirino.memory.client.api.ConversationsApi;
import io.github.chirino.memory.client.api.SearchApi;
import io.github.chirino.memory.client.api.SharingApi;
import io.github.chirino.memory.client.model.*;

@ApplicationScoped
public class MyService {

    @Inject
    MemoryServiceApiBuilder apiBuilder;

    public Conversation getConversation(String bearerToken, UUID conversationId) {
        ConversationsApi api = apiBuilder
            .withBearerAuth(bearerToken)
            .build(ConversationsApi.class);

        return api.getConversation(conversationId);
    }

    public ListConversations200Response listConversations(String bearerToken) {
        ConversationsApi api = apiBuilder
            .withBearerAuth(bearerToken)
            .build(ConversationsApi.class);

        return api.listConversations(
            "latest-fork",  // mode
            null,           // after cursor
            20,             // limit
            null            // query
        );
    }

    public ListConversationEntries200Response listEntries(
            String bearerToken, UUID conversationId) {
        ConversationsApi api = apiBuilder
            .withBearerAuth(bearerToken)
            .build(ConversationsApi.class);

        return api.listConversationEntries(
            conversationId,
            null,               // after cursor
            50,                 // limit
            Channel.HISTORY,    // channel
            "latest",           // epoch
            "none"              // forks
        );
    }
}
```

### Available API Classes

| API Class | Description |
|-----------|-------------|
| `ConversationsApi` | CRUD operations for conversations and entries |
| `SearchApi` | Semantic search and indexing |
| `SharingApi` | Memberships and ownership transfers |

## Error Handling

```java
import jakarta.ws.rs.WebApplicationException;

try {
    Response response = proxy.getConversation(conversationId);
    if (response.getStatus() == 404) {
        // Conversation not found
    }
} catch (WebApplicationException e) {
    int status = e.getResponse().getStatus();
    // Handle HTTP errors
}
```

## Complete Example

Here's a complete JAX-RS resource using `MemoryServiceProxy`:

```java
package org.acme;

import io.github.chirino.memory.client.model.Channel;
import io.github.chirino.memory.runtime.MemoryServiceProxy;
import io.smallrye.common.annotation.Blocking;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Path("/v1/conversations")
@ApplicationScoped
@Blocking
public class ConversationsResource {

    @Inject
    MemoryServiceProxy proxy;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response listConversations(
            @QueryParam("mode") String mode,
            @QueryParam("after") String after,
            @QueryParam("limit") Integer limit,
            @QueryParam("query") String query) {
        return proxy.listConversations(mode, after, limit, query);
    }

    @GET
    @Path("/{conversationId}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getConversation(
            @PathParam("conversationId") String conversationId) {
        return proxy.getConversation(conversationId);
    }

    @GET
    @Path("/{conversationId}/entries")
    @Produces(MediaType.APPLICATION_JSON)
    public Response listEntries(
            @PathParam("conversationId") String conversationId,
            @QueryParam("after") String after,
            @QueryParam("limit") Integer limit) {
        return proxy.listConversationEntries(
            conversationId, after, limit, Channel.HISTORY, null, null);
    }

    @DELETE
    @Path("/{conversationId}")
    public Response deleteConversation(
            @PathParam("conversationId") String conversationId) {
        return proxy.deleteConversation(conversationId);
    }
}
```

## Next Steps

- [gRPC Client](/docs/quarkus/grpc-client/) - For streaming and high-performance use cases
- [Conversation Forking](/docs/quarkus/conversation-forking/) - Branch conversations to explore alternative paths
- [Response Resumption](/docs/quarkus/response-resumption/) - Streaming responses with resume and cancel support
